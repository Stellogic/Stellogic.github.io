---
title: 全排列问题复杂度分析
date: 2025-09-15 09:19:35
categories:
  - 基本算法
tags:
  - 基本算法
  - 学习笔记
---

# 关于全排列问题的复杂度分析
### 关键代码回顾

为了方便对照，我们再看一下核心的剪枝逻辑：

<!-- more -->


1.  `!selected[i]`: 确保同一个**位置**的元素不会被重复使用（这是所有排列问题共有的）。
2.  `!duplicated.contains(choice)`: **剪枝核心**。确保在当前递归层级，对于**数值相同**的元素，只选择第一个未经访问的进行递归。
---

### `nums = [1, 1, 2]` 的递归树

下面是 `backtrack` 函数为 `[1, 1, 2]` 生成全排列的递归树。树的每一层代表排列中的一个位置。

```
                                       backtrack(state=[], choices=[1,1,2]，selected=[F,F,F])
                                                     |
                                                     | for i = 0..2
                         +---------------------------+---------------------------+
                         | i=0, choice=1             | i=1, choice=1             | i=2, choice=2
                         | duplicated.add(1)         | duplicated.contains(1)?   | duplicated.add(2)
                         |                           | --> YES. PRUNED! (剪枝!)  |
                         |                           | (在这一层，1已经用过了)     |
                         V                           X                           V
        backtrack(state=[1], choices=[1,1,2], selected=[T,F,F])      backtrack(state=[2], choices=[1,1,2], selected=[F,F,T])
                         |                                                           |
                         | for i = 0..2                                              | for i = 0..2
     +-------------------+-------------------+                         +-------------+-------------+
     | i=0, selected[0]? | i=1, choice=1     | i=2, choice=2           | i=0, choice=1 | i=1, choice=1 | i=2, selected[2]?
     | --> YES. Skip.    | duplicated.add(1) | duplicated.add(2)       | dup.add(1)    | dup.contains(1)?| --> YES. Skip.
     |                   |                   |                         |             | --> YES. PRUNED!|
     V                   V                   V                         V             X             V
 backtrack(state=[1,1],...)| backtrack(state=[1,2],...)|           backtrack(state=[2,1],...)
     selected=[T,T,F]    |     selected=[T,F,T]    |               selected=[T,F,T]
                         |                         |                               |
                         | for i = 0..2            | for i = 0..2                  | for i = 0..2
     +-------------------+     +-------------------+               +-------------------+
     | i=0, selected? YES|     | i=0, selected? YES|               | i=0, selected? YES|
     | i=1, selected? YES|     | i=1, choice=1     |               | i=1, choice=1     |
     | i=2, choice=2     |     | i=2, selected? YES|               | i=2, selected? YES|
     | state.size()==3   |     | state.size()==3   |               | state.size()==3   |
     V                   V     V                   V               V                   V
   res.add([1,1,2])    (backtrack) res.add([1,2,1]) (backtrack)   res.add([2,1,1])    (backtrack) 
   ```





**树的解读：**

1.  **根节点 (第0层):** `state` 为空。
    *   `for` 循环开始，`i=0`，选择 `nums[0]` (值为1)。进入下一层递归。
    *   `i=1`，选择 `nums[1]` (值也为1)。但此时 `duplicated` 集合中已经包含了1，所以这个分支被**剪掉**了！这是避免重复排列的关键。
    *   `i=2`，选择 `nums[2]` (值为2)。进入下一层递归。

2.  **第1层:**
    *   **左侧分支 (state=):**
        *   `for` 循环遍历 `[1,1,2]`。`nums[0]` 已被选择 (`selected[0]`为true)，跳过。
        *   `i=1`，选择 `nums[1]` (值为1)。进入下一层。
        *   `i=2`，选择 `nums[2]` (值为2)。进入下一层。
    *   **右侧分支 (state=):**
        *   `for` 循环遍历 `[1,1,2]`。
        *   `i=0`，选择 `nums[0]` (值为1)。进入下一层。
        *   `i=1`，选择 `nums[1]` (值也为1)。但本层的 `duplicated` 集合已经有1了，**剪枝**！
        *   `i=2` 已被选择，跳过。

3.  **叶子节点 (第3层):**
    *   当 `state` 的长度达到3时，就找到了一个完整的排列。
    *   例如，从左侧分支一路下来，得到 `[1, 1, 2]`。这个排列被复制并添加到最终结果 `res` 中。
    *   然后函数返回（回溯），尝试其他可能性。

---

### 从递归树分析复杂度

#### 1. 时间复杂度: O(n × n!)

*   **树的节点总数 (决定了 `backtrack` 函数被调用的次数):**
    *   如果没有重复元素（例如 `[1, 2, 3]`），第0层有 `n` 个选择，第1层有 `n-1` 个选择，...，最后一层有1个选择。
    *   整棵树的节点总数大约是 `n + n(n-1) + ... + n! ≈ O(n!)`。
    *   虽然我们的剪枝策略砍掉了很多分支，但在进行复杂度分析时，我们通常考虑最坏情况，即所有元素都不同。因此，递归调用的总次数（即树的节点总数）是 O(n!) 级别的。

*   **每个节点内部的操作耗时:**
    *   在树的**非叶子节点**，主要操作是 `for` 循环，它会执行 `n` 次。循环内部的操作（如 `contains`, `add`）是 O(1) 的。所以每个非叶子节点的时间开销是 O(n)。
    *   在树的**叶子节点**，当 `state.size() == choices.length` 时，会执行 `res.add(new ArrayList<Integer>(state))`。这个操作需要创建一个新列表并把 `state` 中的 `n` 个元素复制过去，时间开销是 **O(n)**。

*   **综合计算:**
    *   算法的总时间主要由两部分构成：构建树的开销和在叶子节点复制结果的开销。
    *   叶子节点的数量就是最终不重复排列的数量，这个数量级是 O(n!)。
    *   仅仅是把所有叶子节点的结果复制到 `res` 列表中的总时间就是：**(叶子节点数量) × (每次复制的时间) ≈ O(n!) × O(n) = O(n × n!)**。
    *   这个开销是算法时间复杂度的主要部分，因此总时间复杂度为 **O(n × n!)**。

#### 2. 空间复杂度: O($n^2$)

空间复杂度我们看的是算法在任意时刻需要占用的最大辅助空间。

*   **递归调用栈的深度:**
    *   从树的结构可以清晰地看到，从根节点到最深的叶子节点，路径的长度是 `n`。这意味着 `backtrack` 函数最多会嵌套调用 `n` 次。
    *   因此，递归调用栈所占用的空间是 **O(n)**。

*   **辅助数据结构:**
    *   `state` 列表：在递归过程中，它存储了当前的路径，其最大长度为 `n`。占用 O(n) 空间。
    *   `selected` 数组：长度始终为 `n`。占用 O(n) 空间。
    *   `duplicated` 集合：这个集合是在**每个**函数调用栈帧内创建的局部变量。因此，到最深时是1+2+3+……+n,是O(n^2)
    
*   **综合计算:**
    *   因此，总的辅助空间复杂度是 O(n) + O(n) + O(n^2) = **O(n^2)**。
    *   （注意：这不包括存储最终结果的 `res` 列表。如果算上它，空间复杂度将是 O(n × n!)）。
