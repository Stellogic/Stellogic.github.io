---
title: 搜索
date: 2025-09-15 09:19:35
categories:
  - 基本算法
tags:
  - 基本算法
  - 学习笔记
---

# 暴力搜索
* 线性搜索：常用于数组链表等线性结构
* 广度优先和深度优先：用于图树
<br>
**优点是通用简单，无需预处理数据，也不需要额外的数据结构**
<br>时间复杂度O(N)

<!-- more -->

# 自适应搜索
## 二分查找
用于数组，需要有序性。
```java
/* 二分查找（双闭区间） */
int binarySearch(int[] nums, int target) {
    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素
    int i = 0, j = nums.length - 1;
    // 循环，当搜索区间为空时跳出（当 i > j 时为空）
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target) // 此情况说明 target 在区间 [m+1, j] 中
            i = m + 1;
        else if (nums[m] > target) // 此情况说明 target 在区间 [i, m-1] 中
            j = m - 1;
        else // 找到目标元素，返回其索引
            return m;
    }
    // 未找到目标元素，返回 -1
    return -1;
}
```
**中点选取一般使用i+(j-i)/2得到向下取整的(i+j)/2,防止整数溢出**
<br>
### 还可以用于处理查找插入位置的问题
<br>
给定一个长度为n的有序数组 nums 和一个元素 target ，数组可能存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。若数组中已存在元素 target ，则插入到其左方。请返回插入后 target 在数组中的索引。

```java
/* 二分查找插入点（存在重复元素） */
int binarySearchInsertion(int[] nums, int target) {
    int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]
    while (i <= j) {
        int m = i + (j - i) / 2; // 计算中点索引 m
        if (nums[m] < target) {
            i = m + 1; // target 在区间 [m+1, j] 中
        } else if (nums[m] > target) {
            j = m - 1; // target 在区间 [i, m-1] 中
        } else {
            j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中
        }
    }
    // 返回插入点 i
    return i;
}
```
i,j是循环不变量。
<br>
i始终保持[0,i-1]处的元素小于target
<br>
j始终保持[j+1,length-1]处的元素大于等于target
<br>
因此最终当j>i时循环停止，i指向首个大于或者等于target的元素，也就是插入的位置
### 查找左边界
实际上和上面查找插入点类似，只是需要额外在不包含target时返回-1
<br>
如果不包含target有两种结果
* i越界等于length
* nums[1] != target
```java
/* 二分查找最左一个 target */
int binarySearchLeftEdge(int[] nums, int target) {
    // 等价于查找 target 的插入点
    int i = binary_search_insertion.binarySearchInsertion(nums, target);
    // 未找到 target ，返回 -1
    if (i == nums.length || nums[i] != target) {
        return -1;
    }
    // 找到 target ，返回索引 i
    return i;
}
```

### 查找右边界
1. 通用解法还是去替换nums[m] == target情况下的指针操作
<br>
此时把i = m+1
<br>
这样，
<br>
循环不变量i保持[0,i-1]的元素始终小于等于target
<br>
j始终保持[j+1,length-1]元素大于target
<br>
因此最终j指向从右侧起的第一个小于等于target的元素，如果恰好target存在，那么j即为右边界

2. 取巧方法（至少保证**数据离散**，下面默认数组只有**整数**）
* 把查找最右边的target转化为查找最左边的target+1<br>
这样的话i - 1就是有边界，如果target存在的话
* 查找最左边的 等价于 查找target-0.5,并返回i（i是第一个大于大于target-0.5的元素就是第一个target）
<br>
查找最右边的 等价于 查找target+0.5，并返回j（j是从右边开始第一个小于等于target+0.5的，也就是最右边的target）

### 使用哈希表优化
两数之和问题
<br>
给定一个整数数组 nums 和一个目标元素 target ，请在数组中搜索“和”为 target 的两个元素，并返回它们的数组索引。保证只有唯一一组解
```java
/* 方法一：暴力枚举 */
int[] twoSumBruteForce(int[] nums, int target) {
    int size = nums.length;
    // 两层循环，时间复杂度为 O(n^2)
    for (int i = 0; i < size - 1; i++) {
        for (int j = i + 1; j < size; j++) {
            if (nums[i] + nums[j] == target)
                return new int[] { i, j };
        }
    }
    return new int[0];
}
```
上面暴力枚举，下面使用哈希表优化
```java
/* 方法二：辅助哈希表 */
int[] twoSumHashTable(int[] nums, int target) {
    int size = nums.length;
    // 辅助哈希表，空间复杂度为 O(n)
    Map<Integer, Integer> dic = new HashMap<>();
    // 单层循环，时间复杂度为 O(n)
    for (int i = 0; i < size; i++) {
        if (dic.containsKey(target - nums[i])) {
            return new int[] { dic.get(target - nums[i]), i };
        }
        dic.put(nums[i], i);
    }
    return new int[0];
}
```
把元素的值作为key，索引作为value。

## 哈希查找：
把搜索数据和目标数据建立为键值对映射
## 树查找：
对于指定的树搜索（比如二叉搜索树）

复杂度总结

||线性搜索|              二分查找              |树查找（很多时候指的是二叉搜索树）|哈希查找|
|:---:|:---:|:------------------------------:|:---:|:---:|
|查找元素|O(n)|            O(logn)             |O(logn)|O(1)|
|插入|O(1),（实际上指的给数组链表插入，因为线性搜索不要求顺序因此可以直接插在动态数组末尾或者链表首部）|      O(n)，（有序，只能插入特定的位置）       |O（logn)|O(1)|
|删除特定元素|O(n)（不管数组还是链表，都要先遍历到特定元素消耗一个O(n)）|O(n)(注意链表一般不用二分搜索，因为无法以O(1)找到中点)|O(logn)|O(1)|
|额外空间|O(1)|              O(1)              |O(n)|O(n)|
|数据预处理||           排序O(nlogn)           |建树O(nlogn)|建表O(n)|
|数据是否有序|无序|               有序               |有序|无序|



复习一下树和哈希表