---
title: 回溯复杂度分析
date: 2025-09-15 09:19:35
categories:
  - 基本算法
tags:
  - 基本算法
  - 学习笔记
---

### 回溯算法复杂度分析的核心思想

分析回溯算法的时间复杂度，本质上是在分析其递归搜索树的规模。因为回溯算法在最坏情况下会遍历整个解空间树，所以其时间复杂度通常是指数级别或阶乘级别的。  

<!-- more -->


其实就是[递归复杂度分析.md](%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md)中的递归树的方法

一个通用的、简化的分析公式是：

**时间复杂度 ≈ 递归调用次数 × 每次递归中执行的操作数**

更精确地说，这可以分解为两个关键部分的分析：
1.  **解空间树的节点总数**：这代表了递归函数被调用的最多次数。
2.  **每个节点上的操作耗时**：这指的是在单次递归函数调用中，除了递归调用自身之外，其他操作（如循环、判断、添加结果等）所花费的时间。

分析起来可能比较困难，但我们可以通过估算递归代码将计算多少个不同的状态，以及在每个递归调用中发生了多少次操作来进行估计。

---

### 分析回溯算法复杂度的思考顺序

遵循以下步骤，可以帮助你清晰、准确地分析出回溯算法的时间复杂度。

#### 第一步：画出（或想象出）递归搜索树

这是最重要的一步。你需要明确算法的搜索过程是怎样的，这通常可以用一棵树来表示。

*   **树的宽度（分支因子）**：在递归的每一层，你有多少种选择？这决定了每个节点有多少个子节点。
*   **树的深度**：递归会进行多少层？这通常与输入数据的规模 `n` 相关。

**示例：**
*   **全排列问题**：对于 `n` 个不同的元素，第一层有 `n` 个选择，第二层有 `n-1` 个选择，以此类推。
*   **子集问题**：对于 `n` 个元素，每个元素都有“选”和“不选”两种状态，所以每层都有 2 个分支。

#### 第二步：计算递归树的节点总数

根据递归树的结构，估算树中节点的总数。这是复杂度的主要决定因素。

*   **排列问题 (Permutations)**：
    *   输入 `[1, 2, 3]` 的递归树，第一层有3个节点，第二层每个节点下有2个分支，第三层有1个分支。叶子节点的数量是 `3 * 2 * 1 = 3!`。
    *   总的节点数大约是 `n!` 级别的。
    *   **复杂度估算**：通常为 **O(n!)**。

*   **子集问题 (Subsets) / 组合问题 (Combinations)**：
    *   对于 `n` 个元素，每个元素都有“选”与“不选”两种可能，因此解空间的大小是 `2^n`。
    *   递归树的深度为 `n`，节点总数是 `1 + 2 + 4 + ... + 2^n`，这是一个等比数列，总和约为 `2^n`。
    *   **复杂度估算**：通常为 **O(2^n)**。

*   **N皇后问题 (N-Queens)**：
    *   第一行皇后有 `N` 个位置可选，第二行最多有 `N-1` 个，以此类推。
    *   虽然看起来是 `N* (N-1) * ...`，但由于剪枝（皇后间的攻击规则），实际搜索空间远小于 `N^N`，但大于 `N!`。不过在最坏情况下的上界分析中，通常近似为 **O(N!)**。

*   **解数独 (Sudoku Solver)**：
    *   假设有 `m` 个空格需要填。每个空格最多有 9 种选择。
    *   **复杂度估算**：最坏情况下是 **O(9^m)**，其中 `m` 是待填空格的数量。

#### 第三步：分析单次递归调用的时间复杂度

现在，看你的 `backtrack` 函数内部，除了递归调用 `backtrack(...)` 之外，还做了哪些操作？

*   **循环**：函数内部是否有 `for` 循环？循环的次数是多少？
    *   例如，在全排列问题中，`for` 循环遍历所有选择，复杂度为 O(n)。
    *   在组合问题中，`for` 循环也可能遍历 O(n) 次。
*   **构造结果**：当找到一个合法解时（通常在递归的叶子节点），需要将当前路径（`path`）复制一份并存入最终结果（`result`）中。
    *   如果路径的长度是 `k`，那么这个复制操作的耗时就是 O(k)。在很多问题中，路径的最大长度是 `n`，所以这里耗时 O(n)。

#### 第四步：整合计算，得出最终复杂度

将前两步的结果相乘，并进行简化。

*   **全排列问题 (Permutations of n distinct elements)**：
    *   节点总数（叶子节点）：`n!`
    *   到达每个叶子节点时，需要 O(n) 的时间复制路径。
    *   **总时间复杂度**：`O(n * n!)`。

*   **子集问题 (Subsets of n elements)**：
    *   节点总数：`2^n`
    *   每个子集都需要被拷贝到结果列表中，平均长度为 O(n)。
    *   **总时间复杂度**：`O(n * 2^n)`。

*   **组合问题 (Combinations - C(n, k))**：
    *   节点总数（叶子节点）：`C(n, k)`
    *   每个组合的长度是 `k`，复制耗时 O(k)。
    *   **总时间复杂度**：`O(k * C(n, k))`。

#### 第五步：考虑剪枝的影响

回溯算法的精髓在于“剪枝”（Pruning），即提前终止那些不可能产生合法解的搜索路径。

*   **对于复杂度分析**：通常我们分析的是**最坏情况时间复杂度**，此时可以不考虑剪枝带来的优化，或者只考虑那些非常明确、一定会发生的剪枝。
*   **剪枝的意义**：虽然最坏时间复杂度可能不变，但剪枝能极大地优化算法在平均情况下的性能，使其能够处理更大规模的数据。例如，在N皇后问题中，剪枝是算法能够实际运行的关键。

### 总结与范例

| 问题类型 | 递归树特点 | 节点/状态数 | 单次操作耗时 | 最终时间复杂度 |
| :--- | :--- | :--- | :--- | :--- |
| **全排列** | 深度为n，每层分支数递减 (n, n-1, ...) | O(n!) | O(n) (复制结果) | **O(n * n!)** |
| **子集** | 深度为n，每层分支数为2 | O(2^n) | O(n) (复制结果) | **O(n * 2^n)** |
| **组合** | 深度为k，分支数变化 | O(C(n, k)) | O(k) (复制结果) | **O(k * C(n, k))** |
| **N皇后** | 深度为N，分支数 <= N | O(N!) | O(N) 或 O(1) (检查合法性) | **O(N!)** |

记住，分析回溯算法的复杂度不需要像数学推导那样百分之百精确，尤其是在面试中。关键是能够清晰地画出递归树模型，并基于模型估算出复杂度的量级，讲清楚你的分析思路。



***

# **下面是子集和问题的复杂度分析**

### 详细分析过程

#### 第一步：画出（或想象出）递归搜索树

这是理解算法行为的核心。我们以一个具体的例子来可视化这棵树：`nums = [2, 3, 6]`, `target = 7`。

```
                      ([], target=7, start=0)
                     /           |           \
         (i=0, pick 2)     (i=1, pick 3)     (i=2, pick 6)
                   /             |             \
      ([2], target=5, start=0)  ([3], target=4, start=1)  ([6], target=1, start=2)
      /         |         \           /         \           \
(i=0, p 2) (i=1, p 3) (i=2, p 6) (i=1, p 3) (i=2, p 6)     (i=2, p 6) -> Pruned (1-6<0)
    /           |         |           |         \
([2,2], t=3) ([2,3], t=2) ([2,6], t=-1) ([3,3], t=1) ([3,6], t=-2)
   ...          ...       Pruned!       ...       Pruned!
    |
([2,2,3], t=0) -> Found a solution!
```

从这棵树中，我们可以观察到两个重要特性：

1.  **树的宽度（分支数量）**：在树的任意一个节点，它要向下递归的分支数量最多是 `n` 个（即 `nums` 数组的长度）。因为 `for` 循环从 `start` 开始，所以分支数会小于等于 `n`。
2.  **树的深度**：树的深度不是固定的 `n`。它取决于 `target` 的大小和 `nums` 中元素的大小。在最坏的情况下，如果我们每次都选择 `nums` 中最小的元素（假设 `min_val`），那么递归的最大深度将是 `target / min_val`。为了简化，我们称其深度为 `D`，其中 `D` 约等于 `target`。

#### 第二步：计算递归树的节点总数

由于这不是一棵结构规整的 `2^n` 或 `n!` 树，精确计算节点数非常困难。但我们可以估算一个**上界**。

*   **分支因子 (Branching Factor)**：最多为 `n`。
*   **最大深度 (Max Depth)**：最多为 `target / min_val`。

在不考虑任何剪枝的情况下，这棵树的节点总数可以粗略地估算为 **O(n^D)**，即 **O(n^(target/min_val))**。

这个估算虽然非常粗略，但它正确地指出了复杂度的关键：**它对 `target` 的值是指数级的，对 `n` 也是指数级的**。剪枝（`target - choices[i] < 0`）会砍掉很多分支，但最坏情况下的复杂度量级依然是这个。

#### 第三步：分析单次递归调用的时间复杂度

现在我们看 `backtrack` 函数内部做了什么（除了递归调用本身）：

1.  `if (target == 0)`：这是一个 O(1) 的判断。
2.  `res.add(new ArrayList<>(state))`: **这是一个关键操作**。当找到一个解时，需要将当前的 `state` (路径) 复制一份放入结果集 `res` 中。如果 `state` 的长度是 `k`，这个复制操作的时间复杂度就是 O(k)。在我们的问题中，路径的最大长度 `k` 不会超过 `target`（因为 `nums` 里的都是正整数），所以这里的时间是 **O(target)**。
3.  `for` 循环：`for (int i = start; i < choices.length; i++)`。这个循环最多执行 `n` 次。
4.  循环内部：`state.add()` 和 `state.remove()` 通常可以看作是 O(1) 的操作。

所以，在每个**非叶子节点**，主要耗时是 `for` 循环，为 O(n)。在每个**作为解的叶子节点**，主要耗时是复制结果，为 O(target)。

#### 第四步：整合计算，得出最终复杂度

**时间复杂度：**

时间复杂度主要由两部分构成：
1.  遍历整个搜索树的成本。
2.  找到解时，复制解的成本。

综合来看，总的时间复杂度由**搜索树的节点总数**主导。

*   **总节点数**：如上分析，约为 O(n^(target/min_val))。
*   **每个节点的操作**：主要是 O(n) 的循环。

因此，一个比较宽松的上界是 `节点数 * 每个节点的操作`，但这并不精确。更通用的做法是直接用搜索空间的大小来表示复杂度。

最终，该算法的时间复杂度被认为是 **O(n^(target/min_val))**。这是一个比较标准的对这类问题的复杂度描述，它清晰地表达了算法性能与 `n` 和 `target` 的指数关系。

**空间复杂度：**

空间复杂度也由两部分构成：
1.  **递归调用栈的深度**：即我们递归树的最大深度。如前所述，最大深度是 `D = target / min_val`。所以这部分的复杂度是 **O(target)**。
2.  **临时状态 `state` 的空间**：`state` 列表存储了当前的组合路径，其最大长度也是递归的深度，所以也是 **O(target)**。

因此，**不包括存储最终结果 `res` 的空间**，算法的辅助空间复杂度是 **O(target)**。

---

### 总结

对该“组合总和”问题的回溯算法复杂度分析如下：

*   **思考顺序**：
    1.  **识别问题类型**：意识到这是“组合总和”问题，元素可重复使用。
    2.  **构建递归树模型**：确定树的宽度（分支数，~`n`）和深度（~`target`）。
    3.  **估算搜索空间**：根据宽度和深度，估算出节点总数的量级为 O(n^target)。
    4.  **分析单点操作**：找出函数内最耗时的操作，如循环（O(n)）和结果复制（O(target)）。
    5.  **整合复杂度**：确定时间复杂度由搜索空间大小主导，即 O(n^target)。分析空间复杂度由递归深度主导，即 O(target)。

*   **最终结论**：
    *   **时间复杂度**: **O(n^(target/min_val))**。其中 `n` 是候选数字的个数，`target` 是目标和，`min_val` 是候选数字中的最小值。这个复杂度表示算法的性能在最坏情况下与 `n` 和 `target` 呈指数关系。
    *   **空间复杂度**: **O(target)**。这主要是由递归栈的深度和存储当前路径的临时列表所决定的（不计入存储所有结果所需的空间）。

