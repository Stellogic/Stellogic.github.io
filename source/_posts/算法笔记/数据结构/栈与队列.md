---
title: 栈与队列
date: 2025-09-15 09:27:31
categories:
  - 数据结构
tags:
  - 数据结构
  - 学习笔记
---


# 栈、队列与双端队列核心笔记

## 1. 栈 (Stack)

### 1.1 定义与原则
栈是一种 **后进先出 (Last-In, First-Out, LIFO)** 的线性数据结构。所有操作均在数据结构的同一端——**栈顶 (Top)** 进行。

<!-- more -->


### 1.2 核心操作

| 操作 | 描述 | 时间复杂度 |
| :--- | :--- | :--- |
| `push(element)` | 将元素压入栈顶 | O(1) |
| `pop()` | 移除并返回栈顶元素 | O(1) |
| `peek()` | 查看栈顶元素，不移除 | O(1) |
| `isEmpty()` | 检查栈是否为空 | O(1) |
| `size()` | 返回栈中元素数量 | O(1) |

### 1.3 实现方式

#### 1.3.1 基于数组 (ArrayStack)
*   **机制**: 使用动态数组（如 `ArrayList`）实现，将数组的**尾部**视为栈顶。
*   **优点**:
    *   内存连续，CPU缓存命中率高，访问速度快。
    *   实现简单。
*   **缺点**:
    *   `push` 操作在数组容量不足时会触发扩容，导致该次操作的**最坏时间复杂度为 O(N)**。其**均摊时间复杂度**为 O(1)。

#### 1.3.2 基于链表 (LinkedListStack)
*   **机制**: 使用单向链表实现，将链表的**头节点**视为栈顶。
*   **优点**:
    *   所有操作的时间复杂度均为**稳定的 O(1)**。
    *   空间按需分配，无容量限制。
*   **缺点**:
    *   每个节点需要额外空间存储指针，内存开销较大。
    *   内存不连续，缓存性能可能较差。

### 1.4 核心应用场景
*   **函数调用栈**: 管理函数调用的上下文信息。
*   **表达式求值**: 中缀表达式转后缀（逆波兰）表达式并计算。
*   **括号匹配**: 校验字符串中的括号是否合法。
*   **深度优先搜索 (DFS)**: 图与树的遍历（递归或非递归实现）。
*   **撤销/重做功能**: 编辑器中的 Undo/Redo 操作。
*   **单调栈**: 解决“下一个更大/更小元素”等问题。

---

## 2. 队列 (Queue)

### 2.1 定义与原则
队列是一种 **先进先出 (First-In, First-Out, FIFO)** 的线性数据结构。元素从**队尾 (Rear)** 加入，从**队首 (Front)** 离开。

### 2.2 核心操作

| 操作 | 描述 | 时间复杂度 |
| :--- | :--- | :--- |
| `push(element)` | 元素在队尾入队 | O(1) |
| `pop()` | 队首元素出队并返回 | O(1) |
| `peek()` | 查看队首元素，不移除 | O(1) |
| `isEmpty()` | 检查队列是否为空 | O(1) |
| `size()` | 返回队列中元素数量 | O(1) |

### 2.3 实现方式

#### 2.3.1 基于环形数组 (ArrayQueue)
*   **机制**: 使用固定长度的数组，通过 `front` 指针和 `size` 计数器（或 `front` 和 `rear` 两个指针）实现。指针移动通过**取模运算** `(index + 1) % capacity` 实现循环，避免了数据迁移。
*   **优点**:
    *   所有操作均为稳定的 O(1) 时间复杂度。
    *   内存连续，缓存友好。
*   **缺点**:
    *   容量固定，无法动态扩展。

#### 2.3.2 基于链表 (LinkedListQueue)
*   **机制**: 使用单向链表，维护 `front` 和 `rear` 两个指针分别指向头节点和尾节点。
*   **优点**:
    *   动态容量，无空间限制。
    *   所有操作均为稳定的 O(1) 时间复杂度。
*   **缺点**:
    *   额外的指针内存开销。
    *   内存不连续。

### 2.4 核心应用场景
*   **广度优先搜索 (BFS)**: 图与树的层序遍历。
*   **资源调度**: 操作系统的任务调度、线程池的任务队列。
*   **消息队列 (MQ)**: 在分布式系统中用于解耦、异步通信和流量削峰。
*   **缓存淘汰策略**: 实现 FIFO 缓存。

---

## 3. 双端队列 (Deque)

### 3.1 定义与原则
双端队列 (Double-Ended Queue) 是栈和队列的泛化，允许在**队首和队尾两端**进行插入和删除操作。

### 3.2 核心操作
包含队首和队尾两套对称的操作：`pushFirst`, `pushLast`, `popFirst`, `popLast`, `peekFirst`, `peekLast`。所有核心操作的时间复杂度均为 O(1)。

### 3.3 实现方式

#### 3.3.1 基于环形数组 (ArrayDeque)
*   **机制**: 与环形队列类似，但 `front` 指针可以双向移动。为防止负数索引，`front` 向前移动的逻辑为 `(front - 1 + capacity) % capacity`。
*   **优点**:
    *   功能强大，高性能，是 Java 中实现栈和队列的**首选推荐**。
*   **缺点**:
    *   容量固定（尽管 Java 的 `ArrayDeque` 实现了自动扩容）。

#### 3.3.2 基于双向链表 (LinkedListDeque)
*   **机制**: 必须使用**双向链表**，每个节点包含 `prev` 和 `next` 两个指针，以支持在两端进行 O(1) 的删除操作。
*   **优点**:
    *   动态容量，实现灵活。
*   **缺点**:
    *   指针的内存开销是所有实现中最大的。

### 3.4 核心应用场景
*   **实现栈和队列**: 可同时作为栈（使用 `pushFirst`/`popFirst`）和队列（使用 `pushLast`/`popFirst`）使用。
*   **滑动窗口问题**: 高效求解滑动窗口中的最值问题（维护一个单调的双端队列）。
*   **历史记录管理**: 如浏览器的前进/后退功能。

---

## 4. 总结与选择

| 特性 | 数组实现 | 链表实现 |
| :--- | :--- | :--- |
| **时间复杂度** | **入/出队/栈**: 平均 O(1)。数组扩容时最坏为 O(N)。 | **入/出队/栈**: 稳定 O(1)。 |
| **空间复杂度** | 元素本身开销小，但可能预分配了未使用空间。 | 每个元素需额外空间存储指针。 |
| **内存模型** | 连续内存，缓存友好。 | 离散内存，可能导致缓存未命中。 |
| **容量** | 固定或需要昂贵的扩容操作。 | 动态调整，灵活。 |

### 实践建议
*   在 **Java** 中，当需要栈或队列结构时，**`ArrayDeque` 是首选**。它比 `Stack` 类（因继承 `Vector` 而有线程同步开销，性能较差）和 `LinkedList`（作为队列或栈使用时，底层节点对象开销较大）通常有更好的性能。
*   当数据规模不确定，且不希望有任何性能抖动（如实时系统）时，链表实现是更安全的选择。

---

## 5. 附录: 完整代码实现

### 5.1 栈实现

<details>
<summary><b>ArrayStack.java</b> (点击展开)</summary>

```java
import java.util.ArrayList;

public class ArrayStack {
    // 使用 ArrayList 实现，尾部作为栈顶
    private ArrayList<Integer> stack;

    public ArrayStack() {
        stack = new ArrayList<>();
    }

    public int size() {
        return stack.size();
    }

    public boolean isEmpty() {
        return stack.isEmpty();
    }

    public void push(int num) {
        stack.add(num);
    }

    public int pop() {
        if (isEmpty()) {
            // 在实际应用中，更推荐抛出 NoSuchElementException
            return -1;
        }
        return stack.remove(size() - 1);
    }

    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return stack.get(size() - 1);
    }

    public Object[] toArray() {
        return stack.toArray();
    }
}
```
</details>

<details>
<summary><b>LinkedListStack.java</b> (点击展开)</summary>

```java
// 辅助节点类
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

public class LinkedListStack {
    // 头节点视为栈顶
    private ListNode stackPeek;
    private int stkSize;

    public LinkedListStack() {
        stackPeek = null;
        stkSize = 0;
    }

    public int getStkSize() {
        return stkSize;
    }

    public boolean isEmpty() {
        return stkSize == 0;
    }

    public void push(int val) {
        ListNode node = new ListNode(val);
        node.next = stackPeek;
        stackPeek = node;
        stkSize++;
    }

    public int pop() {
        if (isEmpty()) {
            return -1;
        }
        int val = stackPeek.val;
        stackPeek = stackPeek.next;
        stkSize--;
        return val;
    }

    public int peek() {
        if (isEmpty()) {
            return -1;
        }
        return stackPeek.val;
    }

    public int[] toArray() {
        int[] res = new int[stkSize];
        ListNode curr = stackPeek;
        for (int i = 0; i < stkSize; i++) {
            res[i] = curr.val;
            curr = curr.next;
        }
        return res;
    }
}
```
</details>

### 5.2 队列实现

<details>
<summary><b>ArrayQueue.java</b> (点击展开)</summary>

```java
public class ArrayQueue {
    /*
    环形数组实现队列。
    front指向首元素，维护size，rear = （size + front）%nums.length
    实现capacity，size,isEmpty,push,pop,peek,toArray方法
     */
    private int[] nums;
    private int front ;
    private int queSize;
    public ArrayQueue(int capacity)
    {
        nums = new int[capacity];
        front = queSize = 0;
    }
    public int capacity()
    {
        /*
        返回整个数组长度
         */
        return nums.length;
    }
    public int size()
    {
        return queSize;
    }
    public boolean isEmpty()
    {
        return queSize == 0;
    }
    public void push(int num)
    {
        if(isEmpty())
        {
            nums[front] = num;
            queSize++;
            return;
        }
        if(capacity() == queSize)
        {
            System.out.println("wrong");
            return;
        }
        int rear = (front + queSize)%capacity();
        nums[rear] = num;
        queSize++;
        return;
    }
    public int pop()
    {
        if(isEmpty())
        {
            return -1;
        }
        int temp = nums[front];
        front = (front+1) % capacity();
        queSize--;
        return temp;
    }
    public int peek()
    {
        if(isEmpty())
        {
            return -1;
        }
        return nums[front];
    }
    public int[] toArray()
    {
        int[] res = new int[queSize];
        int curr = front;
        for (int i = 0; i < queSize; i++) {
            res[i] = nums[curr];
            curr = (curr + 1)%capacity();
        }
        return res;
    }


}
```
</details>

### 5.3双向队列实现
```java
public class ArrayDeque {
    /*
    环形数组实现
    capacity,size,isEmpty,index,pushFirst,pushLast,popFirst
    popLast,peekFirst,peekLast,toArray方法
     */
    private int[] nums;
    private int front;
    private int queSize;
    public ArrayDeque(int capacity)
    {
        this.nums = new int[capacity];
        front = 0;
        queSize = 0;
    }
    public int capacity()
    {
        return nums.length;
    }
    public boolean isEmpty()
    {
        return queSize == 0;
    }
    public int index(int i)
    {
        /*
        为什么不直接 i % capacity()？
        因为在Java中，负数取余的结果还是负数或0（例如 -1 % 10 的结果是 -1）
        这仍然是无效索引。
         */
        return (i + capacity())%capacity();
    }
    public void pushFirst(int num)
    {
        if(queSize == capacity())
        {
            return;
        }
        front = index(front-1);
        nums[front] = num;
        queSize++;
    }
    public void pushLast(int num)
    {
        if(queSize == capacity())
        {
            return;
        }
        int rear =index (front + queSize) ;
        nums[rear] = num;
        queSize++;
    }
    public int popFirst()
    {
        if(isEmpty())
        {
            return -1;
        }
        int temp = nums[front];
        front = index(front+1);
        queSize--;
        return temp;
    }
    public int popLast()
    {
        if(isEmpty())
        {
            return -1;
        }
        int temp = peekLast();
        queSize--;
        return temp;
    }
    public int peekFirst()
    {
        if(isEmpty())
        {
            return -1;
        }
        return nums[front];
    }
    public int peekLast()
    {
        if(isEmpty())
        {
            return -1;
        }
        int last = index(front + queSize -1);
        return nums[last];
    }
    public int[] toArray()
    {
        int[] res = new int[queSize];
        int curr = front;
        for (int i = 0; i < queSize; i++) {
            res[i] = nums[curr];
            curr = index(curr + 1);
        }
        return res;
    }
}

```