<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Stellogic的博客</title>
  
  
  <link href="https://stellogic.github.io/atom.xml" rel="self"/>
  
  <link href="https://stellogic.github.io/"/>
  <updated>2025-09-15T09:29:16.466Z</updated>
  <id>https://stellogic.github.io/</id>
  
  <author>
    <name>Stellogic</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈与队列</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2025-09-15T01:27:31.000Z</published>
    <updated>2025-09-15T09:29:16.466Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈、队列与双端队列核心笔记"><a href="#栈、队列与双端队列核心笔记" class="headerlink" title="栈、队列与双端队列核心笔记"></a>栈、队列与双端队列核心笔记</h1><h2 id="1-栈-Stack"><a href="#1-栈-Stack" class="headerlink" title="1. 栈 (Stack)"></a>1. 栈 (Stack)</h2><h3 id="1-1-定义与原则"><a href="#1-1-定义与原则" class="headerlink" title="1.1 定义与原则"></a>1.1 定义与原则</h3><p>栈是一种 <strong>后进先出 (Last-In, First-Out, LIFO)</strong> 的线性数据结构。所有操作均在数据结构的同一端——<strong>栈顶 (Top)</strong> 进行。</p><span id="more"></span><h3 id="1-2-核心操作"><a href="#1-2-核心操作" class="headerlink" title="1.2 核心操作"></a>1.2 核心操作</h3><table><thead><tr><th align="left">操作</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push(element)</code></td><td align="left">将元素压入栈顶</td><td align="left">O(1)</td></tr><tr><td align="left"><code>pop()</code></td><td align="left">移除并返回栈顶元素</td><td align="left">O(1)</td></tr><tr><td align="left"><code>peek()</code></td><td align="left">查看栈顶元素，不移除</td><td align="left">O(1)</td></tr><tr><td align="left"><code>isEmpty()</code></td><td align="left">检查栈是否为空</td><td align="left">O(1)</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回栈中元素数量</td><td align="left">O(1)</td></tr></tbody></table><h3 id="1-3-实现方式"><a href="#1-3-实现方式" class="headerlink" title="1.3 实现方式"></a>1.3 实现方式</h3><h4 id="1-3-1-基于数组-ArrayStack"><a href="#1-3-1-基于数组-ArrayStack" class="headerlink" title="1.3.1 基于数组 (ArrayStack)"></a>1.3.1 基于数组 (ArrayStack)</h4><ul><li><strong>机制</strong>: 使用动态数组（如 <code>ArrayList</code>）实现，将数组的<strong>尾部</strong>视为栈顶。</li><li><strong>优点</strong>:<ul><li>内存连续，CPU缓存命中率高，访问速度快。</li><li>实现简单。</li></ul></li><li><strong>缺点</strong>:<ul><li><code>push</code> 操作在数组容量不足时会触发扩容，导致该次操作的<strong>最坏时间复杂度为 O(N)<strong>。其</strong>均摊时间复杂度</strong>为 O(1)。</li></ul></li></ul><h4 id="1-3-2-基于链表-LinkedListStack"><a href="#1-3-2-基于链表-LinkedListStack" class="headerlink" title="1.3.2 基于链表 (LinkedListStack)"></a>1.3.2 基于链表 (LinkedListStack)</h4><ul><li><strong>机制</strong>: 使用单向链表实现，将链表的<strong>头节点</strong>视为栈顶。</li><li><strong>优点</strong>:<ul><li>所有操作的时间复杂度均为**稳定的 O(1)**。</li><li>空间按需分配，无容量限制。</li></ul></li><li><strong>缺点</strong>:<ul><li>每个节点需要额外空间存储指针，内存开销较大。</li><li>内存不连续，缓存性能可能较差。</li></ul></li></ul><h3 id="1-4-核心应用场景"><a href="#1-4-核心应用场景" class="headerlink" title="1.4 核心应用场景"></a>1.4 核心应用场景</h3><ul><li><strong>函数调用栈</strong>: 管理函数调用的上下文信息。</li><li><strong>表达式求值</strong>: 中缀表达式转后缀（逆波兰）表达式并计算。</li><li><strong>括号匹配</strong>: 校验字符串中的括号是否合法。</li><li><strong>深度优先搜索 (DFS)</strong>: 图与树的遍历（递归或非递归实现）。</li><li><strong>撤销&#x2F;重做功能</strong>: 编辑器中的 Undo&#x2F;Redo 操作。</li><li><strong>单调栈</strong>: 解决“下一个更大&#x2F;更小元素”等问题。</li></ul><hr><h2 id="2-队列-Queue"><a href="#2-队列-Queue" class="headerlink" title="2. 队列 (Queue)"></a>2. 队列 (Queue)</h2><h3 id="2-1-定义与原则"><a href="#2-1-定义与原则" class="headerlink" title="2.1 定义与原则"></a>2.1 定义与原则</h3><p>队列是一种 <strong>先进先出 (First-In, First-Out, FIFO)</strong> 的线性数据结构。元素从<strong>队尾 (Rear)</strong> 加入，从<strong>队首 (Front)</strong> 离开。</p><h3 id="2-2-核心操作"><a href="#2-2-核心操作" class="headerlink" title="2.2 核心操作"></a>2.2 核心操作</h3><table><thead><tr><th align="left">操作</th><th align="left">描述</th><th align="left">时间复杂度</th></tr></thead><tbody><tr><td align="left"><code>push(element)</code></td><td align="left">元素在队尾入队</td><td align="left">O(1)</td></tr><tr><td align="left"><code>pop()</code></td><td align="left">队首元素出队并返回</td><td align="left">O(1)</td></tr><tr><td align="left"><code>peek()</code></td><td align="left">查看队首元素，不移除</td><td align="left">O(1)</td></tr><tr><td align="left"><code>isEmpty()</code></td><td align="left">检查队列是否为空</td><td align="left">O(1)</td></tr><tr><td align="left"><code>size()</code></td><td align="left">返回队列中元素数量</td><td align="left">O(1)</td></tr></tbody></table><h3 id="2-3-实现方式"><a href="#2-3-实现方式" class="headerlink" title="2.3 实现方式"></a>2.3 实现方式</h3><h4 id="2-3-1-基于环形数组-ArrayQueue"><a href="#2-3-1-基于环形数组-ArrayQueue" class="headerlink" title="2.3.1 基于环形数组 (ArrayQueue)"></a>2.3.1 基于环形数组 (ArrayQueue)</h4><ul><li><strong>机制</strong>: 使用固定长度的数组，通过 <code>front</code> 指针和 <code>size</code> 计数器（或 <code>front</code> 和 <code>rear</code> 两个指针）实现。指针移动通过<strong>取模运算</strong> <code>(index + 1) % capacity</code> 实现循环，避免了数据迁移。</li><li><strong>优点</strong>:<ul><li>所有操作均为稳定的 O(1) 时间复杂度。</li><li>内存连续，缓存友好。</li></ul></li><li><strong>缺点</strong>:<ul><li>容量固定，无法动态扩展。</li></ul></li></ul><h4 id="2-3-2-基于链表-LinkedListQueue"><a href="#2-3-2-基于链表-LinkedListQueue" class="headerlink" title="2.3.2 基于链表 (LinkedListQueue)"></a>2.3.2 基于链表 (LinkedListQueue)</h4><ul><li><strong>机制</strong>: 使用单向链表，维护 <code>front</code> 和 <code>rear</code> 两个指针分别指向头节点和尾节点。</li><li><strong>优点</strong>:<ul><li>动态容量，无空间限制。</li><li>所有操作均为稳定的 O(1) 时间复杂度。</li></ul></li><li><strong>缺点</strong>:<ul><li>额外的指针内存开销。</li><li>内存不连续。</li></ul></li></ul><h3 id="2-4-核心应用场景"><a href="#2-4-核心应用场景" class="headerlink" title="2.4 核心应用场景"></a>2.4 核心应用场景</h3><ul><li><strong>广度优先搜索 (BFS)</strong>: 图与树的层序遍历。</li><li><strong>资源调度</strong>: 操作系统的任务调度、线程池的任务队列。</li><li><strong>消息队列 (MQ)</strong>: 在分布式系统中用于解耦、异步通信和流量削峰。</li><li><strong>缓存淘汰策略</strong>: 实现 FIFO 缓存。</li></ul><hr><h2 id="3-双端队列-Deque"><a href="#3-双端队列-Deque" class="headerlink" title="3. 双端队列 (Deque)"></a>3. 双端队列 (Deque)</h2><h3 id="3-1-定义与原则"><a href="#3-1-定义与原则" class="headerlink" title="3.1 定义与原则"></a>3.1 定义与原则</h3><p>双端队列 (Double-Ended Queue) 是栈和队列的泛化，允许在<strong>队首和队尾两端</strong>进行插入和删除操作。</p><h3 id="3-2-核心操作"><a href="#3-2-核心操作" class="headerlink" title="3.2 核心操作"></a>3.2 核心操作</h3><p>包含队首和队尾两套对称的操作：<code>pushFirst</code>, <code>pushLast</code>, <code>popFirst</code>, <code>popLast</code>, <code>peekFirst</code>, <code>peekLast</code>。所有核心操作的时间复杂度均为 O(1)。</p><h3 id="3-3-实现方式"><a href="#3-3-实现方式" class="headerlink" title="3.3 实现方式"></a>3.3 实现方式</h3><h4 id="3-3-1-基于环形数组-ArrayDeque"><a href="#3-3-1-基于环形数组-ArrayDeque" class="headerlink" title="3.3.1 基于环形数组 (ArrayDeque)"></a>3.3.1 基于环形数组 (ArrayDeque)</h4><ul><li><strong>机制</strong>: 与环形队列类似，但 <code>front</code> 指针可以双向移动。为防止负数索引，<code>front</code> 向前移动的逻辑为 <code>(front - 1 + capacity) % capacity</code>。</li><li><strong>优点</strong>:<ul><li>功能强大，高性能，是 Java 中实现栈和队列的<strong>首选推荐</strong>。</li></ul></li><li><strong>缺点</strong>:<ul><li>容量固定（尽管 Java 的 <code>ArrayDeque</code> 实现了自动扩容）。</li></ul></li></ul><h4 id="3-3-2-基于双向链表-LinkedListDeque"><a href="#3-3-2-基于双向链表-LinkedListDeque" class="headerlink" title="3.3.2 基于双向链表 (LinkedListDeque)"></a>3.3.2 基于双向链表 (LinkedListDeque)</h4><ul><li><strong>机制</strong>: 必须使用<strong>双向链表</strong>，每个节点包含 <code>prev</code> 和 <code>next</code> 两个指针，以支持在两端进行 O(1) 的删除操作。</li><li><strong>优点</strong>:<ul><li>动态容量，实现灵活。</li></ul></li><li><strong>缺点</strong>:<ul><li>指针的内存开销是所有实现中最大的。</li></ul></li></ul><h3 id="3-4-核心应用场景"><a href="#3-4-核心应用场景" class="headerlink" title="3.4 核心应用场景"></a>3.4 核心应用场景</h3><ul><li><strong>实现栈和队列</strong>: 可同时作为栈（使用 <code>pushFirst</code>&#x2F;<code>popFirst</code>）和队列（使用 <code>pushLast</code>&#x2F;<code>popFirst</code>）使用。</li><li><strong>滑动窗口问题</strong>: 高效求解滑动窗口中的最值问题（维护一个单调的双端队列）。</li><li><strong>历史记录管理</strong>: 如浏览器的前进&#x2F;后退功能。</li></ul><hr><h2 id="4-总结与选择"><a href="#4-总结与选择" class="headerlink" title="4. 总结与选择"></a>4. 总结与选择</h2><table><thead><tr><th align="left">特性</th><th align="left">数组实现</th><th align="left">链表实现</th></tr></thead><tbody><tr><td align="left"><strong>时间复杂度</strong></td><td align="left"><strong>入&#x2F;出队&#x2F;栈</strong>: 平均 O(1)。数组扩容时最坏为 O(N)。</td><td align="left"><strong>入&#x2F;出队&#x2F;栈</strong>: 稳定 O(1)。</td></tr><tr><td align="left"><strong>空间复杂度</strong></td><td align="left">元素本身开销小，但可能预分配了未使用空间。</td><td align="left">每个元素需额外空间存储指针。</td></tr><tr><td align="left"><strong>内存模型</strong></td><td align="left">连续内存，缓存友好。</td><td align="left">离散内存，可能导致缓存未命中。</td></tr><tr><td align="left"><strong>容量</strong></td><td align="left">固定或需要昂贵的扩容操作。</td><td align="left">动态调整，灵活。</td></tr></tbody></table><h3 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h3><ul><li>在 <strong>Java</strong> 中，当需要栈或队列结构时，**<code>ArrayDeque</code> 是首选**。它比 <code>Stack</code> 类（因继承 <code>Vector</code> 而有线程同步开销，性能较差）和 <code>LinkedList</code>（作为队列或栈使用时，底层节点对象开销较大）通常有更好的性能。</li><li>当数据规模不确定，且不希望有任何性能抖动（如实时系统）时，链表实现是更安全的选择。</li></ul><hr><h2 id="5-附录-完整代码实现"><a href="#5-附录-完整代码实现" class="headerlink" title="5. 附录: 完整代码实现"></a>5. 附录: 完整代码实现</h2><h3 id="5-1-栈实现"><a href="#5-1-栈实现" class="headerlink" title="5.1 栈实现"></a>5.1 栈实现</h3><details><summary><b>ArrayStack.java</b> (点击展开)</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 ArrayList 实现，尾部作为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        stack.add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 在实际应用中，更推荐抛出 NoSuchElementException</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.remove(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.get(size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><details><summary><b>LinkedListStack.java</b> (点击展开)</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 辅助节点类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedListStack</span> &#123;</span><br><span class="line">    <span class="comment">// 头节点视为栈顶</span></span><br><span class="line">    <span class="keyword">private</span> ListNode stackPeek;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> stkSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LinkedListStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stackPeek = <span class="literal">null</span>;</span><br><span class="line">        stkSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getStkSize</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stkSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">        node.next = stackPeek;</span><br><span class="line">        stackPeek = node;</span><br><span class="line">        stkSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> stackPeek.val;</span><br><span class="line">        stackPeek = stackPeek.next;</span><br><span class="line">        stkSize--;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackPeek.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray() &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stkSize];</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> stackPeek;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stkSize; i++) &#123;</span><br><span class="line">            res[i] = curr.val;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="5-2-队列实现"><a href="#5-2-队列实现" class="headerlink" title="5.2 队列实现"></a>5.2 队列实现</h3><details><summary><b>ArrayQueue.java</b> (点击展开)</summary><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    环形数组实现队列。</span></span><br><span class="line"><span class="comment">    front指向首元素，维护size，rear = （size + front）%nums.length</span></span><br><span class="line"><span class="comment">    实现capacity，size,isEmpty,push,pop,peek,toArray方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front ;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        front = queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        返回整个数组长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            nums[front] = num;</span><br><span class="line">            queSize++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(capacity() == queSize)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;wrong&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear</span> <span class="operator">=</span> (front + queSize)%capacity();</span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[front];</span><br><span class="line">        front = (front+<span class="number">1</span>) % capacity();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queSize];</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queSize; i++) &#123;</span><br><span class="line">            res[i] = nums[curr];</span><br><span class="line">            curr = (curr + <span class="number">1</span>)%capacity();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h3 id="5-3双向队列实现"><a href="#5-3双向队列实现" class="headerlink" title="5.3双向队列实现"></a>5.3双向队列实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayDeque</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    环形数组实现</span></span><br><span class="line"><span class="comment">    capacity,size,isEmpty,index,pushFirst,pushLast,popFirst</span></span><br><span class="line"><span class="comment">    popLast,peekFirst,peekLast,toArray方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> front;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queSize;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayDeque</span><span class="params">(<span class="type">int</span> capacity)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = <span class="keyword">new</span> <span class="title class_">int</span>[capacity];</span><br><span class="line">        front = <span class="number">0</span>;</span><br><span class="line">        queSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">capacity</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> nums.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> queSize == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">index</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        为什么不直接 i % capacity()？</span></span><br><span class="line"><span class="comment">        因为在Java中，负数取余的结果还是负数或0（例如 -1 % 10 的结果是 -1）</span></span><br><span class="line"><span class="comment">        这仍然是无效索引。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (i + capacity())%capacity();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushFirst</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(queSize == capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        front = index(front-<span class="number">1</span>);</span><br><span class="line">        nums[front] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushLast</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(queSize == capacity())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rear</span> <span class="operator">=</span>index (front + queSize) ;</span><br><span class="line">        nums[rear] = num;</span><br><span class="line">        queSize++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popFirst</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[front];</span><br><span class="line">        front = index(front+<span class="number">1</span>);</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">popLast</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> peekLast();</span><br><span class="line">        queSize--;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peekFirst</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peekLast</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> index(front + queSize -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[last];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] toArray()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[queSize];</span><br><span class="line">        <span class="type">int</span> <span class="variable">curr</span> <span class="operator">=</span> front;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queSize; i++) &#123;</span><br><span class="line">            res[i] = nums[curr];</span><br><span class="line">            curr = index(curr + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;栈、队列与双端队列核心笔记&quot;&gt;&lt;a href=&quot;#栈、队列与双端队列核心笔记&quot; class=&quot;headerlink&quot; title=&quot;栈、队列与双端队列核心笔记&quot;&gt;&lt;/a&gt;栈、队列与双端队列核心笔记&lt;/h1&gt;&lt;h2 id=&quot;1-栈-Stack&quot;&gt;&lt;a href=&quot;#1-栈-Stack&quot; class=&quot;headerlink&quot; title=&quot;1. 栈 (Stack)&quot;&gt;&lt;/a&gt;1. 栈 (Stack)&lt;/h2&gt;&lt;h3 id=&quot;1-1-定义与原则&quot;&gt;&lt;a href=&quot;#1-1-定义与原则&quot; class=&quot;headerlink&quot; title=&quot;1.1 定义与原则&quot;&gt;&lt;/a&gt;1.1 定义与原则&lt;/h3&gt;&lt;p&gt;栈是一种 &lt;strong&gt;后进先出 (Last-In, First-Out, LIFO)&lt;/strong&gt; 的线性数据结构。所有操作均在数据结构的同一端——&lt;strong&gt;栈顶 (Top)&lt;/strong&gt; 进行。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>HashMap</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="哈希表核心知识点与-Java-实现"><a href="#哈希表核心知识点与-Java-实现" class="headerlink" title="哈希表核心知识点与 Java 实现"></a>哈希表核心知识点与 Java 实现</h1><h2 id="1-定义与核心原理"><a href="#1-定义与核心原理" class="headerlink" title="1. 定义与核心原理"></a>1. 定义与核心原理</h2><p><strong>哈希表 (Hash Table)<strong>，又称散列表，是一种通过</strong>哈希函数 (Hash Function)</strong> 将键 (Key) 映射到数组索引，从而实现高效键值 (Key-Value) 存储与访问的数据结构。</p><span id="more"></span><ul><li><strong>核心目标</strong>: 实现平均时间复杂度为 <strong>O(1)</strong> 的插入、删除、查找操作。</li><li><strong>基本组件</strong>:<ol><li><strong>键值对 (Pair)</strong>: 数据存储的基本单元。</li><li><strong>桶数组 (Bucket Array)</strong>: 哈希表底层的数组，用于存放数据。</li><li><strong>哈希函数 (Hash Function)</strong>: 负责将 Key 转换为桶数组的索引。</li></ol></li></ul><h2 id="2-关键组件一：哈希函数"><a href="#2-关键组件一：哈希函数" class="headerlink" title="2. 关键组件一：哈希函数"></a>2. 关键组件一：哈希函数</h2><p>哈希函数是哈希表的基石，其质量直接影响哈希表的性能。</p><h3 id="2-1-必备特性"><a href="#2-1-必备特性" class="headerlink" title="2.1. 必备特性"></a>2.1. 必备特性</h3><ul><li><strong>确定性</strong>: 相同的 Key 输入必须产生相同的索引输出。</li><li><strong>高效性</strong>: 函数计算速度必须快。</li><li><strong>均匀性</strong>: 必须能将不同的 Key 尽可能均匀地分布到桶数组的各个位置，以最小化<strong>哈希冲突</strong>。</li></ul><h3 id="2-2-Java-中的-hashCode-与-equals"><a href="#2-2-Java-中的-hashCode-与-equals" class="headerlink" title="2.2. Java 中的 hashCode() 与 equals()"></a>2.2. Java 中的 <code>hashCode()</code> 与 <code>equals()</code></h3><p>在 Java 中，<code>HashMap</code> 等数据结构依赖对象的 <code>hashCode()</code> 方法来计算哈希值。为保证正确性，必须遵守以下契约：</p><ul><li><strong><code>equals()</code> 相等的两个对象，其 <code>hashCode()</code> 必须相等。</strong></li><li><code>hashCode()</code> 相等的两个对象，其 <code>equals()</code> 不一定相等（这正是哈希冲突）。</li><li>如果重写了 <code>equals()</code> 方法，就必须重写 <code>hashCode()</code> 方法以维护此契约。</li></ul><h2 id="3-关键组件二：哈希冲突解决方案"><a href="#3-关键组件二：哈希冲突解决方案" class="headerlink" title="3. 关键组件二：哈希冲突解决方案"></a>3. 关键组件二：哈希冲突解决方案</h2><p><strong>哈希冲突</strong>: 两个不同的 Key 经过哈希函数计算后得到了相同的数组索引。冲突是必然的，解决冲突的策略是哈希表设计的核心。</p><h3 id="3-1-方案-A-链式地址法-Separate-Chaining"><a href="#3-1-方案-A-链式地址法-Separate-Chaining" class="headerlink" title="3.1. 方案 A: 链式地址法 (Separate Chaining)"></a>3.1. 方案 A: 链式地址法 (Separate Chaining)</h3><ul><li><p><strong>机制</strong>: 桶数组的每个位置不直接存储元素，而是存储一个数据集合（如链表、动态数组）的引用。所有哈希到同一索引的键值对，都被添加到该位置的集合中。</p></li><li><p><strong>操作流程</strong>:</p><ul><li><strong>插入 (<code>put</code>)</strong>: 计算索引，定位到桶。遍历桶内集合：若 Key 已存在，则更新 Value；若不存在，则将新键值对添加到集合末尾。</li><li><strong>查找 (<code>get</code>)</strong>: 计算索引，定位到桶。遍历桶内集合，查找匹配的 Key 并返回其 Value。</li><li><strong>删除 (<code>remove</code>)</strong>: 计算索引，定位到桶。遍历桶内集合，找到并移除匹配的键值对。</li></ul></li><li><p><strong>重要优化：红黑树化 (Treeifying)</strong></p><ul><li><strong>问题</strong>: 当大量 Key 哈希到同一个桶时，链表会变得很长，查询效率从 O(1) 退化到 O(N)。</li><li><strong>解决方案</strong>: 在 Java 8 及以后的 <code>HashMap</code> 中，当一个桶内的链表长度超过阈值（默认为 8）且哈希表总容量大于 64 时，该链表会转换为一棵<strong>红黑树</strong>。</li><li><strong>效果</strong>: 将该桶的最坏查询时间复杂度从 O(N) 优化到 **O(logN)**。</li></ul></li><li><p><strong>链式地址法总结</strong>:</p><ul><li><strong>优点</strong>: 实现逻辑清晰，删除操作简单直接，负载因子理论上可以大于1。</li><li><strong>缺点</strong>: 存在额外的数据结构开销（如链表节点的指针），对 CPU 缓存不友好。</li></ul></li></ul><h3 id="3-2-方案-B-开放寻址法-Open-Addressing"><a href="#3-2-方案-B-开放寻址法-Open-Addressing" class="headerlink" title="3.2. 方案 B: 开放寻址法 (Open Addressing)"></a>3.2. 方案 B: 开放寻址法 (Open Addressing)</h3><ul><li><p><strong>机制</strong>: 所有元素都直接存储在桶数组中。当发生冲突时，通过一个<strong>探测序列</strong>在数组中寻找下一个可用的空槽位。</p></li><li><p><strong>核心：懒删除 (Lazy Deletion) 与 <code>TOMBSTONE</code></strong></p><ul><li><strong>问题</strong>: 直接删除元素（置为 <code>null</code>）会中断探测链，导致后续本应能找到的元素查找失败。</li><li><strong>解决方案</strong>: 删除时，不将槽位置为 <code>null</code>，而是放置一个特殊的**墓碑对象 (<code>TOMBSTONE</code>)**。</li><li><strong><code>TOMBSTONE</code> 的作用</strong>:<ul><li>对于<strong>查找</strong>操作：遇到墓碑，表示探测应继续进行。</li><li>对于<strong>插入</strong>操作：墓碑所在的位置被视为可用槽位，可以直接插入新元素。</li></ul></li></ul></li><li><p><strong>探测方法</strong>:</p><ol><li><strong>线性探测 (Linear Probing)</strong>: 依次探测 <code>index+1</code>, <code>index+2</code>, …。实现简单，但易产生<strong>聚集 (Clustering)</strong> 现象，即连续的槽位被占据，降低性能。</li><li><strong>二次探测 (Quadratic Probing)</strong>: 依次探测 <code>index+1²</code>, <code>index+2²</code>, …。可缓解主聚集。</li><li><strong>双重哈希 (Double Hashing)</strong>: 使用第二个哈希函数计算探测的步长。<code>index = (hash1(key) + i * hash2(key)) % capacity</code>。能有效避免各类聚集，是性能较好的探测方法。</li></ol></li><li><p><strong>开放寻址法总结</strong>:</p><ul><li><strong>优点</strong>: 无额外数据结构开销，空间利用率高，数据连续存储对 CPU 缓存友好。</li><li><strong>缺点</strong>: 实现相对复杂，删除操作需要懒删除机制，负载因子必须严格小于1，对哈希函数的均匀性要求更高。</li></ul></li></ul><h2 id="4-关键组件三：负载因子与扩容机制"><a href="#4-关键组件三：负载因子与扩容机制" class="headerlink" title="4. 关键组件三：负载因子与扩容机制"></a>4. 关键组件三：负载因子与扩容机制</h2><ul><li><p><strong>负载因子 (Load Factor)</strong>:</p><ul><li><strong>定义</strong>: <code>负载因子 = 已存元素数量 / 桶数组总容量</code>。</li><li><strong>作用</strong>: 衡量哈希表的填充程度，是决定是否需要扩容的关键指标。Java <code>HashMap</code> 默认为 <code>0.75</code>。</li></ul></li><li><p><strong>扩容 (Rehashing)</strong>:</p><ul><li><strong>触发条件</strong>: 当负载因子超过设定的阈值时。</li><li><strong>目的</strong>: 降低负载因子，减少哈希冲突，维持 O(1) 的平均性能。</li><li><strong>过程 (时间复杂度 O(N))</strong>:<ol><li>创建一个容量通常为原来2倍的新桶数组。</li><li>遍历<strong>旧桶数组</strong>中的<strong>每一个元素</strong>。</li><li><strong>重新计算</strong>每个元素在新容量下的哈希索引 (<code>key % new_capacity</code>)。</li><li>将元素放入新桶数组的对应位置。</li><li>用新桶数组替换旧桶数组。</li></ol></li><li><strong>注意</strong>: 扩容是一个高成本操作，因为它需要重新处理所有现有元素。</li></ul></li></ul><h2 id="5-两种方案对比总结"><a href="#5-两种方案对比总结" class="headerlink" title="5. 两种方案对比总结"></a>5. 两种方案对比总结</h2><table><thead><tr><th align="left">特性</th><th align="left">链式地址法 (Separate Chaining)</th><th align="left">开放寻址法 (Open Addressing)</th></tr></thead><tbody><tr><td align="left"><strong>空间使用</strong></td><td align="left">存在额外指针&#x2F;节点开销</td><td align="left">空间利用率高，无额外开销</td></tr><tr><td align="left"><strong>负载因子</strong></td><td align="left">可大于 1</td><td align="left">必须小于 1</td></tr><tr><td align="left"><strong>删除操作</strong></td><td align="left">简单，直接移除节点</td><td align="left">复杂，需要 <code>TOMBSTONE</code> 标记</td></tr><tr><td align="left"><strong>缓存效率</strong></td><td align="left">较低（内存不连续）</td><td align="left">较高（内存连续）</td></tr><tr><td align="left"><strong>主要问题</strong></td><td align="left">链表过长导致性能退化</td><td align="left">元素聚集导致性能退化</td></tr><tr><td align="left"><strong>常见场景</strong></td><td align="left">通用哈希表实现 (如 Java <code>HashMap</code>)</td><td align="left">对内存占用敏感的特定场景</td></tr></tbody></table><hr><h2 id="6-完整代码实现"><a href="#6-完整代码实现" class="headerlink" title="6. 完整代码实现"></a>6. 完整代码实现</h2><h3 id="实现-1：HashMapChaining-java-链式地址法"><a href="#实现-1：HashMapChaining-java-链式地址法" class="headerlink" title="实现 1：HashMapChaining.java (链式地址法)"></a>实现 1：HashMapChaining.java (链式地址法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助类：键值对</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">    <span class="keyword">public</span> String val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapChaining</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现哈希表，链式地址</span></span><br><span class="line"><span class="comment">    实现构造，hashFunc,loadFactor,get,put,remove,extend,print方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="type">double</span> lodaThres;</span><br><span class="line">    <span class="type">int</span> extendRatio;</span><br><span class="line">    List&lt;List&lt;Pair&gt;&gt; buckets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMapChaining</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        capacity = <span class="number">4</span>;</span><br><span class="line">        lodaThres = <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">        extendRatio = <span class="number">2</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">loadFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.get(index);</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor() &gt; lodaThres) &#123;</span><br><span class="line">            extend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.get(index);</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                pair.val = val;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Pair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(key, val);</span><br><span class="line">        bucket.add(pair);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc((key));</span><br><span class="line">        List&lt;Pair&gt; bucket = buckets.get(index);</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.key == key) &#123;</span><br><span class="line">                bucket.remove(pair);</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;List&lt;Pair&gt;&gt; bucketsTemp = buckets;</span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(capacity);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; capacity; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">// 重置size，因为put操作会重新增加它</span></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Pair&gt; bucket : bucketsTemp) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">                put(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Pair&gt; bucket : buckets) &#123;</span><br><span class="line">            List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Pair pair : bucket) &#123;</span><br><span class="line">                res.add(pair.key + <span class="string">&quot;-&gt;&quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-2：HashMapOpenAddressing-java-开放寻址法"><a href="#实现-2：HashMapOpenAddressing-java-开放寻址法" class="headerlink" title="实现 2：HashMapOpenAddressing.java (开放寻址法)"></a>实现 2：HashMapOpenAddressing.java (开放寻址法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pair 类复用上面的定义</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapOpenAddressing</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    包含懒删除的开放寻址（线性探测）的哈希表。</span></span><br><span class="line"><span class="comment">    实现构造，hashFunc ,loadFactor,findBucket,get,put,remove,extend,print</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">loadThres</span> <span class="operator">=</span> <span class="number">2.0</span> / <span class="number">3.0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">extendRatio</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> Pair[] buckets;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Pair</span> <span class="variable">TOMBSTONE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pair</span>(-<span class="number">1</span>, <span class="string">&quot;-1&quot;</span>); <span class="comment">// 墓碑标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMapOpenAddressing</span><span class="params">()</span> &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">Pair</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hashFunc</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key % capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">loadFactor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>) size / capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findBucket</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hashFunc(key);</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstTombstone</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 循环探测</span></span><br><span class="line">        <span class="keyword">while</span> (buckets[index] != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果找到匹配的key，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (buckets[index].key == key) &#123;</span><br><span class="line">                <span class="comment">// 如果之前遇到了墓碑，做交换优化，让元素更靠近初始位置</span></span><br><span class="line">                <span class="keyword">if</span> (firstTombstone != -<span class="number">1</span>) &#123;</span><br><span class="line">                    buckets[firstTombstone] = buckets[index];</span><br><span class="line">                    buckets[index] = TOMBSTONE;</span><br><span class="line">                    <span class="keyword">return</span> firstTombstone;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index; <span class="comment">// 直接返回当前位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录遇到的第一个墓碑</span></span><br><span class="line">            <span class="keyword">if</span> (firstTombstone == -<span class="number">1</span> &amp;&amp; buckets[index] == TOMBSTONE) &#123;</span><br><span class="line">                firstTombstone = index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 线性探测，移动到下一个位置</span></span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束，表示未找到key。</span></span><br><span class="line">        <span class="comment">// 如果曾遇到墓碑，返回第一个墓碑的位置（用于插入）；否则返回null的位置。</span></span><br><span class="line">        <span class="keyword">return</span> firstTombstone == -<span class="number">1</span> ? index : firstTombstone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findBucket(key);</span><br><span class="line">        <span class="comment">// 如果找到的位置不为null且不是墓碑，说明找到了</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">null</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            <span class="keyword">return</span> buckets[index].val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, String val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor() &gt; loadThres) &#123;</span><br><span class="line">            extend();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findBucket(key);</span><br><span class="line">        <span class="comment">// 如果该位置已有元素（不是null或墓碑），说明是更新操作</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">null</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index].val = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则是插入新元素</span></span><br><span class="line">        buckets[index] = <span class="keyword">new</span> <span class="title class_">Pair</span>(key, val);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> findBucket(key);</span><br><span class="line">        <span class="comment">// 确保该位置有元素再删除</span></span><br><span class="line">        <span class="keyword">if</span> (buckets[index] != <span class="literal">null</span> &amp;&amp; buckets[index] != TOMBSTONE) &#123;</span><br><span class="line">            buckets[index] = TOMBSTONE;</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">extend</span><span class="params">()</span> &#123;</span><br><span class="line">        Pair[] bucketsTemp = buckets;</span><br><span class="line">        capacity *= extendRatio;</span><br><span class="line">        buckets = <span class="keyword">new</span> <span class="title class_">Pair</span>[capacity];</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">// 重置size，因为put会重新计算</span></span><br><span class="line">        <span class="comment">// 遍历旧数组，将非null且非墓碑的元素重新插入</span></span><br><span class="line">        <span class="keyword">for</span> (Pair pair : bucketsTemp) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair != <span class="literal">null</span> &amp;&amp; pair != TOMBSTONE) &#123;</span><br><span class="line">                put(pair.key, pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Pair pair : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;null&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair == TOMBSTONE) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;TOMBSTONE&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(pair.key + <span class="string">&quot;-&gt;&quot;</span> + pair.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;哈希表核心知识点与-Java-实现&quot;&gt;&lt;a href=&quot;#哈希表核心知识点与-Java-实现&quot; class=&quot;headerlink&quot; title=&quot;哈希表核心知识点与 Java 实现&quot;&gt;&lt;/a&gt;哈希表核心知识点与 Java 实现&lt;/h1&gt;&lt;h2 id=&quot;1-定义与核心原理&quot;&gt;&lt;a href=&quot;#1-定义与核心原理&quot; class=&quot;headerlink&quot; title=&quot;1. 定义与核心原理&quot;&gt;&lt;/a&gt;1. 定义与核心原理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;哈希表 (Hash Table)&lt;strong&gt;，又称散列表，是一种通过&lt;/strong&gt;哈希函数 (Hash Function)&lt;/strong&gt; 将键 (Key) 映射到数组索引，从而实现高效键值 (Key-Value) 存储与访问的数据结构。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Heap</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Heap/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Heap/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h1><p>因为堆是完全二叉树，我们可以尝试用数组<br><br><br>下面以大顶堆为例<br><br></p><span id="more"></span><h2 id="入堆：先把元素加到堆底，之后从低至顶堆化（冒泡即可）"><a href="#入堆：先把元素加到堆底，之后从低至顶堆化（冒泡即可）" class="headerlink" title="入堆：先把元素加到堆底，之后从低至顶堆化（冒泡即可）"></a>入堆：先把元素加到堆底，之后从低至顶堆化（冒泡即可）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span></span><br><span class="line">&#123;</span><br><span class="line">    maxHeap.add(val);</span><br><span class="line">    siftUp(size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">siftUp</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent(i);</span><br><span class="line">        <span class="keyword">if</span>(p&lt;<span class="number">0</span> || maxHeap.get(i) &lt;= maxHeap.get(p))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(i,p);</span><br><span class="line">        i = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然一次入堆操作时间复杂度是O（logn),空间复杂度除了储存原本的堆外是O(1)<br><br></p><h2 id="出堆"><a href="#出堆" class="headerlink" title="出堆"></a>出堆</h2><p>一般先交换堆顶和堆底，之后删除堆底（实际上是原来的堆顶），之后从根节点开始自顶置底堆化<br><br><br>自顶至底堆化：根节点和两个子节点比较，把最大的子节点和根节点交换，迭代至叶节点或者某个无需交换的节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    swap(<span class="number">0</span>,size() - <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> maxHeap.remove(size() - <span class="number">1</span>);</span><br><span class="line">    siftDown(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> left(i),r = right(i),maxNode = i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(maxNode))</span><br><span class="line">        &#123;</span><br><span class="line">            maxNode = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(maxNode))</span><br><span class="line">        &#123;</span><br><span class="line">            maxNode = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxNode == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(i,maxNode);</span><br><span class="line">        i = maxNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意很多语言优先队列就是堆</strong></p><h2 id="建堆操作"><a href="#建堆操作" class="headerlink" title="建堆操作"></a>建堆操作</h2><ol><li>依次入堆法，时间复杂度O(nlogn)<br></li><li>遍历堆化：先把列表元素直接加入堆，再倒叙遍历堆对每个非叶子点进行 从顶至底堆化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">MaxHeap(List&lt;Integer&gt; nums) &#123;</span><br><span class="line">    maxHeap = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> parent(size() -<span class="number">1</span>);i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        siftDown(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度是个差比数列求和：<br><img src="/img.png" alt="/img/算法笔记/数据结构//img/算法笔记/数据结构/Heap/img.png"><br>以完美二叉树为例：每层高度记为h，h-1 … 0，单层节点数量则是2^0,2^1 ……2^h;<br><br>求和得最终是O(2^h),即为O(n).</p><h2 id="Top-k-问题"><a href="#Top-k-问题" class="headerlink" title="Top-k 问题"></a>Top-k 问题</h2><p>给定一个长度为n 的无序数组 nums ，请返回数组中最大的k 个元素。</p><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>k遍历，每轮找到一个当前最大，时间复杂度O(nk)</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>先排序再取前k个，O(nlogn)</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>先初始化一个小顶对；前k个元素入堆；k+1个开始，如果当前元素大于堆顶则堆顶出堆当前元素入堆；遍历完后堆中的就是k个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">Queue&lt;Integer&gt; <span class="title function_">topKHeap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        heap.offer(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k;i&lt;nums.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; heap.peek())</span><br><span class="line">        &#123;</span><br><span class="line">            heap.poll();</span><br><span class="line">            heap.offer(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度O（nlogk）。<br><br>时间复杂度：<br><br>初始堆构建：我们遵循每次循环最悲观的操作作为单次操作量，就是log(k),因此第一部分就是O（klogk)<br><br><br>同时大概想一下，再k&#x2F;2前后开始的复杂度就是log(k)，有超过一半的操作数是这个，因此我们找的上届是合理的<br><br><br>后续： O((n-k)log(k))<br><br><br>因此最终求和后就是O(nlog(k))</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Heap&quot;&gt;&lt;a href=&quot;#Heap&quot; class=&quot;headerlink&quot; title=&quot;Heap&quot;&gt;&lt;/a&gt;Heap&lt;/h1&gt;&lt;p&gt;因为堆是完全二叉树，我们可以尝试用数组&lt;br&gt;&lt;br&gt;&lt;br&gt;下面以大顶堆为例&lt;br&gt;&lt;br&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Tree</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.464Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="层序遍历（广度优先，bfs）"><a href="#层序遍历（广度优先，bfs）" class="headerlink" title="层序遍历（广度优先，bfs）"></a>层序遍历（广度优先，bfs）</h3><p>广度优先，和队列的“先进先出”类似。因此考虑使用队列</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化一个队列,作为遍历过程中的临时储存。</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="comment">//初始化一个列表储存结果</span></span><br><span class="line">    List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();<span class="comment">//出队</span></span><br><span class="line">        result.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(N).要访问所有节点<br><br>空间复杂度：O(N).队列和result占用空间</p><h3 id="深度优先（前序，中序，后序）"><a href="#深度优先（前序，中序，后序）" class="headerlink" title="深度优先（前序，中序，后序）"></a>深度优先（前序，中序，后序）</h3><p>前序：当前节点-&gt;左子树-&gt;右子树<br><br>中序：左子树-&gt;当前节点-&gt;右子树<br><br>后序：左子树-&gt;右子树-&gt;当前节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    list.add(cur.val);</span><br><span class="line">    preOrder(cur.left);</span><br><span class="line">    preOrder(cur.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(cur.left);</span><br><span class="line">    list.add(cur.val);</span><br><span class="line">    inOrder(cur.right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(cur.left);</span><br><span class="line">    postOrder(cur.right);</span><br><span class="line">    list.add(cur.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：都是O(N)，因为要遍历所有节点<br><br>空间复杂度: O(N)。list储存结果是O（N）；栈帧应该是O(logN),因为每次要按深度递到叶节点后再归，理想状态平衡的话应当是O（logN），如果退化成链表就是O(N)</p><h2 id="数组表示"><a href="#数组表示" class="headerlink" title="数组表示"></a>数组表示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArrayBinaryTree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ArrayBinaryTree</span><span class="params">(List&lt;Integer&gt; arr)</span> &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(arr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">val</span><span class="params">(<span class="type">int</span> i )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;= size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">left</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">right</span><span class="params">(<span class="type">int</span> i)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">parent</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">levelOrder</span><span class="params">()</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt; size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(val(i) != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res.add(val(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Integer i, String order, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size() || val(i) == <span class="literal">null</span>) &#123; <span class="comment">// 索引越界或节点为空</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;pre&quot;</span>.equals(order)) &#123;</span><br><span class="line">            res.add(val(i));</span><br><span class="line">            dfs(left(i), order, res);</span><br><span class="line">            dfs(right(i), order, res);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;in&quot;</span>.equals(order)) &#123;</span><br><span class="line">            dfs(left(i), order, res);</span><br><span class="line">            res.add(val(i));</span><br><span class="line">            dfs(right(i), order, res);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;post&quot;</span>.equals(order)) &#123;</span><br><span class="line">            dfs(left(i), order, res);</span><br><span class="line">            dfs(right(i), order, res);</span><br><span class="line">            res.add(val(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>左子树&lt;根节点&lt;右子树，任意子树也满足</p><h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">search</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &gt; num) &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类似二分查找，时间复杂度是O(logN)(在二叉树平衡时）, 空间复杂度O(1)</p><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p>一般直接插在合适的末端，作为新的叶节点，这样更方便<br>先查找再插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root,pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == num )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(num);</span><br><span class="line">    <span class="keyword">if</span>(pre.val &lt; num)</span><br><span class="line">    &#123;</span><br><span class="line">        pre.right = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pre.left = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度平衡时也是O（logN).</p><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>需分情况，要删的节点的度是0，1，2<br>其中度为二时为了保证满足二叉搜索树。需要用一个节点替换被删除的节点，可以是右子树最小节点或者左子树最大节点。这里我们使用右子树最小节点（也就是中序遍历的下一个节点，左子树-&gt;当前节点-&gt;右子树）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line">TreeNode root;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root,pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//查找</span></span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.val == num)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = cur;</span><br><span class="line">        <span class="keyword">if</span>(cur.val &lt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur.left == <span class="literal">null</span> || cur.right ==<span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">child</span> <span class="operator">=</span> (cur.left != <span class="literal">null</span> ? cur.left : cur.right);</span><br><span class="line">        <span class="keyword">if</span>(cur != root)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.left == cur)</span><br><span class="line">            &#123;</span><br><span class="line">                pre.left =child;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                pre.right = child;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            root = child;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//度为二</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.right;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tempParent</span> <span class="operator">=</span> cur;</span><br><span class="line">        <span class="comment">//查找右子树的最小节点</span></span><br><span class="line">        <span class="keyword">while</span> (temp.left != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            tempParent = temp;</span><br><span class="line">            temp = temp.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.val = temp.val;</span><br><span class="line">        <span class="comment">//删除后继节点</span></span><br><span class="line">        <span class="keyword">if</span>(tempParent.left == temp)</span><br><span class="line">        &#123;</span><br><span class="line">            tempParent.left = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tempParent.right = temp.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度: 查找O(logn),获取中序遍历后继节点O(logn)，最终是O（logn)<br><br>空间复杂度：O（1）<br><br><br><strong>因此平衡的二叉搜索树的增删查都是O(logN)</strong></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;二叉树&quot;&gt;&lt;a href=&quot;#二叉树&quot; class=&quot;headerlink&quot; title=&quot;二叉树&quot;&gt;&lt;/a&gt;二叉树&lt;/h1&gt;&lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;h3 id=&quot;层序遍历（广度优先，bfs）&quot;&gt;&lt;a href=&quot;#层序遍历（广度优先，bfs）&quot; class=&quot;headerlink&quot; title=&quot;层序遍历（广度优先，bfs）&quot;&gt;&lt;/a&gt;层序遍历（广度优先，bfs）&lt;/h3&gt;&lt;p&gt;广度优先，和队列的“先进先出”类似。因此考虑使用队列&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/graph/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/graph/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h1><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjMat</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; vertices;<span class="comment">//顶点列表，元素代表顶点值，索引是顶点索引</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjMat; <span class="comment">//邻接矩阵，行列索引对应顶点索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjMat</span><span class="params">(<span class="type">int</span>[] vertices, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vertices = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.adjMat = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加顶点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> val : vertices)</span><br><span class="line">        &#123;</span><br><span class="line">            addVertex(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                添加边</span></span><br><span class="line"><span class="comment">                注意</span></span><br><span class="line"><span class="comment">                edges这个二维数组里面表示的是索引对应的顶点直接有边</span></span><br><span class="line"><span class="comment">                如int[][] edges = &#123;&#123;0, 1&#125;, &#123;0, 2&#125;, &#123;1, 3&#125;&#125;;</span></span><br><span class="line"><span class="comment">                第一个元素&#123;0,1&#125;表示索引0，1对应的顶点之间有边</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] e : edges)</span><br><span class="line">        &#123;</span><br><span class="line">            addEdge(e[<span class="number">0</span>],e[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertices.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(<span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size();</span><br><span class="line">        vertices.add(val);</span><br><span class="line">        List&lt;Integer&gt; newRow = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n ;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            newRow.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.add(newRow);</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; row : adjMat)&#123;</span><br><span class="line">            row.add(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        vertices.remove((index));</span><br><span class="line">        adjMat.remove(index);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat)</span><br><span class="line">        &#123;</span><br><span class="line">            row.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> j)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || j&lt; <span class="number">0</span> || i&gt;= size() || j&gt;= size() || i==j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.get(i).set(j,<span class="number">1</span>);</span><br><span class="line">        adjMat.get(j).set(i,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(<span class="type">int</span> i ,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span>||j&lt;<span class="number">0</span>||i&gt;=size()||j&gt;=size())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjMat.get(i).set(j,<span class="number">0</span>);</span><br><span class="line">        adjMat.get(j).set(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;顶点列表 = &quot;</span>);</span><br><span class="line">        System.out.println(vertices);</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵 = &quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; row : adjMat) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> val : row) &#123;</span><br><span class="line">                System.out.print(val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><p>实际上我们使用Vertex类表示顶点，这样删除时只需要删除一个不需要删除其他（借助哈希表）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line"></span><br><span class="line">    Vertex(<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须重写 equals 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span> || getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vertex</span> <span class="operator">=</span> (Vertex) obj;</span><br><span class="line">        <span class="keyword">return</span> val == vertex.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须重写 hashCode 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.hashCode(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们想用Vertex作为key，哈希表必须知道怎么去实现哈希算法从而快速找到把这个key放在哪里，也需要知道怎么去比较两个key是否相等。<br><br><br><strong>因此务必重写hashCode(哈希算法)和equals方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphAdjList</span> &#123;</span><br><span class="line">    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GraphAdjList</span><span class="params">(Vertex[][] edges)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.adjList = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Vertex[] edge : edges) &#123;</span><br><span class="line">            addVertex(edge[<span class="number">0</span>]);</span><br><span class="line">            addVertex(edge[<span class="number">1</span>]);</span><br><span class="line">            addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> adjList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(Vertex vet1, Vertex vet2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet1) || !adjList.containsKey(vet2)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.get(vet1).add(vet2);</span><br><span class="line">        adjList.get(vet2).add(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeEdge</span><span class="params">(Vertex vet1, Vertex vet2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.get(vet1).remove(vet2);</span><br><span class="line">        adjList.get(vet2).remove(vet1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addVertex</span><span class="params">(Vertex vet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (adjList.containsKey(vet)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.put(vet, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeVertex</span><span class="params">(Vertex vet)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!adjList.containsKey(vet)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        adjList.remove(vet);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Vertex&gt; list : adjList.values()) &#123;</span><br><span class="line">            list.remove((vet));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接表 = &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Vertex,List&lt;Vertex&gt;&gt; pair : adjList.entrySet())</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Vertex vertex : pair.getValue())</span><br><span class="line">            &#123;</span><br><span class="line">                temp.add(vertex.val);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(pair.getKey().val + <span class="string">&quot;: &quot;</span> + temp + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left"></th><th align="center">邻接矩阵</th><th align="center">邻接表（链表）</th><th align="center">邻接表（哈希表）</th></tr></thead><tbody><tr><td align="left"><strong>判断是否邻接</strong></td><td align="center">O(1)</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="left"><strong>添加边</strong></td><td align="center">O(1)</td><td align="center">O(1)</td><td align="center">O(1)</td></tr><tr><td align="left"><strong>删除边</strong></td><td align="center">O(1)</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="left"><strong>添加顶点</strong></td><td align="center">O(n)</td><td align="center">O(1)</td><td align="center">O(1)</td></tr><tr><td align="left"><strong>删除顶点</strong></td><td align="center">O(n*n)</td><td align="center">O(n+m)</td><td align="center">O(n+m)</td></tr><tr><td align="left"><strong>内存空间</strong></td><td align="center">O(n*n)</td><td align="center">O(n+m)</td><td align="center">O(n+m)</td></tr></tbody></table><p>请注意，邻接表（链表）对应本文实现，而邻接表（哈希表）专指将所有链表替换为哈希表后的实现。</p><h1 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h1><h2 id="广度遍历（BFS）"><a href="#广度遍历（BFS）" class="headerlink" title="广度遍历（BFS）"></a>广度遍历（BFS）</h2><p>使用队列<br><br><br>遍历起始顶点加入队列，每次迭代弹出队首病记录访问，之后把顶点所有的邻接节点加入队尾</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphBFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    visited.add(startVet);</span><br><span class="line">    Queue&lt;Vertex&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(startVet);</span><br><span class="line">    <span class="keyword">while</span> (!que.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">Vertex</span> <span class="variable">vet</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        res.add(vet);</span><br><span class="line">        <span class="comment">//相当于遍历边</span></span><br><span class="line">        <span class="keyword">for</span>(Vertex adjVet : graph.adjList.get(vet))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited.contains(adjVet))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            que.offer(adjVet);</span><br><span class="line">            visited.add(adjVet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(V+E)<br><br><br>空间复杂度：OO（V）</p><h2 id="深度优先（DFS）"><a href="#深度优先（DFS）" class="headerlink" title="深度优先（DFS）"></a>深度优先（DFS）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (visited.contains(vet)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    res.add(vet);</span><br><span class="line">    visited.add(vet);</span><br><span class="line">    <span class="comment">//依然是，访问邻接节点相当于再访问边。</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Vertex&gt; <span class="title function_">graphDFS</span><span class="params">(GraphAdjList graph, Vertex startVet)</span> &#123;</span><br><span class="line">    List&lt;Vertex&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Set&lt;Vertex&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    dfs(graph,visited,res,startVet);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以优化成调用前检查</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet)</span> &#123;</span><br><span class="line">    res.add(vet);     <span class="comment">// 记录访问顶点</span></span><br><span class="line">    visited.add(vet); <span class="comment">// 标记该顶点已被访问</span></span><br><span class="line">    <span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">    <span class="keyword">for</span> (Vertex adjVet : graph.adjList.get(vet)) &#123;</span><br><span class="line">        <span class="comment">//基本情况隐藏在这里，如果所有邻接节点都被访问，就会返回</span></span><br><span class="line">        <span class="keyword">if</span> (visited.contains(adjVet))</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 跳过已被访问的顶点</span></span><br><span class="line">        <span class="comment">// 递归访问邻接顶点</span></span><br><span class="line">        dfs(graph, visited, res, adjVet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显式写出基本情况时，如果某个邻接节点被访问过，依然会递归调用一次dfs，性能会略微低点。<br><br><br>时间复杂度：O(V+E)，所有顶点都会被访问一次，用O（V）时间，所有边被访问两次，O（E）<br>空间复杂度：res，visited都是O（V），递归深度最多也是O（V），总体就是O（V）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图的实现&quot;&gt;&lt;a href=&quot;#图的实现&quot; class=&quot;headerlink&quot; title=&quot;图的实现&quot;&gt;&lt;/a&gt;图的实现&lt;/h1&gt;&lt;h2 id=&quot;邻接矩阵&quot;&gt;&lt;a href=&quot;#邻接矩阵&quot; class=&quot;headerlink&quot; title=&quot;邻接矩阵&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>全排列问题复杂度分析</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于全排列问题的复杂度分析"><a href="#关于全排列问题的复杂度分析" class="headerlink" title="关于全排列问题的复杂度分析"></a>关于全排列问题的复杂度分析</h1><h3 id="关键代码回顾"><a href="#关键代码回顾" class="headerlink" title="关键代码回顾"></a>关键代码回顾</h3><p>为了方便对照，我们再看一下核心的剪枝逻辑：</p><span id="more"></span><ol><li><code>!selected[i]</code>: 确保同一个<strong>位置</strong>的元素不会被重复使用（这是所有排列问题共有的）。</li><li><code>!duplicated.contains(choice)</code>: <strong>剪枝核心</strong>。确保在当前递归层级，对于<strong>数值相同</strong>的元素，只选择第一个未经访问的进行递归。</li></ol><hr><h3 id="nums-1-1-2-的递归树"><a href="#nums-1-1-2-的递归树" class="headerlink" title="nums = [1, 1, 2] 的递归树"></a><code>nums = [1, 1, 2]</code> 的递归树</h3><p>下面是 <code>backtrack</code> 函数为 <code>[1, 1, 2]</code> 生成全排列的递归树。树的每一层代表排列中的一个位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                                      backtrack(state=[], choices=[1,1,2]，selected=[F,F,F])</span><br><span class="line">                                                    |</span><br><span class="line">                                                    | for i = 0..2</span><br><span class="line">                        +---------------------------+---------------------------+</span><br><span class="line">                        | i=0, choice=1             | i=1, choice=1             | i=2, choice=2</span><br><span class="line">                        | duplicated.add(1)         | duplicated.contains(1)?   | duplicated.add(2)</span><br><span class="line">                        |                           | --&gt; YES. PRUNED! (剪枝!)  |</span><br><span class="line">                        |                           | (在这一层，1已经用过了)     |</span><br><span class="line">                        V                           X                           V</span><br><span class="line">       backtrack(state=[1], choices=[1,1,2], selected=[T,F,F])      backtrack(state=[2], choices=[1,1,2], selected=[F,F,T])</span><br><span class="line">                        |                                                           |</span><br><span class="line">                        | for i = 0..2                                              | for i = 0..2</span><br><span class="line">    +-------------------+-------------------+                         +-------------+-------------+</span><br><span class="line">    | i=0, selected[0]? | i=1, choice=1     | i=2, choice=2           | i=0, choice=1 | i=1, choice=1 | i=2, selected[2]?</span><br><span class="line">    | --&gt; YES. Skip.    | duplicated.add(1) | duplicated.add(2)       | dup.add(1)    | dup.contains(1)?| --&gt; YES. Skip.</span><br><span class="line">    |                   |                   |                         |             | --&gt; YES. PRUNED!|</span><br><span class="line">    V                   V                   V                         V             X             V</span><br><span class="line">backtrack(state=[1,1],...)| backtrack(state=[1,2],...)|           backtrack(state=[2,1],...)</span><br><span class="line">    selected=[T,T,F]    |     selected=[T,F,T]    |               selected=[T,F,T]</span><br><span class="line">                        |                         |                               |</span><br><span class="line">                        | for i = 0..2            | for i = 0..2                  | for i = 0..2</span><br><span class="line">    +-------------------+     +-------------------+               +-------------------+</span><br><span class="line">    | i=0, selected? YES|     | i=0, selected? YES|               | i=0, selected? YES|</span><br><span class="line">    | i=1, selected? YES|     | i=1, choice=1     |               | i=1, choice=1     |</span><br><span class="line">    | i=2, choice=2     |     | i=2, selected? YES|               | i=2, selected? YES|</span><br><span class="line">    | state.size()==3   |     | state.size()==3   |               | state.size()==3   |</span><br><span class="line">    V                   V     V                   V               V                   V</span><br><span class="line">  res.add([1,1,2])    (backtrack) res.add([1,2,1]) (backtrack)   res.add([2,1,1])    (backtrack) </span><br></pre></td></tr></table></figure><p><strong>树的解读：</strong></p><ol><li><p><strong>根节点 (第0层):</strong> <code>state</code> 为空。</p><ul><li><code>for</code> 循环开始，<code>i=0</code>，选择 <code>nums[0]</code> (值为1)。进入下一层递归。</li><li><code>i=1</code>，选择 <code>nums[1]</code> (值也为1)。但此时 <code>duplicated</code> 集合中已经包含了1，所以这个分支被<strong>剪掉</strong>了！这是避免重复排列的关键。</li><li><code>i=2</code>，选择 <code>nums[2]</code> (值为2)。进入下一层递归。</li></ul></li><li><p><strong>第1层:</strong></p><ul><li><strong>左侧分支 (state&#x3D;):</strong><ul><li><code>for</code> 循环遍历 <code>[1,1,2]</code>。<code>nums[0]</code> 已被选择 (<code>selected[0]</code>为true)，跳过。</li><li><code>i=1</code>，选择 <code>nums[1]</code> (值为1)。进入下一层。</li><li><code>i=2</code>，选择 <code>nums[2]</code> (值为2)。进入下一层。</li></ul></li><li><strong>右侧分支 (state&#x3D;):</strong><ul><li><code>for</code> 循环遍历 <code>[1,1,2]</code>。</li><li><code>i=0</code>，选择 <code>nums[0]</code> (值为1)。进入下一层。</li><li><code>i=1</code>，选择 <code>nums[1]</code> (值也为1)。但本层的 <code>duplicated</code> 集合已经有1了，<strong>剪枝</strong>！</li><li><code>i=2</code> 已被选择，跳过。</li></ul></li></ul></li><li><p><strong>叶子节点 (第3层):</strong></p><ul><li>当 <code>state</code> 的长度达到3时，就找到了一个完整的排列。</li><li>例如，从左侧分支一路下来，得到 <code>[1, 1, 2]</code>。这个排列被复制并添加到最终结果 <code>res</code> 中。</li><li>然后函数返回（回溯），尝试其他可能性。</li></ul></li></ol><hr><h3 id="从递归树分析复杂度"><a href="#从递归树分析复杂度" class="headerlink" title="从递归树分析复杂度"></a>从递归树分析复杂度</h3><h4 id="1-时间复杂度-O-n-×-n"><a href="#1-时间复杂度-O-n-×-n" class="headerlink" title="1. 时间复杂度: O(n × n!)"></a>1. 时间复杂度: O(n × n!)</h4><ul><li><p><strong>树的节点总数 (决定了 <code>backtrack</code> 函数被调用的次数):</strong></p><ul><li>如果没有重复元素（例如 <code>[1, 2, 3]</code>），第0层有 <code>n</code> 个选择，第1层有 <code>n-1</code> 个选择，…，最后一层有1个选择。</li><li>整棵树的节点总数大约是 <code>n + n(n-1) + ... + n! ≈ O(n!)</code>。</li><li>虽然我们的剪枝策略砍掉了很多分支，但在进行复杂度分析时，我们通常考虑最坏情况，即所有元素都不同。因此，递归调用的总次数（即树的节点总数）是 O(n!) 级别的。</li></ul></li><li><p><strong>每个节点内部的操作耗时:</strong></p><ul><li>在树的<strong>非叶子节点</strong>，主要操作是 <code>for</code> 循环，它会执行 <code>n</code> 次。循环内部的操作（如 <code>contains</code>, <code>add</code>）是 O(1) 的。所以每个非叶子节点的时间开销是 O(n)。</li><li>在树的<strong>叶子节点</strong>，当 <code>state.size() == choices.length</code> 时，会执行 <code>res.add(new ArrayList&lt;Integer&gt;(state))</code>。这个操作需要创建一个新列表并把 <code>state</code> 中的 <code>n</code> 个元素复制过去，时间开销是 **O(n)**。</li></ul></li><li><p><strong>综合计算:</strong></p><ul><li>算法的总时间主要由两部分构成：构建树的开销和在叶子节点复制结果的开销。</li><li>叶子节点的数量就是最终不重复排列的数量，这个数量级是 O(n!)。</li><li>仅仅是把所有叶子节点的结果复制到 <code>res</code> 列表中的总时间就是：**(叶子节点数量) × (每次复制的时间) ≈ O(n!) × O(n) &#x3D; O(n × n!)**。</li><li>这个开销是算法时间复杂度的主要部分，因此总时间复杂度为 **O(n × n!)**。</li></ul></li></ul><h4 id="2-空间复杂度-O-n-2"><a href="#2-空间复杂度-O-n-2" class="headerlink" title="2. 空间复杂度: O($n^2$)"></a>2. 空间复杂度: O($n^2$)</h4><p>空间复杂度我们看的是算法在任意时刻需要占用的最大辅助空间。</p><ul><li><p><strong>递归调用栈的深度:</strong></p><ul><li>从树的结构可以清晰地看到，从根节点到最深的叶子节点，路径的长度是 <code>n</code>。这意味着 <code>backtrack</code> 函数最多会嵌套调用 <code>n</code> 次。</li><li>因此，递归调用栈所占用的空间是 **O(n)**。</li></ul></li><li><p><strong>辅助数据结构:</strong></p><ul><li><code>state</code> 列表：在递归过程中，它存储了当前的路径，其最大长度为 <code>n</code>。占用 O(n) 空间。</li><li><code>selected</code> 数组：长度始终为 <code>n</code>。占用 O(n) 空间。</li><li><code>duplicated</code> 集合：这个集合是在<strong>每个</strong>函数调用栈帧内创建的局部变量。因此，到最深时是1+2+3+……+n,是O(n^2)</li></ul></li><li><p><strong>综合计算:</strong></p><ul><li>因此，总的辅助空间复杂度是 O(n) + O(n) + O(n^2) &#x3D; **O(n^2)**。</li><li>（注意：这不包括存储最终结果的 <code>res</code> 列表。如果算上它，空间复杂度将是 O(n × n!)）。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于全排列问题的复杂度分析&quot;&gt;&lt;a href=&quot;#关于全排列问题的复杂度分析&quot; class=&quot;headerlink&quot; title=&quot;关于全排列问题的复杂度分析&quot;&gt;&lt;/a&gt;关于全排列问题的复杂度分析&lt;/h1&gt;&lt;h3 id=&quot;关键代码回顾&quot;&gt;&lt;a href=&quot;#关键代码回顾&quot; class=&quot;headerlink&quot; title=&quot;关键代码回顾&quot;&gt;&lt;/a&gt;关键代码回顾&lt;/h3&gt;&lt;p&gt;为了方便对照，我们再看一下核心的剪枝逻辑：&lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="定义和概念"><a href="#定义和概念" class="headerlink" title="定义和概念"></a>定义和概念</h2><p>将问题分解为一系列更小的子问题，并且通过储存子问题的解来避免重复计算，从而提高时间效率  </p><span id="more"></span><p>与回溯、分治的区别：  </p><ul><li>分治递归的把原问题划分成多个<strong>独立</strong>的子问题直到最小问题，之后回溯中合并子问题的解得到原问题解</li><li>动态规划也递归分解，但是动态规划的子问题是相互依赖的，会出现重叠子问题</li><li>回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>最优子结构<br>原问题的最优解是从子问题的最优解构建得来的</li><li>无后效性<br>给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关<br>就是说只依赖前序状态当前的已有的信息，但和前序状态时如何实现的无关</li></ol><h2 id="问题判断"><a href="#问题判断" class="headerlink" title="问题判断"></a>问题判断</h2><p><strong>总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常适合用动态规划求解。</strong><br>但实际上，很难直接判断，因此</p><ol><li>先观察问题是否适合使用回溯（穷举）解决（通常满足决策树模型，其中每一个节点代表一个决策，每一条路径代表一个决策序列。）</li><li>之后看加分项和减分项  <ul><li>加分项：  <ul><li>问题包含最大（小）或最多（少）等最优化描述。</li><li>问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。</li></ul></li><li>减分项：<ul><li>问题的目标是找出所有可能的解决方案，而不是找出最优解。</li><li>问题描述中有明显的排列组合的特征，需要返回具体的多个方案。</li></ul></li></ul></li></ol><h2 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h2><ol><li>描述决策</li><li>定义状态</li><li>建立dp表</li><li>推导状态转移方程</li><li>确定边界条件</li></ol><p>状态：状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。  </p><p>dp表： 每个状态都对应一个子问题，我们会定义一个 dp表来存储所有子问题的解，状态的每个独立变量都是 dp表的一个维度。</p><p>边界条件：边界条件在动态规划中用于初始化dp表，在搜索中用于剪枝。  </p><p>状态转移方程： 递推公式  </p><p>初始状态：（如1阶2阶）最小子问题的状态</p><p>状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li>不考虑时间的前提下，所有动态规划问题都可以用回溯（暴力搜索）进行求解，但递归树中存在大量的重叠子问题，效率极低。通过引入记忆化列表，可以存储所有计算过的子问题的解，从而保证重叠子问题只被计算一次。</li><li>由于当前状态仅依赖某些局部状态，因此我们可以消除dp表的一个维度，从而降低空间复杂度。</li></ol><h2 id="引入爬楼梯例题"><a href="#引入爬楼梯例题" class="headerlink" title="引入爬楼梯例题"></a>引入爬楼梯例题</h2><p>给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶，请问有多少种方案可以爬到楼顶？</p><ol><li><p>回溯穷举暴力：每轮除法上1阶或2阶，到达楼顶就方案数量加一，越过楼梯顶就剪枝</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; choices, <span class="type">int</span> state, <span class="type">int</span> n, List&lt;Integer&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 当爬到第 n 阶时，方案数量加 1</span></span><br><span class="line">    <span class="keyword">if</span> (state == n)</span><br><span class="line">        res.set(<span class="number">0</span>, res.get(<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Integer choice : choices) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：不允许越过第 n 阶</span></span><br><span class="line">        <span class="keyword">if</span> (state + choice &gt; n)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新状态</span></span><br><span class="line">        backtrack(choices, state + choice, n, res);</span><br><span class="line">        <span class="comment">// 回退</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：回溯 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsBacktrack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; choices = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 可选择向上爬 1 阶或 2 阶</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 从第 0 阶开始爬</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    res.add(<span class="number">0</span>); <span class="comment">// 使用 res[0] 记录方案数量</span></span><br><span class="line">    backtrack(choices, state, n, res);</span><br><span class="line">    <span class="keyword">return</span> res.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>暴力搜索  </p><p> 得到一个结论dp[i] &#x3D; dp[i-1] + dp[i-2]<br> 可以直接递归，和回溯都一样属于深度优先搜索  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>) + dfs(i - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDFS</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/img_17.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_17.png"><br> 如图，递归树深度为n,时间复杂度为O(2^n)  </p><p> 主要原因是有很多子问题重叠了，被重复计算了。  </p></li><li><p>记忆化搜索<br>我们期望所有重叠子问题只计算一次<br>声明一个mem来记录每个子问题的解，搜索时重复子问题剪枝直接返回</p><ol><li>当首次计算dp[i]时，我们将其记录至 mem[i] ，以便之后使用。</li><li>再次计算dp[i] 时，直接从mem[i]获取结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] mem)</span> &#123;</span><br><span class="line">    <span class="comment">// 已知 dp[1] 和 dp[2] ，返回之</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span> || i == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    <span class="comment">// 若存在记录 dp[i] ，则直接返回之</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i] != -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> mem[i];</span><br><span class="line">    <span class="comment">// dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, mem) + dfs(i - <span class="number">2</span>, mem);</span><br><span class="line">    <span class="comment">// 记录 dp[i]</span></span><br><span class="line">    mem[i] = count;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 爬楼梯：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDFSMem</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录</span></span><br><span class="line">    <span class="type">int</span>[] mem = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(mem, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dfs(n, mem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p> <img src="/img_18.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_18.png"><br>所有重叠子问题都只需计算一次，时间复杂度优化至 O(n)</p></li><li><p>动态规划<br> 记忆化搜索是从顶至底的方法<br> 动态规划是从低至顶：从最小子问题的解开始，迭代构建更大子问题的解，直到得到原问题  </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDP</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 显然dp[i]只和dp[i-1]和dp[i-2]有关，因此不必使用dp储存所有子问题的解，利用两个变量滚动即可</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">climbingStairsDPComp</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = a + b;</span><br><span class="line">        a = temp;</span><br><span class="line">        <span class="comment">//每轮结束时，b就是第dp[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 空间复杂度降到O(1).<br> <strong>动态规划当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为<code>“滚动变量”</code>或<code>“滚动数组”</code>。</strong></p></li></ol><h2 id="更改爬楼梯问题说明最优子结构"><a href="#更改爬楼梯问题说明最优子结构" class="headerlink" title="更改爬楼梯问题说明最优子结构"></a>更改爬楼梯问题说明最优子结构</h2><p>给定一个楼梯，你每步可以上 1阶或者 2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 cost，其中 cost[i]表示在第 i个台阶需要付出的代价， cost[0]为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？</p><p>显然$dp[i] &#x3D; min(dp[i-1],dp[i-2]) + cost[i]$  </p><p>也就是原问题的最优解是从子问题的最优解构建得来的。  </p><p>实际上原来的爬楼梯问题如果换成问”最大方案数量”的等价问法，也相当于一种最优子结构  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 爬楼梯最小代价：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minCostClimbingStairsDP</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    <span class="comment">// 初始化 dp 表，用于存储子问题的解</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始状态：预设最小子问题的解</span></span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 状态转移：从较小子问题逐步求解较大子问题</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个dp[i]只由dp[i-1]和dp[i-2]决定，因此也可以两个变量滚动空间优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minCostClimbingStairsDPComp</span><span class="params">(<span class="type">int</span>[] cost)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>|| n==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> cost[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> cost[<span class="number">1</span>],b = cost[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> b;</span><br><span class="line">        b = Math.min(a,temp) + cost[i];</span><br><span class="line">        a = temp;</span><br><span class="line">        <span class="comment">//b在每轮循环结束就是dp[i]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改爬楼梯问题说明无后效性"><a href="#修改爬楼梯问题说明无后效性" class="headerlink" title="修改爬楼梯问题说明无后效性"></a>修改爬楼梯问题说明无后效性</h2><p>无后效性就是说，给定一个确定的状态，问题未来的发展只与当前状态有关，而与过去经历的所有状态无关。<br>就是说只依赖前序状态当前的已有的信息，但和前序状态时如何实现的无关<br>上面的爬楼梯问题都是这样。<br>但如果加一个约束条件：<br><code>给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶，但不能连续两轮跳 1阶，请问有多少种方案可以爬到楼顶？</code><br>如果上一轮是跳1阶，下一轮必须跳2阶，意味着下一步选择不能有当前状态决定，还和前一个状态有关。<br>但我们可以扩展状态的定义，状态[i,j]表示在第i阶，并且上一轮跳了j阶，j属于{1,2}。这样又满足了无后效性<br>则有<br>dp[i,j] &#x3D; dp[i,1] + dp[i,2] &#x3D; dp[i-1,2] + dp[i-2,1] + dp[i-2,2]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">clim</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化dp表</span></span><br><span class="line">    <span class="type">int</span>[][]dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[i][<span class="number">2</span>] = dp[i-<span class="number">2</span>][<span class="number">1</span>]+dp[i-<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][<span class="number">1</span>]+dp[n][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的可以通过扩展状态定义满足无后效性<br>但是有时候会有无法做到<br><code>给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶。规定当爬到第 i阶时，系统自动会在第 2i阶上放上障碍物，之后所有轮都不允许跳到第 2i阶上。例如，前两轮分别跳到了第 2、3 阶上，则之后就不能跳到第 4、6 阶上。请问有多少种方案可以爬到楼顶？</code><br>这个问题每次的跳跃都会影响未来的跳跃</p><h2 id="表格问题"><a href="#表格问题" class="headerlink" title="表格问题"></a>表格问题</h2><p>先判断问题能否回溯，之后根据加分减分可以尝试是否使用动态规划</p><p><code>给定一个n*m的二维网格 grid ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。</code></p><p><strong>分析</strong></p><ol><li><p>思考每轮决策，定义状态得到dp表  </p><p> 本题每轮决策是从当前格子向下或者向右。因此状态应该包括行列索引两个变量，[i,j]  </p><p> 状态[i,j]对应的子问题就是：从起点[0,0]走到[i,j]的最小代价路径和，记为dp[i,j]</p></li></ol><p><img src="/img_19.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_19.png"></p><ol start="2"><li><p>找出最优子结构进而推导状态转移方程 </p><p> dp[i,j]&#x3D;min(dp[i-1,j],dp[i,j-1])+grid[i,j] (grid[i,j]是[i,j]处格点的代价)</p></li><li><p>确定边界条件和状态转移顺序 </p><p> 首行的状态只能由左边的状态得到，首列的状态只能由上班的状态得到。因此i&#x3D;0,j&#x3D;0就是边界条件</p><p> 如图 14-13 所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列。<br> <img src="/img_20.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_20.png"><br> 这是为了保证计算当前解时，以来的更小子问题的解都被计算出来了</p></li></ol><p><strong>实现</strong><br>因为子问题分解时从顶到底的思想，所以按照 暴力搜索、 记忆化搜索 、动态规划顺序展示</p><ol><li><p>暴力搜索</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：暴力搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minPathSumDFS</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 若为左上角单元格，则终止搜索</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若行列索引越界，则返回 +∞ 代价</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> minPathSumDFS(grid, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minPathSumDFS(grid, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回从左上角到 (i, j) 的最小路径代价</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(left, up) + grid[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img_21.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_21.png"><br>每个状态都能向下和向右，从左上角到右下角需要m+n-2步，所以复杂度O(2^(m+n))</p></li><li><p>记忆化搜索<br>引入mem记忆列表记录子问题的解并对重叠子问题剪枝</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小路径和：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">minPathSumDFSMem</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span>[][] mem, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 若为左上角单元格，则终止搜索</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若行列索引越界，则返回 +∞ 代价</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左边和上边单元格的最小路径代价</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> minPathSumDFSMem(grid, mem, i - <span class="number">1</span>, j);</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minPathSumDFSMem(grid, mem, i, j - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 记录并返回左上角到 (i, j) 的最小路径代价</span></span><br><span class="line">    mem[i][j] = Math.min(left, up) + grid[i][j];</span><br><span class="line">    <span class="keyword">return</span> mem[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img_22.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_22.png"><br>引入记忆后所有子问题的解只算一次，时间复杂度O(mn)</p></li><li><p>动态规划</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minPath</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length,m = grid[<span class="number">0</span>].length;<span class="comment">//n是行数，m是列数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//状态转移首行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt; m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//首列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>]+grid[i][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他行列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j]) + grid[i][j];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(mn),空间复杂度O(mn)(dp表)</p></li></ol><p>也可以空间优化，因为每个格子之和左边和上边的格子有关，因此可以只用一个单行数组实现dp表   （无法进一步优化，虽然对于每个格点只需要左侧和上方，左侧可以只用一个量，但是上方的对于每一行不同列的格点都不同，至少需要保存上面一整行）<br>但，因为数组 dp 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minPath</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length,m = grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">    <span class="comment">//状态转移:首行</span></span><br><span class="line">    dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移其余行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="comment">//状态转移首列</span></span><br><span class="line">        dp[<span class="number">0</span>] = dp[<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//状态转移其他列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = Math.min(dp[j-<span class="number">1</span>],dp[j]) + grid[i][j];<span class="comment">//dp[j-1]是已经被更新的左侧的，dp[j]被更新前是上面一行同列的元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以把空间复杂度降到O（m)</p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p>给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。</p><p>这里物品编号从1开始所以i对于的wgt[i-1]</p><p>可以看成n轮决策组成的过程，每个物体都有不放入和放入两种决策，满足决策树模型</p><p>同时求的是最大价值，因此很可能能用动态规划</p><ol><li><p>思考每轮决策定义状态得到dp表</p><p> 每个物品不放入背包，背包容量不变；放入背包容量减小。</p><p> 定义状态：当前物品编号i和背包容量c。</p><p> [i,c]对应子问题：前i个物品在容量为c的背包中的最大价值，记为dp[i,c]</p><p> 待求解的是dp[n,cap]，需要一个（n+1）*(cap+1)的表</p></li><li><p>找出最优子结构并推出状态转移方程</p><p> 对i做决策时分为一下两种情况：</p><ol><li>不放入i,则dp[i,c] &#x3D; dp[i-1,c]</li><li>放入i,则dp[i,c] &#x3D; dp[i-1,c-wgt[i-1]] + val[i-1]<br>因此最终状态转移方程：dp[i,c] &#x3D; max(dp[i-1,c] , dp[i-1,c-wgt[i-1]] + val[i-1])</li></ol></li><li><p>确定边界条件和状态转移顺序</p><ol><li>边界：当物品或背包为0，最大价值为0.即为首行首列dp[i,0]和dp[0,c]为0</li><li>每个其他dp都要由左上方的和正上方的两个状态确定，因此通过两层正循环遍历即可</li></ol></li></ol><p><strong>实现</strong></p><ol><li>暴力搜索<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：暴力搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDFS</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> knapsackDFS(wgt, val, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 返回两种方案中价值更大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(no, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/img_23.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_23.png"><br>有很多重复</li><li>记忆化搜索:借助记忆列表 mem 来记录子问题的解<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 0-1 背包：记忆化搜索 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">knapsackDFSMem</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span>[][] mem, <span class="type">int</span> i, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 若已选完所有物品或背包无剩余容量，则返回价值 0</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> || c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若已有记录，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (mem[i][c] != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若超过背包容量，则只能选择不放入背包</span></span><br><span class="line">    <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">        <span class="keyword">return</span> knapsackDFSMem(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算不放入和放入物品 i 的最大价值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">no</span> <span class="operator">=</span> knapsackDFSMem(wgt, val, mem, i - <span class="number">1</span>, c);</span><br><span class="line">    <span class="type">int</span> <span class="variable">yes</span> <span class="operator">=</span> knapsackDFSMem(wgt, val, mem, i - <span class="number">1</span>, c - wgt[i - <span class="number">1</span>]) + val[i - <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 记录并返回两种方案中价值更大的那一个</span></span><br><span class="line">    mem[i][c] = Math.max(no, yes);</span><br><span class="line">    <span class="keyword">return</span> mem[i][c];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>时间负载的取决于子问题的数量，也就是dp表的数量，降到了O(n*cap)</li><li>动态规划<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapsackDP</span><span class="params">(<span class="type">int</span>[] wgt,<span class="type">int</span>[] val,<span class="type">int</span> cap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">//初始化dp表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][cap+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>;c &lt;= cap;c++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wgt[i - <span class="number">1</span>] &gt; c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果超过背包容量，一定不选i</span></span><br><span class="line">                dp[i][c] = dp[i-<span class="number">1</span>][c];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][c] = Math.max(dp[i-<span class="number">1</span>][c],dp[i-<span class="number">1</span>][c - wgt[i-<span class="number">1</span>]]+val[i-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面没有显示初始化首行首列，因为Java定义时直接所有元素为0</li></ol><p>时间复杂度空间复杂度都是O(n*cap)<br>4. 空间优化<br>每个状态只和上一行的状态(正上方左上方）有关，因此可以两个数组滚动前进。复杂度降低到O(n)<br>还能继续降低，使用一个数组。但行序需要倒叙遍历<br>因为，假设只有一个数组，开始遍历第i行时，该数组储存的还是i-1行的状态<br>    1. 如果正序，遍历到dp[i,j]时，左上方的值已经被覆盖了<br>    2. 如果倒叙，不存在覆盖问题（同一行代表同一元素，对应的背包容量缩减量相同）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">knapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt ,<span class="type">int</span>[] val,<span class="type">int</span> cap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//状态转移</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//倒叙遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span>cap;c &gt;= <span class="number">1</span>;c--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(wgt[i-<span class="number">1</span>] &lt;= c)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[c] = Math.max(dp[c],dp[c - wgt[i - <span class="number">1</span>] ]+ val[i-<span class="number">1</span>]);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h2><p>给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。<strong>每个物品可以重复选取</strong>，问在限定背包容量下能放入物品的最大价值。</p><ol><li>思路：核心就是可以重复选取了<br>状态[i,c]分为两种情况：<ol><li>不放入i：转移至[i-1,c]</li><li>放入i：转移至[i,c-wgt[i-1]]<br>状态方程  $dp[i, c] &#x3D; \max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1])$</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDP</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[i][c] = dp[i - <span class="number">1</span>][c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[i][c] = Math.max(dp[i - <span class="number">1</span>][c], dp[i][c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几乎一样，只是一处i-1变为i<br>3. 空间优化<br>   由于当前状态是从左边和上边的状态转移而来的，因此空间优化后应该对dp表中的每一行进行正序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 完全背包：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">unboundedKnapsackDPComp</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> wgt.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cap + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">1</span>; c &lt;= cap; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wgt[i - <span class="number">1</span>] &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若超过背包容量，则不选物品 i</span></span><br><span class="line">                dp[c] = dp[c];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选物品 i 这两种方案的较大值</span></span><br><span class="line">                dp[c] = Math.max(dp[c], dp[c - wgt[i - <span class="number">1</span>]] + val[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[cap];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="零钱兑换问题"><a href="#零钱兑换问题" class="headerlink" title="零钱兑换问题"></a>零钱兑换问题</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><p>给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，<strong>每种硬币可以重复选取</strong>，问能够凑出目标金额的最少硬币数量，硬币面值至少为1。如果无法凑出目标金额，则返回 $-1$ </p><ol><li>可以看作完全背包的特殊情况<ol><li>物品对应硬币，重量对应面值，背包容量对应目标金额</li><li>相反，这个要最小化硬币数量</li><li>完全背包要求是不超过背包容量，零钱兑换要求是恰好</li></ol></li><li>思考每轮决策，定义状态得到dp表<br> [i,a]对应的子问题：前i种硬币能凑出金额a的最少硬币数量，记为dp[i,a]<br> dp表(n+1)*(amt+1)</li><li>找最优子结构状态转移方程<br>dp[i,a] &#x3D; min(dp[i-1,a],dp[i,a-coins[i-1]] + 1)</li><li>确定边界条件和转移顺序<br> 目标金额为0，数量为0，即首列都为0<br> 五硬币时，无法凑出，可以记为无限大，即首行都是无限大</li><li>实现<br>大多数语言没提供无限大，因此只能用整型int的最大值替代，但是这样+1操作可能溢出，因此采用amt+1表示无限，因为凑出amt的硬币最多就是amt（面值至少为1），返回前需要判断dp[n,amt]是否等于amt+1<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChangeDP</span><span class="params">(<span class="type">int</span>[] coins,<span class="type">int</span> amt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> amt + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始化dp表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][amt+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//状态转移:首列行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;a&lt;=amt;a++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][a] = MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移：其余列行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[i - <span class="number">1</span>] &gt; a)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//超过目标金额，不选i</span></span><br><span class="line">                dp[i][a] = dp[i-<span class="number">1</span>][a];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][a] = Math.min(dp[i - <span class="number">1</span>][a],dp[i][a - coins[i - <span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt] != MAX ? dp[n][amt] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>空间优化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeDPComp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> amt + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp,MAX);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;a &lt;= amt;a++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(coins[i - <span class="number">1</span>] &gt; a)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果超过目标金额，不选硬币</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[a] = Math.min(dp[a],dp[a - coins[i - <span class="number">1</span>] + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt] != MAX ? dp[amt] : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，<strong>问凑出目标金额的硬币组合数量</strong>。</p><ol><li><p>思路<br>本题时求组合数量，因此子问题变为前i种硬币凑出金额a的组合数量，dp表尺寸依然是(n+1)*(amt+1)</p><p>显然状态转移方程：dp[i, a] &#x3D; dp[i-1, a] + dp[i, a - coins[i-1]]</p><p> 目标金额为0时，无需选择，因此dp[i,0]为1;没有硬币时组合数是0，即dp[0,a]为0</p></li><li><p>实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDP</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][amt + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 初始化首列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[i][a] = dp[i - <span class="number">1</span>][a] + dp[i][a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化空间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换 II：空间优化后的动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeIIDPComp</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> coins.length;</span><br><span class="line">    <span class="comment">// 初始化 dp 表</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amt + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>; a &lt;= amt; a++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (coins[i - <span class="number">1</span>] &gt; a) &#123;</span><br><span class="line">                <span class="comment">// 若超过目标金额，则不选硬币 i</span></span><br><span class="line">                dp[a] = dp[a];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不选和选硬币 i 这两种方案之和</span></span><br><span class="line">                dp[a] = dp[a] + dp[a - coins[i - <span class="number">1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amt];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="编辑距离问题（Levenshtein-距离）"><a href="#编辑距离问题（Levenshtein-距离）" class="headerlink" title="编辑距离问题（Levenshtein 距离）"></a>编辑距离问题（Levenshtein 距离）</h2><p>输入两个字符串 $s$ 和 $t$ ，返回将 $s$ 转换为 $t$ 所需的最少编辑步数。</p><p>你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。</p><ol><li>思路分析<br>可以看错决策树模型，字符串对应树节点，一轮决策（编辑操作）对应一条边。<br> <img src="/img_24.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/img_24.png"><br> 如图，把hello转化成algo，从决策树的角度看，本题的目标是求解节点 hello 和节点 algo 之间的最短路径。<ol><li><p>思考每轮决策，定义状态得到dp表<br> 每轮决策是对s进行一次编辑操作，希望编辑过程问题规模越来越小，这样方便构建子问题<br> 设s，t长度分别n，m，先考虑尾部字符。  </p><ul><li>若s[n-1]和t[m-1]相同，可以跳过，考虑s[n-2]t[n-2]</li><li>如果不同，对s进行一次操作（插入替换删除），使尾部字符相同，从而可以考虑更小规模的问题<br> 也就是对s每次操作都会改变待匹配的字符。<br> 定义状态[i,j]代表s，t当前考虑i，j字符<br>对应子问题：将s的前i个字符更改为t的前j个字符所需的最小编辑步数，得到(i+1)*(j+1)的dp表</li></ul></li><li><p>最优子结构，状态转移方程<br>问题dp[i,j]分为三种情况：</p><ol><li>s[i-1]后添加t[i-1]，则剩余子问题dp[i,j-1]</li><li>删除s[i-1]，则剩余子问题dp[i-1,j]</li><li>替换s[i-1]为t[i-1],剩余dp[i-1,j-1]</li><li>特殊情况当s[i-1]和t[i-1]相同时，就是dp[i-1,j-1]</li></ol><p> 状态转移方程：dp[i,j] &#x3D; min(dp[i,j-1],dp[i-1,j],dp[i-1,j-1])+1<br> 特殊情况：dp[i,j] &#x3D; dp[i-1,j-1]</p></li><li><p>边界条件和状态转移顺序<br> 两字符串都为空时，步数为0，即dp[0,0] &#x3D; 0<br> 任意一个为空时，dp[0,j]和dp[i,0]分别为j，i<br> dp[i,j]依赖左方，左上方，上方的解，因此正序循环即可</p></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">editDistanceDP</span><span class="params">(String s,String t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(),m = t.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//状态转移:首列首行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//状态转移：其他行列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j-<span class="number">1</span>],dp[i-<span class="number">1</span>][j],dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>空间优化：<br>dp[i,j]由上方，左方，左上方转移而来，正序遍历会丢失左上方，倒序遍历dp[i,j-1]无法构建，都不行<br>但可以使用leftup暂存dp[i-1,j-1],从而可以正序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">editDistanceDPComp</span><span class="params">(String s ,String t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(),m = t.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//状态转移：首行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftup</span> <span class="operator">=</span> dp[<span class="number">0</span>];<span class="comment">//暂存dp[i-1,j-1]</span></span><br><span class="line">        dp[<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dp[j];</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == t.charAt(j - <span class="number">1</span>))&#123;</span><br><span class="line">                dp[i] = leftup;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>],dp[j],leftup) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            leftup = temp;<span class="comment">//dp[i-1][j-1] (左上方): 这是最棘手的部分。当我们准备计算 dp[j] 时，我们需要的 dp[i-1][j-1] 在哪里？它就是上一轮循环中 dp[j-1] 的旧值。但是，dp[j-1] 已经被更新为 dp[i][j-1] 了，它的旧值丢失了！在旧值被覆盖之前，把它保存下来</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h2 id=&quot;定义和概念&quot;&gt;&lt;a href=&quot;#定义和概念&quot; class=&quot;headerlink&quot; title=&quot;定义和概念&quot;&gt;&lt;/a&gt;定义和概念&lt;/h2&gt;&lt;p&gt;将问题分解为一系列更小的子问题，并且通过储存子问题的解来避免重复计算，从而提高时间效率  &lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义和基本概念"><a href="#定义和基本概念" class="headerlink" title="定义和基本概念"></a>定义和基本概念</h1><p>分治包括分和治两个阶段</p><ol><li>分：递归的将原问题划分为两个或者多个子问题，直到达到最小子问题</li><li>治：从已知解的最小子问题开始，从低至顶将子问题的解进行合并，构建出原问题的解</li></ol><span id="more"></span><p> 总操作数是O(n + n^2&#x2F;2 + n) &#x3D; O(n^2&#x2F;2 + 2n)<br><img src="/img_7.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%88%86%E6%B2%BB/img_7.png"><br>做差可证明只要n&gt;4分解后的操作数更小<br>如果一直划分直到每个子数组只剩一个元素，即为归并排序<br>如果设置多个划分点，原数组平均划分成k个子数组，即为桶排序<br>2. 并行优化计算<br>分治的子问题一般独立，可以并行解决，利于操作系统的并行优化  </p><h2 id="分治搜索"><a href="#分治搜索" class="headerlink" title="分治搜索"></a>分治搜索</h2><p>O(logn)的搜索通常都使用了分治策略<br>如二分查找  </p><ol><li>原问题可以分解：可以把原问题分解成在一半的子数组查找</li><li>子问题独立：每轮处理一个子问题，不受其他子问题影响，当区间只剩一个元素或为空时，问题就变得足够简单，可以直接判断并求解。</li><li>子问题无需合并：子问题解决意味着原问题解决<br>下面是二分查找的递归实现，更能体现分治的特定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找：问题 f(i, j) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// 若区间为空，代表无目标元素，则返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算中点索引 m</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(m+1, j)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(nums, target, m + <span class="number">1</span>, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">        <span class="comment">// 递归子问题 f(i, m-1)</span></span><br><span class="line">        <span class="keyword">return</span> dfs(nums, target, i, m - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 二分查找 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 求解问题 f(0, n-1)</span></span><br><span class="line">    <span class="keyword">return</span> dfs(nums, target, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="构建二叉树"><a href="#构建二叉树" class="headerlink" title="构建二叉树"></a>构建二叉树</h2><p>给定二叉树前序遍历<code>preorder</code>和中序遍历<code>inorder</code>,构建二叉树，并返回根节点<br>例如<br><code>preorder</code>:[3,9,2,1,7]<br><code>inorder</code>:[9,3,1,2,7]<br><img src="/img_8.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%88%86%E6%B2%BB/img_8.png"></p><hr><p><strong>分析</strong></p><ol><li><p>能否分治</p><ol><li>问题可以分解：简单的可以划分为两个子问题。<ol><li>构建左子树</li><li>构建右子树</li><li>当然还要加上一个操作：初始化根节点。<br>继续划分直到最小资问题（空子树）停止</li></ol></li><li>子问题是独立的：<br>  左子树和右子树独立无交集。构建左子树只需要关心中序遍历和前序遍历对应的左子树部分。右子树也是  </li><li>子问题可以合并：<br>  得到了左子树和右子树（子问题的解），可以连接到根节点上，最终得到原问题的解</li></ol></li><li><p>如何划分子树  </p><ul><li>前序遍历：[根节点 | 左子树 | 右子树]</li><li>中序节点：[左子树 | 根节点 | 右子树]</li></ul></li><li><p>一般化基于变量描述划分</p><ul><li>当前树根节点在preorder中的索引记为i</li><li>当前树的根节点在inorder中的索引记为m</li><li>当前树在inorder中的索引区间记为[l,r]</li></ul><p> 于是  </p><table><thead><tr><th align="center"></th><th align="center">根节点在preorder中的索引区间</th><th align="center">在inorder的索引区间</th></tr></thead><tbody><tr><td align="center">当前树</td><td align="center">i</td><td align="center">[l,r]</td></tr><tr><td align="center">左子树</td><td align="center">i+1</td><td align="center">[l,m-1]</td></tr><tr><td align="center">右子树</td><td align="center">i+1+(m-l)</td><td align="center">[m+1,r]</td></tr><tr><td align="center">如下图：</td><td align="center"></td><td align="center"></td></tr><tr><td align="center"><img src="/img_9.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%88%86%E6%B2%BB/img_9.png"></td><td align="center"></td><td align="center"></td></tr></tbody></table></li></ol><hr><p><strong>实现</strong><br>为了提高查询m的效率，使用哈希表存储inorder中元素到索引的映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] preorder,Map&lt;Integer,Integer&gt; inorderMap,<span class="type">int</span> i ,<span class="type">int</span> l,<span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//子树区间为空时终止</span></span><br><span class="line">    <span class="keyword">if</span>(r - l &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[i]);</span><br><span class="line">    <span class="comment">// 查询当前根节点在中序遍历的索引m</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> inorderMap.get(preorder[i]);</span><br><span class="line">    <span class="comment">//子问题：构建左子树</span></span><br><span class="line">    root.left = dfs(preorder,inorderMap,i+<span class="number">1</span>,l,m - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//子问题：构建右子树</span></span><br><span class="line">    root.right = dfs(preorder,inorderMap,i+<span class="number">1</span>+m-l,m+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder,<span class="type">int</span>[] inorder)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化哈希表存入inorder，元素为key，索引为value</span></span><br><span class="line">    Map&lt;Integer,Integer&gt; inorderMap = <span class="keyword">new</span>  <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; inorder.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        inorderMap.put(inorder[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> dfs(preorder,inorderMap,<span class="number">0</span>,<span class="number">0</span>,inorder.length-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：对于每个节点初始化一次，每个节点的操作都是O(1),因此总复杂度是O(N).<a href="%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">点击看常见递归复杂度分析方法</a></li><li>空间复杂度：O(n).哈希表O(n),递归调用栈在最差时树退化为链表成为O(n)</li></ul><h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p>给定三根柱子，记为 A、B 和 C 。起始状态下，柱子 A 上套着<br>个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这<br>个圆盘移到柱子 C 上，并保持它们的原有顺序不变（如图 12-10 所示）。在移动圆盘的过程中，需要遵守以下规则。</p><ol><li>圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入。</li><li>每次只能移动一个圆盘。</li><li>小圆盘必须时刻位于大圆盘之上。</li></ol><hr><p><strong>分析</strong></p><ol><li>考虑基本情况f(1)<br> 直接从a-&gt;c即可</li><li>f(2)  <ol><li>最上方小圆盘a-&gt;b</li><li>大圆盘a-&gt;c</li><li>小圆盘b-&gt;c</li></ol></li><li>f(3)  <ol><li>b为目标，c为缓冲，两个小圆盘a-&gt;b(执行一个f(2))</li><li>大圆盘a-&gt;c</li><li>c为目标，a为缓冲，两个小圆盘b-&gt;c(执行一个f(2))</li></ol><ul><li>把f(3)分解成了两个f(2)和一个f(1).这说明原问题是可以分解的，子问题是独立的，解决完子问题之后解可以合并</li></ul></li><li>f(n)<br>可以分治  <ol><li>n-1个圆盘a-&gt;b，借助c</li><li>1个圆盘a-&gt;c</li><li>n-1个圆盘b-&gt;c，借助a<br> <img src="/img_10.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%88%86%E6%B2%BB/img_10.png"></li></ol></li></ol><hr><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*移动一个圆盘*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">move</span><span class="params">(List&lt;Integer&gt; src, List&lt;Integer&gt; tar)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">pan</span> <span class="operator">=</span> src.remove(src.size() - <span class="number">1</span>);</span><br><span class="line">    tar.add(pan);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, List&lt;Integer&gt; src,List&lt;Integer&gt; buf, List&lt;Integer&gt; tar)</span>&#123;</span><br><span class="line">    <span class="comment">/*如果src只剩一个圆盘直接移动接口*/</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        move(src,tar);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//f(i-1),先把i-1个移动到buf</span></span><br><span class="line">    dfs(i - <span class="number">1</span>, src,tar,buf);</span><br><span class="line">    <span class="comment">//f(1),移动最上面的大的</span></span><br><span class="line">    move(src,tar);</span><br><span class="line">    <span class="comment">//f(i-1),buf的i-1个移动到tar</span></span><br><span class="line">    dfs(i - <span class="number">1</span>, buf,src,tar);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">solveHanota</span><span class="params">(List&lt;Integer&gt; A,List&lt;Integer&gt; B, List&lt;Integer&gt; C)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.size();</span><br><span class="line">    dfs(n,A,B,C);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：T(n) &#x3D; 2T(n-1) + O(1),不满足主定理的形式，画出递归树分析<br>  <img src="/img_11.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%88%86%E6%B2%BB/img_11.png">  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     T(n) -----O(1)的move操作</span><br><span class="line">    /    \</span><br><span class="line">T(n-1)  T(n-1) -----O(2)的move</span><br><span class="line">        </span><br><span class="line">                   </span><br></pre></td></tr></table></figure>  一共n+1层，每层操作数是2^(k),k属于[0,n]<br>  最终和是1+2+4……+2^n,因此时间复杂度就是O(2^n)<br>  也可以选择直接展开，或者通项</li><li>空间复杂度：递归调用栈O(n)</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义和基本概念&quot;&gt;&lt;a href=&quot;#定义和基本概念&quot; class=&quot;headerlink&quot; title=&quot;定义和基本概念&quot;&gt;&lt;/a&gt;定义和基本概念&lt;/h1&gt;&lt;p&gt;分治包括分和治两个阶段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分：递归的将原问题划分为两个或者多个子问题，直到达到最小子问题&lt;/li&gt;
&lt;li&gt;治：从已知解的最小子问题开始，从低至顶将子问题的解进行合并，构建出原问题的解&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯复杂度分析</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯算法复杂度分析的核心思想"><a href="#回溯算法复杂度分析的核心思想" class="headerlink" title="回溯算法复杂度分析的核心思想"></a>回溯算法复杂度分析的核心思想</h3><p>分析回溯算法的时间复杂度，本质上是在分析其递归搜索树的规模。因为回溯算法在最坏情况下会遍历整个解空间树，所以其时间复杂度通常是指数级别或阶乘级别的。  </p><span id="more"></span><p>其实就是<a href="%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">递归复杂度分析.md</a>中的递归树的方法</p><p>一个通用的、简化的分析公式是：</p><p><strong>时间复杂度 ≈ 递归调用次数 × 每次递归中执行的操作数</strong></p><p>更精确地说，这可以分解为两个关键部分的分析：</p><ol><li><strong>解空间树的节点总数</strong>：这代表了递归函数被调用的最多次数。</li><li><strong>每个节点上的操作耗时</strong>：这指的是在单次递归函数调用中，除了递归调用自身之外，其他操作（如循环、判断、添加结果等）所花费的时间。</li></ol><p>分析起来可能比较困难，但我们可以通过估算递归代码将计算多少个不同的状态，以及在每个递归调用中发生了多少次操作来进行估计。</p><hr><h3 id="分析回溯算法复杂度的思考顺序"><a href="#分析回溯算法复杂度的思考顺序" class="headerlink" title="分析回溯算法复杂度的思考顺序"></a>分析回溯算法复杂度的思考顺序</h3><p>遵循以下步骤，可以帮助你清晰、准确地分析出回溯算法的时间复杂度。</p><h4 id="第一步：画出（或想象出）递归搜索树"><a href="#第一步：画出（或想象出）递归搜索树" class="headerlink" title="第一步：画出（或想象出）递归搜索树"></a>第一步：画出（或想象出）递归搜索树</h4><p>这是最重要的一步。你需要明确算法的搜索过程是怎样的，这通常可以用一棵树来表示。</p><ul><li><strong>树的宽度（分支因子）</strong>：在递归的每一层，你有多少种选择？这决定了每个节点有多少个子节点。</li><li><strong>树的深度</strong>：递归会进行多少层？这通常与输入数据的规模 <code>n</code> 相关。</li></ul><p><strong>示例：</strong></p><ul><li><strong>全排列问题</strong>：对于 <code>n</code> 个不同的元素，第一层有 <code>n</code> 个选择，第二层有 <code>n-1</code> 个选择，以此类推。</li><li><strong>子集问题</strong>：对于 <code>n</code> 个元素，每个元素都有“选”和“不选”两种状态，所以每层都有 2 个分支。</li></ul><h4 id="第二步：计算递归树的节点总数"><a href="#第二步：计算递归树的节点总数" class="headerlink" title="第二步：计算递归树的节点总数"></a>第二步：计算递归树的节点总数</h4><p>根据递归树的结构，估算树中节点的总数。这是复杂度的主要决定因素。</p><ul><li><p>**排列问题 (Permutations)**：</p><ul><li>输入 <code>[1, 2, 3]</code> 的递归树，第一层有3个节点，第二层每个节点下有2个分支，第三层有1个分支。叶子节点的数量是 <code>3 * 2 * 1 = 3!</code>。</li><li>总的节点数大约是 <code>n!</code> 级别的。</li><li><strong>复杂度估算</strong>：通常为 **O(n!)**。</li></ul></li><li><p>**子集问题 (Subsets) &#x2F; 组合问题 (Combinations)**：</p><ul><li>对于 <code>n</code> 个元素，每个元素都有“选”与“不选”两种可能，因此解空间的大小是 <code>2^n</code>。</li><li>递归树的深度为 <code>n</code>，节点总数是 <code>1 + 2 + 4 + ... + 2^n</code>，这是一个等比数列，总和约为 <code>2^n</code>。</li><li><strong>复杂度估算</strong>：通常为 **O(2^n)**。</li></ul></li><li><p>**N皇后问题 (N-Queens)**：</p><ul><li>第一行皇后有 <code>N</code> 个位置可选，第二行最多有 <code>N-1</code> 个，以此类推。</li><li>虽然看起来是 <code>N* (N-1) * ...</code>，但由于剪枝（皇后间的攻击规则），实际搜索空间远小于 <code>N^N</code>，但大于 <code>N!</code>。不过在最坏情况下的上界分析中，通常近似为 **O(N!)**。</li></ul></li><li><p>**解数独 (Sudoku Solver)**：</p><ul><li>假设有 <code>m</code> 个空格需要填。每个空格最多有 9 种选择。</li><li><strong>复杂度估算</strong>：最坏情况下是 **O(9^m)**，其中 <code>m</code> 是待填空格的数量。</li></ul></li></ul><h4 id="第三步：分析单次递归调用的时间复杂度"><a href="#第三步：分析单次递归调用的时间复杂度" class="headerlink" title="第三步：分析单次递归调用的时间复杂度"></a>第三步：分析单次递归调用的时间复杂度</h4><p>现在，看你的 <code>backtrack</code> 函数内部，除了递归调用 <code>backtrack(...)</code> 之外，还做了哪些操作？</p><ul><li><strong>循环</strong>：函数内部是否有 <code>for</code> 循环？循环的次数是多少？<ul><li>例如，在全排列问题中，<code>for</code> 循环遍历所有选择，复杂度为 O(n)。</li><li>在组合问题中，<code>for</code> 循环也可能遍历 O(n) 次。</li></ul></li><li><strong>构造结果</strong>：当找到一个合法解时（通常在递归的叶子节点），需要将当前路径（<code>path</code>）复制一份并存入最终结果（<code>result</code>）中。<ul><li>如果路径的长度是 <code>k</code>，那么这个复制操作的耗时就是 O(k)。在很多问题中，路径的最大长度是 <code>n</code>，所以这里耗时 O(n)。</li></ul></li></ul><h4 id="第四步：整合计算，得出最终复杂度"><a href="#第四步：整合计算，得出最终复杂度" class="headerlink" title="第四步：整合计算，得出最终复杂度"></a>第四步：整合计算，得出最终复杂度</h4><p>将前两步的结果相乘，并进行简化。</p><ul><li><p>**全排列问题 (Permutations of n distinct elements)**：</p><ul><li>节点总数（叶子节点）：<code>n!</code></li><li>到达每个叶子节点时，需要 O(n) 的时间复制路径。</li><li><strong>总时间复杂度</strong>：<code>O(n * n!)</code>。</li></ul></li><li><p>**子集问题 (Subsets of n elements)**：</p><ul><li>节点总数：<code>2^n</code></li><li>每个子集都需要被拷贝到结果列表中，平均长度为 O(n)。</li><li><strong>总时间复杂度</strong>：<code>O(n * 2^n)</code>。</li></ul></li><li><p>**组合问题 (Combinations - C(n, k))**：</p><ul><li>节点总数（叶子节点）：<code>C(n, k)</code></li><li>每个组合的长度是 <code>k</code>，复制耗时 O(k)。</li><li><strong>总时间复杂度</strong>：<code>O(k * C(n, k))</code>。</li></ul></li></ul><h4 id="第五步：考虑剪枝的影响"><a href="#第五步：考虑剪枝的影响" class="headerlink" title="第五步：考虑剪枝的影响"></a>第五步：考虑剪枝的影响</h4><p>回溯算法的精髓在于“剪枝”（Pruning），即提前终止那些不可能产生合法解的搜索路径。</p><ul><li><strong>对于复杂度分析</strong>：通常我们分析的是<strong>最坏情况时间复杂度</strong>，此时可以不考虑剪枝带来的优化，或者只考虑那些非常明确、一定会发生的剪枝。</li><li><strong>剪枝的意义</strong>：虽然最坏时间复杂度可能不变，但剪枝能极大地优化算法在平均情况下的性能，使其能够处理更大规模的数据。例如，在N皇后问题中，剪枝是算法能够实际运行的关键。</li></ul><h3 id="总结与范例"><a href="#总结与范例" class="headerlink" title="总结与范例"></a>总结与范例</h3><table><thead><tr><th align="left">问题类型</th><th align="left">递归树特点</th><th align="left">节点&#x2F;状态数</th><th align="left">单次操作耗时</th><th align="left">最终时间复杂度</th></tr></thead><tbody><tr><td align="left"><strong>全排列</strong></td><td align="left">深度为n，每层分支数递减 (n, n-1, …)</td><td align="left">O(n!)</td><td align="left">O(n) (复制结果)</td><td align="left"><strong>O(n * n!)</strong></td></tr><tr><td align="left"><strong>子集</strong></td><td align="left">深度为n，每层分支数为2</td><td align="left">O(2^n)</td><td align="left">O(n) (复制结果)</td><td align="left"><strong>O(n * 2^n)</strong></td></tr><tr><td align="left"><strong>组合</strong></td><td align="left">深度为k，分支数变化</td><td align="left">O(C(n, k))</td><td align="left">O(k) (复制结果)</td><td align="left"><strong>O(k * C(n, k))</strong></td></tr><tr><td align="left"><strong>N皇后</strong></td><td align="left">深度为N，分支数 &lt;&#x3D; N</td><td align="left">O(N!)</td><td align="left">O(N) 或 O(1) (检查合法性)</td><td align="left"><strong>O(N!)</strong></td></tr></tbody></table><p>记住，分析回溯算法的复杂度不需要像数学推导那样百分之百精确，尤其是在面试中。关键是能够清晰地画出递归树模型，并基于模型估算出复杂度的量级，讲清楚你的分析思路。</p><hr><h1 id="下面是子集和问题的复杂度分析"><a href="#下面是子集和问题的复杂度分析" class="headerlink" title="下面是子集和问题的复杂度分析"></a><strong>下面是子集和问题的复杂度分析</strong></h1><h3 id="详细分析过程"><a href="#详细分析过程" class="headerlink" title="详细分析过程"></a>详细分析过程</h3><h4 id="第一步：画出（或想象出）递归搜索树-1"><a href="#第一步：画出（或想象出）递归搜索树-1" class="headerlink" title="第一步：画出（或想象出）递归搜索树"></a>第一步：画出（或想象出）递归搜索树</h4><p>这是理解算法行为的核心。我们以一个具体的例子来可视化这棵树：<code>nums = [2, 3, 6]</code>, <code>target = 7</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">                      ([], target=7, start=0)</span><br><span class="line">                     /           |           \</span><br><span class="line">         (i=0, pick 2)     (i=1, pick 3)     (i=2, pick 6)</span><br><span class="line">                   /             |             \</span><br><span class="line">      ([2], target=5, start=0)  ([3], target=4, start=1)  ([6], target=1, start=2)</span><br><span class="line">      /         |         \           /         \           \</span><br><span class="line">(i=0, p 2) (i=1, p 3) (i=2, p 6) (i=1, p 3) (i=2, p 6)     (i=2, p 6) -&gt; Pruned (1-6&lt;0)</span><br><span class="line">    /           |         |           |         \</span><br><span class="line">([2,2], t=3) ([2,3], t=2) ([2,6], t=-1) ([3,3], t=1) ([3,6], t=-2)</span><br><span class="line">   ...          ...       Pruned!       ...       Pruned!</span><br><span class="line">    |</span><br><span class="line">([2,2,3], t=0) -&gt; Found a solution!</span><br></pre></td></tr></table></figure><p>从这棵树中，我们可以观察到两个重要特性：</p><ol><li><strong>树的宽度（分支数量）</strong>：在树的任意一个节点，它要向下递归的分支数量最多是 <code>n</code> 个（即 <code>nums</code> 数组的长度）。因为 <code>for</code> 循环从 <code>start</code> 开始，所以分支数会小于等于 <code>n</code>。</li><li><strong>树的深度</strong>：树的深度不是固定的 <code>n</code>。它取决于 <code>target</code> 的大小和 <code>nums</code> 中元素的大小。在最坏的情况下，如果我们每次都选择 <code>nums</code> 中最小的元素（假设 <code>min_val</code>），那么递归的最大深度将是 <code>target / min_val</code>。为了简化，我们称其深度为 <code>D</code>，其中 <code>D</code> 约等于 <code>target</code>。</li></ol><h4 id="第二步：计算递归树的节点总数-1"><a href="#第二步：计算递归树的节点总数-1" class="headerlink" title="第二步：计算递归树的节点总数"></a>第二步：计算递归树的节点总数</h4><p>由于这不是一棵结构规整的 <code>2^n</code> 或 <code>n!</code> 树，精确计算节点数非常困难。但我们可以估算一个<strong>上界</strong>。</p><ul><li>**分支因子 (Branching Factor)**：最多为 <code>n</code>。</li><li>**最大深度 (Max Depth)**：最多为 <code>target / min_val</code>。</li></ul><p>在不考虑任何剪枝的情况下，这棵树的节点总数可以粗略地估算为 **O(n^D)**，即 **O(n^(target&#x2F;min_val))**。</p><p>这个估算虽然非常粗略，但它正确地指出了复杂度的关键：<strong>它对 <code>target</code> 的值是指数级的，对 <code>n</code> 也是指数级的</strong>。剪枝（<code>target - choices[i] &lt; 0</code>）会砍掉很多分支，但最坏情况下的复杂度量级依然是这个。</p><h4 id="第三步：分析单次递归调用的时间复杂度-1"><a href="#第三步：分析单次递归调用的时间复杂度-1" class="headerlink" title="第三步：分析单次递归调用的时间复杂度"></a>第三步：分析单次递归调用的时间复杂度</h4><p>现在我们看 <code>backtrack</code> 函数内部做了什么（除了递归调用本身）：</p><ol><li><code>if (target == 0)</code>：这是一个 O(1) 的判断。</li><li><code>res.add(new ArrayList&lt;&gt;(state))</code>: <strong>这是一个关键操作</strong>。当找到一个解时，需要将当前的 <code>state</code> (路径) 复制一份放入结果集 <code>res</code> 中。如果 <code>state</code> 的长度是 <code>k</code>，这个复制操作的时间复杂度就是 O(k)。在我们的问题中，路径的最大长度 <code>k</code> 不会超过 <code>target</code>（因为 <code>nums</code> 里的都是正整数），所以这里的时间是 **O(target)**。</li><li><code>for</code> 循环：<code>for (int i = start; i &lt; choices.length; i++)</code>。这个循环最多执行 <code>n</code> 次。</li><li>循环内部：<code>state.add()</code> 和 <code>state.remove()</code> 通常可以看作是 O(1) 的操作。</li></ol><p>所以，在每个<strong>非叶子节点</strong>，主要耗时是 <code>for</code> 循环，为 O(n)。在每个<strong>作为解的叶子节点</strong>，主要耗时是复制结果，为 O(target)。</p><h4 id="第四步：整合计算，得出最终复杂度-1"><a href="#第四步：整合计算，得出最终复杂度-1" class="headerlink" title="第四步：整合计算，得出最终复杂度"></a>第四步：整合计算，得出最终复杂度</h4><p><strong>时间复杂度：</strong></p><p>时间复杂度主要由两部分构成：</p><ol><li>遍历整个搜索树的成本。</li><li>找到解时，复制解的成本。</li></ol><p>综合来看，总的时间复杂度由<strong>搜索树的节点总数</strong>主导。</p><ul><li><strong>总节点数</strong>：如上分析，约为 O(n^(target&#x2F;min_val))。</li><li><strong>每个节点的操作</strong>：主要是 O(n) 的循环。</li></ul><p>因此，一个比较宽松的上界是 <code>节点数 * 每个节点的操作</code>，但这并不精确。更通用的做法是直接用搜索空间的大小来表示复杂度。</p><p>最终，该算法的时间复杂度被认为是 **O(n^(target&#x2F;min_val))**。这是一个比较标准的对这类问题的复杂度描述，它清晰地表达了算法性能与 <code>n</code> 和 <code>target</code> 的指数关系。</p><p><strong>空间复杂度：</strong></p><p>空间复杂度也由两部分构成：</p><ol><li><strong>递归调用栈的深度</strong>：即我们递归树的最大深度。如前所述，最大深度是 <code>D = target / min_val</code>。所以这部分的复杂度是 **O(target)**。</li><li><strong>临时状态 <code>state</code> 的空间</strong>：<code>state</code> 列表存储了当前的组合路径，其最大长度也是递归的深度，所以也是 **O(target)**。</li></ol><p>因此，<strong>不包括存储最终结果 <code>res</code> 的空间</strong>，算法的辅助空间复杂度是 **O(target)**。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对该“组合总和”问题的回溯算法复杂度分析如下：</p><ul><li><p><strong>思考顺序</strong>：</p><ol><li><strong>识别问题类型</strong>：意识到这是“组合总和”问题，元素可重复使用。</li><li><strong>构建递归树模型</strong>：确定树的宽度（分支数，<del><code>n</code>）和深度（</del><code>target</code>）。</li><li><strong>估算搜索空间</strong>：根据宽度和深度，估算出节点总数的量级为 O(n^target)。</li><li><strong>分析单点操作</strong>：找出函数内最耗时的操作，如循环（O(n)）和结果复制（O(target)）。</li><li><strong>整合复杂度</strong>：确定时间复杂度由搜索空间大小主导，即 O(n^target)。分析空间复杂度由递归深度主导，即 O(target)。</li></ol></li><li><p><strong>最终结论</strong>：</p><ul><li><strong>时间复杂度</strong>: **O(n^(target&#x2F;min_val))**。其中 <code>n</code> 是候选数字的个数，<code>target</code> 是目标和，<code>min_val</code> 是候选数字中的最小值。这个复杂度表示算法的性能在最坏情况下与 <code>n</code> 和 <code>target</code> 呈指数关系。</li><li><strong>空间复杂度</strong>: **O(target)**。这主要是由递归栈的深度和存储当前路径的临时列表所决定的（不计入存储所有结果所需的空间）。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;回溯算法复杂度分析的核心思想&quot;&gt;&lt;a href=&quot;#回溯算法复杂度分析的核心思想&quot; class=&quot;headerlink&quot; title=&quot;回溯算法复杂度分析的核心思想&quot;&gt;&lt;/a&gt;回溯算法复杂度分析的核心思想&lt;/h3&gt;&lt;p&gt;分析回溯算法的时间复杂度，本质上是在分析其递归搜索树的规模。因为回溯算法在最坏情况下会遍历整个解空间树，所以其时间复杂度通常是指数级别或阶乘级别的。  &lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="评价维度"><a href="#评价维度" class="headerlink" title="评价维度"></a>评价维度</h1><ul><li>运行效率（时间复杂度，还有常数项也尽可能小）</li><li>就地性（原地排序再原数组直接操作不必借助辅助数组，节省内存）</li><li>稳定性（排序前后相等元素相对位置不变）</li><li>自适应性（利用输入数据的信息减少计算量，达到更优）</li><li>是否基于比较（基于比较的依赖于”&gt;,&lt;,&#x3D;”,理论最优时间复杂度是(O(nlogn)；非比较排序不用比较运算符，速度快但通用性差)<br>**目前没有发现上面所有都好的算法**</li></ul><span id="more"></span><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选择排序 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">selectionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [i, n-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 内循环：找到未排序区间内的最小元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[k])</span><br><span class="line">                k = j; <span class="comment">// 记录最小元素的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将该最小元素与未排序区间的首个元素交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[k];</span><br><span class="line">        nums[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>时间复杂度O(n方)，非自适应。(n-1)到2求和</li><li>空间复杂度O(1),原地排序。</li><li>非稳定性排序<img src="/img.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img.png"></li></ul><h1 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 冒泡排序（标志优化） */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bubbleSortWithFlag</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 外循环：未排序区间为 [0, i]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 初始化标志位</span></span><br><span class="line">        <span class="comment">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 nums[j] 与 nums[j + 1]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j + <span class="number">1</span>];</span><br><span class="line">                nums[j + <span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="literal">true</span>; <span class="comment">// 记录交换元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 此轮“冒泡”未交换任何元素，直接跳出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n*n),优化后是自适应排序。(n-1)到1求和</li><li>空间复杂度O(1)，原地排序</li><li>稳定性排序</li></ul><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>类似整理扑克牌，从未排序区间选一个基准元素，把ta和左侧已排序区间逐一比较并插入到正确地方<br><img src="/img_1.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入排序 从小到大*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//外循环，已经排序的区间是[0,i-1]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt; nums.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> nums[i],j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//把base插入已排序区间的合适位置</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; nums[j] &gt; base)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">           把比base大的元素都向右移动，</span></span><br><span class="line"><span class="comment">           因为我们已经存取了索引为i的元素为base，所以不必担心覆盖</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            nums[j+<span class="number">1</span>] = nums[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束时，j索引一定是第一个不大于base的元素</span></span><br><span class="line">        <span class="comment">//原本的j+1索引的元素是第一个大于base的元素，已经向右移动了</span></span><br><span class="line">        <span class="comment">//因此直接插入在j+1即可</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n*n),自适应性。1加到(n-1)。遇到有序数组时，内循环（插入操作）会提前终止，达到最佳复杂度O(n).</li><li>空间复杂度O(1),原地排序。</li><li>稳定排序。插入时我们插入在相等元素右侧。</li></ul><p><strong>虽然复杂度是O(n*n),但数据量小时可能比快排更快</strong><br><br></p><h4 id="实践中插入排序使用频率高于冒泡和选择"><a href="#实践中插入排序使用频率高于冒泡和选择" class="headerlink" title="实践中插入排序使用频率高于冒泡和选择"></a>实践中插入排序使用频率高于冒泡和选择</h4><ul><li>冒泡： 基于元素交换，涉及3个单元操作，插入排序基于元素赋值，只需要一个单元操作</li><li>选择： 不自适应，任何时候都是O(n*n),</li></ul><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="基于分治策略核心是哨兵划分：目标是选择数组某个元素作为基准数，将所有小于基准数的元素移到左侧，大于的移到右侧。"><a href="#基于分治策略核心是哨兵划分：目标是选择数组某个元素作为基准数，将所有小于基准数的元素移到左侧，大于的移到右侧。" class="headerlink" title="基于分治策略核心是哨兵划分：目标是选择数组某个元素作为基准数，将所有小于基准数的元素移到左侧，大于的移到右侧。"></a>基于分治策略<br><br>核心是<strong>哨兵划分</strong>：目标是选择数组某个元素作为基准数，将所有小于基准数的元素移到左侧，大于的移到右侧。<br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> i,<span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*哨兵划分*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//我们以nums[left]为基准</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left , j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; nums[j] &gt;= nums[left])&#123;</span><br><span class="line">            j--;<span class="comment">//从右向左找首个小于基准数的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j &amp;&amp; nums[i] &lt;= nums[left])&#123;</span><br><span class="line">            i++;<span class="comment">//从左向右找到首个大于基准数的</span></span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终i，j一定相等，作为分界线</span></span><br><span class="line">    swap(nums,i,left);</span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><p>注意，当我们选取左侧的元素为基准时，只能先从右往左查找！<br><br> <strong>正确顺序：先从右往左查找</strong></p><p>在这种模式下，循环的逻辑是：</p><ol><li><code>j</code> 指针从右向左移动，直到找到一个小于 <code>key</code> 的数，然后停下来。</li><li><code>i</code> 指针从左向右移动，直到找到一个大于 <code>key</code> 的数，然后停下来。</li><li>交换 <code>nums[i]</code> 和 <code>nums[j]</code>。</li><li>重复以上过程，直到 <code>i</code> 和 <code>j</code> 相遇。</li></ol><p><strong>为什么这能成功？</strong><br>因为 <code>j</code> 的任务是找到一个“小数”，而 <code>i</code> 的任务是找到一个“大数”。当循环结束，<code>i</code> 和 <code>j</code> 相遇时，相遇点 <code>i</code> 的值必然是小于等于基准数 <code>key</code> 的。这有两种情况：</p><ul><li><strong>情况一</strong>：<code>j</code> 先移动，找到了一个小数停下，然后 <code>i</code> 再移动，直到与 <code>j</code> 相遇。这意味着相遇点 <code>i</code>（也就是 <code>j</code> 的位置）的元素就是 <code>j</code> 找到的那个小数，它必然小于 <code>key</code>。</li><li><strong>情况二</strong>：在某次交换后，<code>j</code> 开始向左移动，但它还没找到小数，<code>i</code> 就已经和它相遇了。这说明 <code>i</code> 和 <code>j</code> 相遇点及其右边的所有元素，都已经被 <code>j</code> 扫描过并确认是大于等于 <code>key</code> 的。而 <code>i</code> 停在当前位置，是因为它左边的元素都小于等于 <code>key</code>。因此，<code>i</code> 和 <code>j</code> 相遇的这个位置，是经过 <code>i</code> 指针扫描确认的小于等于 <code>key</code> 的区域的右边界。</li></ul><p>无论哪种情况，**只要是 <code>j</code> 指针的循环先启动，就能保证当 <code>i</code> 和 <code>j</code> 相遇时，它们所在的位置的元素是 <code>j</code> 筛选过的，必然小于等于 <code>key</code>**。这样，最后一步 <code>swap(nums[left], nums[i])</code> 就能成功地将一个较小的数换到最左边，而基准数被换到了中间的正确位置。</p><hr><p> <strong>错误顺序：先从左往右查找</strong></p><p>现在我们交换顺序，让 <code>i</code> 指针先从左往右查找。</p><ol><li><code>i</code> 指针从左向右移动，直到找到一个大于 <code>key</code> 的数，然后停下来。</li><li><code>j</code> 指针从右向左移动，直到找到一个小于 <code>key</code> 的数，然后停下来。</li><li>交换 <code>nums[i]</code> 和 <code>nums[j]</code>。</li><li>重复以上过程，直到 <code>i</code> 和 <code>j</code> 相遇。</li></ol><p><strong>为什么这会失败？</strong><br>问题就出在当 <code>i</code> 和 <code>j</code> 相遇时，相遇点的元素 <code>nums[i]</code> 可能是大于 <code>key</code> 的。</p><p>我们用你提到的例子 <code>[0, 0, 0, 0, 1]</code> 来走一遍流程：</p><ul><li><strong>基准数</strong> <code>key = nums[0] = 0</code>。<code>i</code> 从索引 0 开始，<code>j</code> 从索引 4 开始。</li></ul><ol><li>**先动 <code>i</code>**：<code>i</code> 从左向右查找大于 <code>0</code> 的数。<ul><li><code>i</code> 移动到索引 4 时，<code>nums[4]</code> 是 <code>1</code>，大于 <code>0</code>。<code>i</code> 停在 4。</li></ul></li><li>**再动 <code>j</code>**：<code>j</code> 从右向左查找小于 <code>0</code> 的数。<ul><li>此时 <code>i</code> 已经是 4，<code>j</code> 也是 4，<code>i &lt; j</code> 的条件不满足，<code>j</code> 不会移动。</li></ul></li><li><strong>循环结束</strong>：<code>while(i &lt; j)</code> 循环因为 <code>i</code> 等于 <code>j</code> 而终止。此时 <code>i</code> 和 <code>j</code> 相遇在索引 4。</li><li><strong>最后交换</strong>：执行 <code>swap(nums[left], nums[i])</code>，也就是交换 <code>nums[0]</code> 和 <code>nums[4]</code>。<ul><li>数组从 <code>[0, 0, 0, 0, 1]</code> 变成了 <code>[1, 0, 0, 0, 0]</code>。</li></ul></li></ol><p><strong>问题分析</strong>：<br>因为是 <code>i</code> 指针先移动并找到了一个“大数”（<code>1</code>）而停下，而 <code>j</code> 指针因为 <code>i</code> 已经到达了它的位置而没有机会再去寻找“小数”，导致 <code>i</code> 和 <code>j</code> 最终相遇在了一个大于基准数的位置上。最后一步交换，就把这个“大数”换到了数组的最左边，破坏了分区的正确性。[<a class="link"   href="https://www.google.com/url?sa=E&q=https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQHbdtVWJwirlBZMh2uktWns2d-8VnZNlqt7A0pvAV6waWCDjny1brKFEYM82L-seP8N9vpGtZLhF8RR6ImJ6zHiL6ZYxuFa290pBnHwH-FPe-puvS3LplIkHzv8hXkwfYBD-U5h-uYKJ7Eo9rT6jw==" >1<i class="fas fa-external-link-alt"></i></a>][<a class="link"   href="https://www.google.com/url?sa=E&q=https://vertexaisearch.cloud.google.com/grounding-api-redirect/AUZIYQGzPOXfIUWwVJROO75yk8ZkcAzQGc0yO1nAWTd-rYjZwf9RU5NmCEbySHTzUvVCTbEIMt0Jg6YRLxD4_mNdJ-hOZ_yV6PXh4adGAqEAjMcVziCXsiveFvs83ixWlM5pfUjF0TBcgCyfKb_n1MDt4g==" >2<i class="fas fa-external-link-alt"></i></a>]</p><hr><p>总之，最终达到左边子数组任意元素&lt;&#x3D;基准数&lt;&#x3D;右边子数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//基本情况，如果数组长度为1天然有序</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//基于分治策略，把一个长数组划分成两个短数组。</span></span><br><span class="line">    <span class="comment">//有两个作用：1.把pivot放在正确的顺序索引上</span></span><br><span class="line">    <span class="comment">//         2.左边子数组任意元素&lt;=基准数&lt;=右边子数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(nums,left,right);</span><br><span class="line">    <span class="comment">//分别排序pivot左右两侧的数组</span></span><br><span class="line">    quickSort(nums,left,pivot-<span class="number">1</span>);</span><br><span class="line">    quickSort(nums,pivot+<span class="number">1</span>,right);</span><br><span class="line">    <span class="comment">//最终左右两侧，pivot自己都有序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>平均时间复杂度O(nlongn)，非自适应：平均情况下递归层数为logn,每层中操作数为O(n)(主要是哨兵划分，各个子数组操作之和)。<br><br>但最差时(哨兵选取的是最大或者最小的元素时），每轮哨兵划分都分为长度为0和n-1的子数组，递归层数会达到n，复杂度达到O(n*n).</li><li>空间复杂度O(n),原地排序：递归深度最差达到n(哨兵选取的是最大或者最小元素时)。直接操作员数组，没有借助额外空间</li><li>非稳定性：partition的最后一步，把基准元素调换到分界线时可能改变和基准元素相等的元素的相对位置</li></ul><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="基准数选取优化"><a href="#基准数选取优化" class="headerlink" title="基准数选取优化"></a>基准数选取优化</h3><p>下面是一种方法，选取首、尾、中点的中位数。<br><br><br>我们要把选取的基准数调换到最左侧，这样可以直接复用代码，直接仿照上面的哨兵划分即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 选取三个候选元素的中位数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">medianThree</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> nums[left], m = nums[mid], r = nums[right];</span><br><span class="line">    <span class="keyword">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))</span><br><span class="line">        <span class="keyword">return</span> mid; <span class="comment">// m 在 l 和 r 之间</span></span><br><span class="line">    <span class="keyword">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))</span><br><span class="line">        <span class="keyword">return</span> left; <span class="comment">// l 在 m 和 r 之间</span></span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 哨兵划分（三数取中值） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// 选取三个候选元素的中位数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">med</span> <span class="operator">=</span> medianThree(nums, left, (left + right) / <span class="number">2</span>, right);</span><br><span class="line">    <span class="comment">// 将中位数交换至数组最左端，之后就可以直接复用上面的代码了</span></span><br><span class="line">    swap(nums, left, med);</span><br><span class="line">    <span class="comment">// 以 nums[left] 为基准数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left, j = right;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])</span><br><span class="line">            j--;          <span class="comment">// 从右向左找首个小于基准数的元素</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])</span><br><span class="line">            i++;          <span class="comment">// 从左向右找首个大于基准数的元素</span></span><br><span class="line">        swap(nums, i, j); <span class="comment">// 交换这两个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, left);  <span class="comment">// 将基准数交换至两子数组的分界线</span></span><br><span class="line">    <span class="keyword">return</span> i;             <span class="comment">// 返回基准数的索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="递归深度优化"><a href="#递归深度优化" class="headerlink" title="递归深度优化"></a>递归深度优化</h3><p>最差空间复杂度优化为O(logn):即便在基准数选取最大或者最小值时也保证O(logn)<br><br><br>我们可以只对划分出来的短子数组进行递归，长子数组利用迭代在下次循环处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> [] nums , <span class="type">int</span> left ,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;<span class="comment">//基本情况隐含了，子数组长度小于等于直接返回</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> parition(nums,left,right);</span><br><span class="line">        <span class="keyword">if</span>(pivot - left &lt; right - pivot)&#123;</span><br><span class="line">            quickSort(nums,left,pivot-<span class="number">1</span>);</span><br><span class="line">            left = pivot + <span class="number">1</span>;<span class="comment">//左子数组被排序过了，这是新的未排序的左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            quickSort(nums,pivot + <span class="number">1</span>,right);</span><br><span class="line">            right = pivot - <span class="number">1</span>;<span class="comment">//右子数组被排序过了，这是新的未排序的右边界</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于每次较短的子数组必定小于等于n&#x2F;2,因此这种方法递归深度必然不超过O(logn)<br><br><br>最差空间复杂度优化为O(logn)</p><h3 id="分区优化"><a href="#分区优化" class="headerlink" title="分区优化"></a>分区优化</h3><p>当数组中所有元素都相等时，快速排序的时间复杂度是O(n^n)<br><br><br>对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>也基于分治策略，<br><br></p><ol><li>划分阶段：用递归将数组从中点处分开</li><li>合并阶段：数组长度为1时停止开始合并<br><img src="/img_2.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_2.png"><br>归并排序的顺序和二叉树的后序遍历类似。</li></ol><ul><li>后序遍历：先递归左子树，再递归右子树，最后处理根节点</li><li>归并排序：先递归左子树组，再递归右子树组，最后处理合并<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">merge</span> <span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//左子数组区间时[left,mid],右子树组是[mid+1,right]</span></span><br><span class="line">    <span class="comment">//temp存放合并后的结果</span></span><br><span class="line">    <span class="type">int</span> [] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left +<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left,j = mid+<span class="number">1</span>,k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当左右数组都有元素时，进行比较并把较小的元素复制到数组中</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt;= nums[j])</span><br><span class="line">        &#123;</span><br><span class="line">            temp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当任意一个数组元素被遍历完后，把剩余元素复制到临时数组</span></span><br><span class="line">    <span class="keyword">while</span> (i&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++] = nums[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[k++] = nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将temp复制回原数组对应区间</span></span><br><span class="line">    <span class="keyword">for</span>(k = <span class="number">0</span>;k&lt; temp.length;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[left + k] = temp[k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*归并排序*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//基本情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//相信mergeSort能处理更小规模的</span></span><br><span class="line">    <span class="comment">//先对左侧归并排序</span></span><br><span class="line">    mergeSort(nums,left,mid);</span><br><span class="line">    <span class="comment">//堆右侧归并排序</span></span><br><span class="line">    mergeSort(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="comment">//最后把左右子数组进行合并</span></span><br><span class="line">    merge(nums,left,mid,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度O(nlogn)、非自适应。递归高度logn,每层一共的合并操作都是n</li><li>空间复杂度O(n)、非原地排序。递归调用栈O(logn),合并操作的辅助数组O(n).</li><li>稳定排序（我们先处理了左侧的子数组）</li></ul><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>一个简单的方法是输入数组建立小顶堆，之后不断执行出堆操作，一次记录出堆元素<br><br><br>但这样空间复杂度高，我们可以优化成原地排序<br><br></p><ol><li>输入数组建立大顶堆。完成后最大元素位于堆顶</li><li>把堆顶元素（首个）和堆底元素（最后一个元素）交换。交换后堆的长度减去1，已排序元素加一</li><li>从堆顶开始执行从顶到底堆化。</li><li>重复2、3。循环n-1轮即可排序成功</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">siftDown</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> n,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span>*i +<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ma</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; n &amp;&amp; nums[l] &gt; nums[ma])</span><br><span class="line">        &#123;</span><br><span class="line">            ma = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; n &amp;&amp; nums[r] &gt; nums[ma])</span><br><span class="line">        &#123;</span><br><span class="line">            ma = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ma == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        nums[i] = nums[ma];</span><br><span class="line">        nums[ma] = temp;</span><br><span class="line">        i = ma;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，自顶向下堆化要求除了要处理的当前节点及其子节点外，剩余部分的子树都满足堆的性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*堆排序*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="comment">//建堆</span></span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length/<span class="number">2</span> - <span class="number">1</span> ;i&gt;= <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        siftDown(nums,nums.length,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//从堆中提取最大元素，循环n-1轮</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        siftDown(nums,i,<span class="number">0</span>);<span class="comment">//i是索引中最后的元素，本来就是数组长度-1，因此首次循环无需先减去1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(nlogn)、非自适应排序<br><br>log(n-1) + log(n-2) + …… + log2,我们在之后证明这个求和的渐进上限就是O(nlogn)</li><li>空间复杂度O(1)、原地排序</li><li>非稳定性排序：交换堆顶和堆底时，相等元素相对位置可能变化</li></ul><p>下面我们来证明log(n-1) + ……+log2的渐进上限是O(logn)</p><ol><li>显然和s&lt;&#x3D;nlogn</li><li>之后我们把s分两半，log(2)到log(n&#x2F;2),和log(n&#x2F;2+1)到log(n-1)，后一半是nlogn,因此s&gt;&#x3D;nlogn</li></ol><h2 id="实际上快速排序一般更快"><a href="#实际上快速排序一般更快" class="headerlink" title="实际上快速排序一般更快"></a>实际上快速排序一般更快</h2><ol><li>出现最坏情况的概率很低<br>快速排序的最坏情况时间复杂度是 O(n²)，这种情况发生在每次选择的基准值（pivot）都是当前数组中的最大或最小值时，例如对一个已经排好序的数组进行排序。<br>然而，这种情况在实际应用中非常罕见。通过随机选取基准值或使用“三数取中”等方法，可以极大地避免最坏情况的发生。在绝大多数情况下，快速排序都能在 O(n log n) 的时间复杂度下高效运行。</li><li>缓存使用效率高<br>现代计算机的内存结构是分级的（CPU -&gt; Cache -&gt; Memory）。CPU访问缓存的速度远快于访问主内存。<br>快速排序在分区（partition）操作时，是对一个连续的数组块进行操作。这使得数据可以被加载到高速缓存中，从而提高访问效率。 这种访问模式被称为“局部性原理”（principle of locality）。<br>相比之下，像堆排序这样的算法需要跳跃式地访问元素（例如，访问父节点和子节点，它们在内存中可能相距很远），这降低了缓存的命中率，从而导致实际运行时间变慢。</li><li>复杂度的常数系数小<br>算法的时间复杂度（如 O(n log n)）描述的是随着数据规模 (n) 增长的趋势，但忽略了常数项。在实际计算中，这个常数项代表了完成基本操作（如比较、交换）所需的具体时间。<br>在上述三种算法中，快速排序完成一次内循环所需要的比较、赋值、交换等操作的总数量是最少的。 这意味着在相同的 n log n 级别下，快速排序的实际执行时间更短。这与“插入排序”比“冒泡排序”更快的原因类似，尽管它们的复杂度在最坏情况下都是O(n²)，但插入排序的内部操作更少。</li></ol><h1 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h1><p>采取分治策略<br><br><br>设置一些具有一定大小顺序的桶，每个桶对应一个数据范围，把数据平均分配到各个桶中，之后在每个桶内部排序，最后按照桶的顺序把所有数据合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">float</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化k = n/2，预期向每个桶分配2个元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> nums.length / <span class="number">2</span>;</span><br><span class="line">    List&lt;List&lt;Float&gt;&gt; buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        buckets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把元素平均分配到各个桶</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> num : nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) (num * i);</span><br><span class="line">        buckets.get(i).add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对每个桶排序</span></span><br><span class="line">    <span class="keyword">for</span> (List&lt;Float&gt; bucket : buckets) &#123;</span><br><span class="line">        Collection.sort(bucket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(List&lt;Float&gt;bucket : buckets)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">float</span> num : bucket)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n + k):在平均分布的情况下，排序单个桶O((n&#x2F;k) *log(n&#x2F;k)),k个桶就是O(nlog(n&#x2F;k)),当k很大，趋近于O(n)。合并结果时，每轮循环操作数O(1+n&#x2F;k),一共k轮循环花费O(n+k)。但最差情况下所有数据分配到一个桶，复杂度可能是O(nlogn)</li><li>空间复杂度：O(n + k),非原地排序</li><li>稳定性取决于排序每个桶内的算法是否稳定<br>**桶排序重要的是要尽可能使元素平均分布**</li></ul><h1 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h1><p>假定数组都是非负整数<br><img src="/img_3.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_3.png"><br>先找到原数组最大数字m,创建长度m+1辅助数组counter,借助counter统计nums各个数字出现次数，由于counter索引天然有序，之后遍历counter把数字填入nums</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意这个实现不能排序对象</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">countingSortNative</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//统计最大元素m</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        m = Math.max(m , nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计各个数字出现次数</span></span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历counter，把元素填入原数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;num &lt; m+<span class="number">1</span>;num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; counter[num];j++,i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将计数排序中的计数数组 counter 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。<br><br><br>但是上述实现无法对对象排序。如果强行对对象排序，会只得到排序所依据的属性的顺序<br><br><br>我们可以计算前缀和来完整实现。<br><br><br>前缀和就是小于等于i的元素之和，我们用prefix数组记录<br><br><br>于是prefix[i] - 1就是最右侧元素应该在的索引<br><br><br>最后倒序遍历原数组nums,依据每个元素对应的prefix放到res对应的位置，之后让prefix减一，最后把res复制到原数字即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        m = Math.max(m,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[num]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[i+<span class="number">1</span>] += counter[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒序遍历并且填入res</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>;i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        res[counter[num] - <span class="number">1</span>] = num;</span><br><span class="line">        counter[num]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n + m),非自适应：m是最大的数</li><li>空间复杂度O(n+m),非原地排序</li><li>稳定排序<br>计数排序只适用于非负整数（其他的可以转换），适用于数据量大但是范围小的情况</li></ul><h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><p>位数从低到高，分别以每位为键进行计数排序。<br><br></p><ul><li><strong>低位排序是为高位排序服务的</strong>：当我们按十位排序时，所有十位相同的数字，它们的相对顺序实际上是由个位决定的，而个位在第一步已经排好了。</li><li><strong>稳定性是秩序的“守护者”</strong>：稳定性保证了低位排序的成果不会被高位排序破坏掉。它确保了当高位相同时，低位已经建立的秩序得以保留。</li><li><strong>层层递进的秩序</strong>：当排到第 <code>k</code> 位时，所有数字的后 <code>k</code> 位其实都已经是有序的了。当最后排完最高位时，整个数字自然就是完全有序的。<br><img src="/img_4.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_4.png"><br>可用下图公式获取d进制数字的第k位<br><img src="/img_5.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_5.png"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取元素第k位，其中exp = 10^(k-1)*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">digit</span> <span class="params">(<span class="type">int</span> num , <span class="type">int</span> exp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//传入exp避免重复次方运算</span></span><br><span class="line">    <span class="keyword">return</span> (num/exp) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计数排序，根据nums第k位排序*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">countingSortDigit</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> exp)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] counter = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">//统计0~9出现个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> digit(nums[i],exp);</span><br><span class="line">        counter[d]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        counter[i] += counter[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//倒序遍历</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span> [n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n -<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> digit(nums[i],exp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> counter[d] - <span class="number">1</span>;</span><br><span class="line">        res[j] = nums[i];</span><br><span class="line">        counter[d]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nums[i] = res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基数排序*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            m = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">exp</span> <span class="operator">=</span> <span class="number">1</span>;exp &lt;= m ;exp *= <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        countingSortDigit(nums,exp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度：O(nk),非自适应：对某一位排序是O(n+d),排序所有k位是O((n+d)k),一般n &gt;&gt; d,可以近似为O(nk).一般情况下，n,k都是小常数，复杂度可以为O(n).</li><li>空间复杂度：O(n + d),要借助res和counter数组</li><li>稳定排序：计数排序稳定基数就稳定</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/img_6.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E6%8E%92%E5%BA%8F/img_6.png"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;评价维度&quot;&gt;&lt;a href=&quot;#评价维度&quot; class=&quot;headerlink&quot; title=&quot;评价维度&quot;&gt;&lt;/a&gt;评价维度&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;运行效率（时间复杂度，还有常数项也尽可能小）&lt;/li&gt;
&lt;li&gt;就地性（原地排序再原数组直接操作不必借助辅助数组，节省内存）&lt;/li&gt;
&lt;li&gt;稳定性（排序前后相等元素相对位置不变）&lt;/li&gt;
&lt;li&gt;自适应性（利用输入数据的信息减少计算量，达到更优）&lt;/li&gt;
&lt;li&gt;是否基于比较（基于比较的依赖于”&amp;gt;,&amp;lt;,&amp;#x3D;”,理论最优时间复杂度是(O(nlogn)；非比较排序不用比较运算符，速度快但通用性差)&lt;br&gt;
**目前没有发现上面所有都好的算法**&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本质是穷举，核心思想是从一个初始状态除法，暴力搜索所有可能的解决方案，遇到正确的解记录，直到找到解或者尝试所有可能无法找到解<br>经常使用深度优先搜索  </p><span id="more"></span><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>见<a href="%E5%9B%9E%E6%BA%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">回溯复杂度分析.md</a></p><h2 id="尝试与回退"><a href="#尝试与回退" class="headerlink" title="尝试与回退"></a>尝试与回退</h2><p>经常使用这两个策略，遇到某个状态无法前进就撤销上一步选择<br>例如，<code>给定一棵二叉树，搜索并记录所有值为7的节点，请返回节点列表。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历：例题一 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root.val == <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        res.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问每个节点都表示尝试，越过叶节点return表示回退<br>但回退不仅仅包括函数返回<br>例，<code>在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径。</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 前序遍历：例题二 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试</span></span><br><span class="line">    path.add(root); <span class="comment">//path 需要在外部定义</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录解</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">    <span class="comment">//回退，到最后遍历了root以及他的所有子节点也没找到，需要把root从path去掉</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们信仰之越的契约是：相信preOrder能处理更小规模的子树，遍历子树的root以及所有节点，并把路径添加到res，让后穷举完所有结果后回退，把path回退到之前</p><h2 id="剪枝"><a href="#剪枝" class="headerlink" title="剪枝"></a>剪枝</h2><p>如果有约束条件可以尝试剪枝<br>例，<code>在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3 的节点。</code><br>我们需要添加剪枝操作，遇到值为3的节点则提前返回不再继续找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试</span></span><br><span class="line">    path.add(root);</span><br><span class="line">    <span class="keyword">if</span> (root.val == <span class="number">7</span>) &#123;</span><br><span class="line">        <span class="comment">//记录解</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//继续尝试左右边</span></span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">    <span class="comment">//回退</span></span><br><span class="line">    path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/img_12.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%9B%9E%E6%BA%AF/img_12.png"></p><h2 id="框架代码"><a href="#框架代码" class="headerlink" title="框架代码"></a>框架代码</h2><p>尝试-&gt;回退-&gt;剪枝<br>state表示当前问题状态，choices表示当前状态下可做的选择</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.plaf.nimbus.State;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(State state, List&lt;Choices&gt; choices, List&lt;State&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSolution(state)) &#123;</span><br><span class="line">        recordSolution(state, res);</span><br><span class="line">        <span class="comment">//如果找到一个解就可以结束则返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (Choice choice : choices)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断是否需要剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(isValid(state,choice))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尝试：做出选择，更新状态</span></span><br><span class="line">            makeChoice(state,choice);</span><br><span class="line">            <span class="comment">//继续深入尝试</span></span><br><span class="line">            backtrack(state,choices,res);</span><br><span class="line">            <span class="comment">//回退：撤销选择</span></span><br><span class="line">            undoChoice(state,choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助框架代码解决例题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.swing.tree.TreeNode;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isSolution</span><span class="params">(List&lt;TreeNode&gt; state)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !state.isEmpty() &amp;&amp; state.get(state.size() - <span class="number">1</span>).val == <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recordSolution</span><span class="params">(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res)</span> &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(List&lt;TreeNode&gt; state, TreeNode choice)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> choice != <span class="literal">null</span> &amp;&amp; choice.val != <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">makeChoice</span><span class="params">(List&lt;TreeNode&gt; state, TreeNode choice)</span> &#123;</span><br><span class="line">    state.add(choice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">undoChoice</span><span class="params">(List&lt;TreeNode&gt; state, TreeNode choice)</span> &#123;</span><br><span class="line">    state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSolution(state)) &#123;</span><br><span class="line">        recordSolution(state, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (TreeNode choice : choices) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isValid(state, choice)) &#123;</span><br><span class="line">            makeChoice(state, choice);</span><br><span class="line">            backtrack(state, Arrays.asList(choice.left,choice.right),res);</span><br><span class="line">            undoChoice(state,choice);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="优点与局限"><a href="#优点与局限" class="headerlink" title="优点与局限"></a>优点与局限</h2><p>本质是深度优先搜索，剪枝可以降低复杂度  </p><p>复杂度： </p><ul><li>时间：遍历所有可能性，复杂度可能指数阶</li><li>要保持当前状态（例如路径，剪枝的辅助变量）</li></ul><p>优化方式：  </p><ul><li>剪枝</li><li>启发式搜索：引入策略或者估计值，优先搜索最有可能产生解的路径</li></ul><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="全排列问题"><a href="#全排列问题" class="headerlink" title="全排列问题"></a>全排列问题</h2><p><code>输入一个整数数组，其中可能包含重复元素，返回所有可能的排列。</code>   </p><ul><li><p><strong>分析</strong>  </p><ul><li>可以使用回溯，把生成排列成一系列选择的结果。  <ul><li><p>choices 就是输入数组所有元素</p></li><li><p>state 就是已经被选择的所有元素，并且唯一（当然值可能重复，但是选取的元素唯一）</p></li><li><p>剪枝  </p><ul><li>重复选择剪枝：确保每个元素只被选择一次，引入selected，selected[i]表示choices[i]是否被选择</li><li>相等元素剪枝：<img src="/img_13.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%9B%9E%E6%BA%AF/img_13.png"> 可以引入一个哈希集合duplicated，标记尝试过的元素</li></ul><br> <hr><p><img src="/img_14.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%9B%9E%E6%BA%AF/img_14.png"> 两种剪枝的不同</p></li></ul></li></ul></li><li><p><strong>实现</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span>[] choices, <span class="type">boolean</span>[] selected, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 当状态长度等于元素数量时记录,就是框架代码的issolution</span></span><br><span class="line">    <span class="keyword">if</span> (state.size() == choices.length) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="comment">//需要 返回，不可能继续下去探索了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    Set&lt;Integer&gt; duplicated = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length;i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">choice</span> <span class="operator">=</span> choices[i];</span><br><span class="line">        <span class="comment">//剪枝：不允许重复选择元素 且 不允许选择相等元素</span></span><br><span class="line">        <span class="comment">//就是isValid</span></span><br><span class="line">        <span class="keyword">if</span> (!selected[i] &amp;&amp; !duplicated.contains(choice))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尝试做出选择，相当于makeChoice</span></span><br><span class="line">            duplicated.add(choice); <span class="comment">// 记录已经选择过的元素的值</span></span><br><span class="line">            selected[i] = <span class="literal">true</span>; <span class="comment">//记录被选择过的元素本身（记录索引i就行其实）</span></span><br><span class="line">            state.add(choice);</span><br><span class="line">            <span class="comment">//进行下一轮选择</span></span><br><span class="line">            backtrack(state,choices,selected,res);</span><br><span class="line">            <span class="comment">//回退，相当于undoChoice</span></span><br><span class="line">            selected[i] = <span class="literal">false</span>;</span><br><span class="line">            state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permutations</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(),nums,<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length],res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>复杂度：详见<a href="%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">全排列问题复杂度分析.md</a><ul><li>时间复杂度：O(n * n!)</li><li>空间复杂度: O(n^2)</li></ul></li></ul><h2 id="子集和问题"><a href="#子集和问题" class="headerlink" title="子集和问题"></a>子集和问题</h2><h3 id="无重复情况"><a href="#无重复情况" class="headerlink" title="无重复情况"></a>无重复情况</h3><p>给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合。</p><hr><p><strong>分析</strong></p><ol><li><p>可以直接参考全排列问题。但集合元素可以无限次选取，因此不必借助selected</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回溯算法：子集和 I */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span> total, <span class="type">int</span>[] choices, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">// 子集和等于 target 时，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (total == target) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历所有选择</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 剪枝：若子集和超过 target ，则跳过该选择</span></span><br><span class="line">        <span class="keyword">if</span> (total + choices[i] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，更新元素和 total</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">// 进行下一轮选择</span></span><br><span class="line">        backtrack(state, target, total + choices[i], choices, res);</span><br><span class="line">        <span class="comment">// 回退：撤销选择，恢复到之前的状态</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 求解子集和 I（包含重复子集） */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumINaive</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 状态（子集）</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 子集和</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 结果列表（子集列表）</span></span><br><span class="line">    backtrack(state, target, total, nums, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 但这样比如输入[3,4,5]和目标9，会输出[3,3,3] [4,5] [5,4],因为搜索过程的全排列是区分顺序的，但实际上的子集合是不区分顺序的，如图<img src="/img_15.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E5%9B%9E%E6%BA%AF/img_15.png"></p></li><li><p>于是考虑剪枝  </p><ol><li>当第一轮选择[3,4]时会生成如[3,4……]这样的所有子集，</li><li>之后第一轮选择4，第二轮如果选择3,就产生[4,3……],显然重复了，应当剪去</li></ol><p> 因为每一次都是从左向右尝试，因此越靠右侧剪掉的越多<br><strong>总之，只要让每次选择的元素索引$i_n,满足i_1&lt;&#x3D;i_2&lt;&#x3D;……&lt;&#x3D;i_n$,即可保证不重复，不满足的应当剪枝</strong></p></li><li><p>除此之外，还进行两个优化</p><ol><li>开启搜索前可以先把nums排序，这样遍历所有选择时，只要子集和超过target直接结束循环。因为后面元素更大，子集和一定超过target</li><li>省去total，直接通过对target进行减法，total为0记录解<br><strong>实现</strong></li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, in[] choices, <span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">//子集和等于target时记录解</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    <span class="comment">//剪枝：从start开始遍历，防止生成重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; choices.length; i++) &#123;</span><br><span class="line">        <span class="comment">//剪枝：如果子集和超过target，直接结束循环</span></span><br><span class="line">        <span class="comment">//因为数组已经排序，小的尝试已经超过，后面大的没必要继续尝试</span></span><br><span class="line">        <span class="keyword">if</span> (target - choices[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试：做出选择，相当于makeChoice</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        <span class="comment">//继续探索,契约是相信backtrack能处理更小规模的问题，同时已经剪枝，在探索完后回退</span></span><br><span class="line">        backtrack(state, target - choices[i], choices, i, res);</span><br><span class="line">        <span class="comment">//回退</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumI</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(state,target,nums,start,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度： O(n^(target&#x2F;min))，详见<a href="%E5%9B%9E%E6%BA%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90.md">回溯复杂度分析.md</a>，实际上就是递归树的节点总数 * 每个节点的操作数</li><li>空间复杂度: O(target)</li></ul><h3 id="考虑重复元素"><a href="#考虑重复元素" class="headerlink" title="考虑重复元素"></a>考虑重复元素</h3><p><code>给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合。</code></p><ol><li>显然我们要进行向相等元素剪枝。<code>由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素。</code></li><li>每个元素只能选一次，也可以用start约束：选择$x_i后，下一轮直接从i+1开始遍历就行$</li></ol><p><strong>实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;Integer&gt; state, <span class="type">int</span> target, <span class="type">int</span>[] choices, <span class="type">int</span> start, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">    <span class="comment">//isSolution</span></span><br><span class="line">    <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(state));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有选择</span></span><br><span class="line">    <span class="comment">//剪枝二：从start开始，避免重复子集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i &lt; choices.length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//剪枝1：子集和查过target，则直接结束</span></span><br><span class="line">        <span class="keyword">if</span>(target - choices[i] &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝四：如果元素和左边的相等，说明选取了想等元素跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; choices[i] == choices[i-<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//做出选择</span></span><br><span class="line">        state.add(choices[i]);</span><br><span class="line">        backtrack(state,target - choices[i],choices,i+<span class="number">1</span>,res); <span class="comment">// i+1相当于剪枝三：避免选择重复元素</span></span><br><span class="line">        <span class="comment">//回退</span></span><br><span class="line">        state.remove(state.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetSumII</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    List&lt;Integer&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Array.sort(nums);</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    backtrack(state,target,nums,start,res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综合：</p><p>时间复杂度（含输出）：O(n log n + 2^n + mL)。给出统一最坏上界可写成 O(n · 2^n)。<br>辅助空间复杂度（不含结果集）：递归深度和当前路径 O(n)。若计入结果集，需再加 O(mL)。</p><ul><li>时间复杂度： 递归树最大深度是n，每层的选择是从n递减，但是每个路径深度不一定是n，可能提前结束。应该考虑每个元素都有两种可能，选择或者不选择，一共有$2^n$数量级个节点，每次遍历的操作量可以认为是O(1)(递归调用不算)，一共遍历了O(2^n)(因为要找到遍历所有可能所有节点)，复制解的操作，每次复制一个解的操作最差是O(n),最坏情况下可能几乎每个路径都有解，O(n<em>2^n),因此最终就是O(n</em>2^n) <ul><li>排序成本：Arrays.sort(nums) 是 O(n log n)。</li><li>遍历成本（不算拷贝解）：回溯树中每个元素至多“选&#x2F;不选”，最坏节点数 O(2^n)。重复剪枝只降低常数，不改变指数级上界。所以遍历是 O(2^n)。</li><li>输出成本（拷贝解）：每找到一个解要拷贝 O(L)（L 为解的长度，L ≤ n）。设解的个数为 m，则拷贝总成本 O(mL)。最坏情况下 m 可达 O(2^n)，于是 O(mL) ≤ O(n · 2^n)。</li><li>因此总成本O(n*2^n)</li></ul></li><li>空间复杂度：调用栈O(N) + state O(n)最终就是O(N)</li></ul><h2 id="n皇后问题"><a href="#n皇后问题" class="headerlink" title="n皇后问题"></a>n皇后问题</h2><p>根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n 个皇后和一个 n*n大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案。     </p><ol><li>n*n 的棋盘有n^2个格子，就是choices。逐个放置皇后时每个每个时刻棋盘就是state</li><li>考虑逐行放置：由于皇后数量和棋盘行数都是n，因此棋盘每行只允许放一个皇后。<br>实际上也起到了剪枝的效果，避免同一行有多个皇后的所有搜索分支</li><li>列和对角线剪枝  <ul><li>列：利用一个长度为n的布尔型数组cols记录每一列是否有皇后</li><li>对角线，主对角线索引row - col为恒定值；次对角线row + col为恒定值。可以构造两个分别以行列和差的布尔数组代表每个对角线是否有皇后，长度2n-1</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res, <span class="type">boolean</span>[] cols, <span class="type">boolean</span>[] diags1, <span class="type">boolean</span>[] diags2)</span> &#123;</span><br><span class="line">    <span class="comment">//isSolution,所有行放置完，记录解</span></span><br><span class="line">    <span class="keyword">if</span> (row == n) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; copyState = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; sRow : state)</span><br><span class="line">        &#123;</span><br><span class="line">            copyState.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(sRow));</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(copyState);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历所有的列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>;col &lt; n;col++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//计算格子对应的主对角线和次对角线</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diag1</span> <span class="operator">=</span> row - col + n -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diag2</span> <span class="operator">=</span> row + col;</span><br><span class="line">        <span class="comment">//剪枝：不允许列、对角线存在皇后</span></span><br><span class="line">        <span class="keyword">if</span>( !col[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//尝试:makechoice</span></span><br><span class="line">            state.get(row).set(col,<span class="string">&quot;Q&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//继续放置</span></span><br><span class="line">            backtrack(row + <span class="number">1</span>,n,state,res,cols,diags1,diags1);</span><br><span class="line">            <span class="comment">//回退</span></span><br><span class="line">            state.get(row).set(col,<span class="string">&quot;#&quot;</span>);</span><br><span class="line">            cols[col] = diags1[diag1] = diags2[diag2] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;List&lt;List&lt;String&gt;&gt;&gt; <span class="title function_">nQueens</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; state = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;String&gt; row = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            row.add(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        state.add(row);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span>[] cols = <span class="keyword">new</span> <span class="title class_">boolean</span>[n]; <span class="comment">//记录列是否有皇后</span></span><br><span class="line">    <span class="type">boolean</span>[] diags1 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    <span class="type">boolean</span>[] diags2 = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">    backtrack(<span class="number">0</span>,n,state,res,cols,diags1,diags2);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：从第一行到最后一行依次有n,n-1……1个选择，递归树也就一共O(n!)个路径（或者说叶子节点）,复制添加操作O(n^2)，因此最终复杂度是O(n! +s* n^2)(s是解的数目)</li><li>空间复杂度：<ul><li>递归深度 O(n)；三组布尔数组 O(n) 与 O(2n-1)。</li><li>棋盘状态 state 为 n×n，O(n^2)。</li><li>结果集存储占用 O(S·n^2)（按当前拷贝方式）。</li><li>综合（不计输出）：O(n^2)；计入输出：O(n^2 + S·n^2)。</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;本质是穷举，核心思想是从一个初始状态除法，暴力搜索所有可能的解决方案，遇到正确的解记录，直到找到解或者尝试所有可能无法找到解&lt;br&gt;经常使用深度优先搜索  &lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>搜索</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="暴力搜索"><a href="#暴力搜索" class="headerlink" title="暴力搜索"></a>暴力搜索</h1><ul><li>线性搜索：常用于数组链表等线性结构</li><li>广度优先和深度优先：用于图树<br>**优点是通用简单，无需预处理数据，也不需要额外的数据结构**<br>时间复杂度O(N)</li></ul><span id="more"></span><h1 id="自适应搜索"><a href="#自适应搜索" class="headerlink" title="自适应搜索"></a>自适应搜索</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>用于数组，需要有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找（双闭区间） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) <span class="comment">// 此情况说明 target 在区间 [m+1, j] 中</span></span><br><span class="line">            i = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) <span class="comment">// 此情况说明 target 在区间 [i, m-1] 中</span></span><br><span class="line">            j = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// 找到目标元素，返回其索引</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 未找到目标元素，返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>中点选取一般使用i+(j-i)&#x2F;2得到向下取整的(i+j)&#x2F;2,防止整数溢出</strong><br><br></p><h3 id="还可以用于处理查找插入位置的问题"><a href="#还可以用于处理查找插入位置的问题" class="headerlink" title="还可以用于处理查找插入位置的问题"></a>还可以用于处理查找插入位置的问题</h3><br>给定一个长度为n的有序数组 nums 和一个元素 target ，数组可能存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。若数组中已存在元素 target ，则插入到其左方。请返回插入后 target 在数组中的索引。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找插入点（存在重复元素） */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchInsertion</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>; <span class="comment">// 初始化双闭区间 [0, n-1]</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i + (j - i) / <span class="number">2</span>; <span class="comment">// 计算中点索引 m</span></span><br><span class="line">        <span class="keyword">if</span> (nums[m] &lt; target) &#123;</span><br><span class="line">            i = m + <span class="number">1</span>; <span class="comment">// target 在区间 [m+1, j] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &gt; target) &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// target 在区间 [i, m-1] 中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j = m - <span class="number">1</span>; <span class="comment">// 首个小于 target 的元素在区间 [i, m-1] 中</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回插入点 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i,j是循环不变量。<br><br><br>i始终保持[0,i-1]处的元素小于target<br><br><br>j始终保持[j+1,length-1]处的元素大于等于target<br><br><br>因此最终当j&gt;i时循环停止，i指向首个大于或者等于target的元素，也就是插入的位置</p><h3 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h3><p>实际上和上面查找插入点类似，只是需要额外在不包含target时返回-1<br><br><br>如果不包含target有两种结果</p><ul><li>i越界等于length</li><li>nums[1] !&#x3D; target<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二分查找最左一个 target */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">binarySearchLeftEdge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 等价于查找 target 的插入点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> binary_search_insertion.binarySearchInsertion(nums, target);</span><br><span class="line">    <span class="comment">// 未找到 target ，返回 -1</span></span><br><span class="line">    <span class="keyword">if</span> (i == nums.length || nums[i] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到 target ，返回索引 i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h3><ol><li><p>通用解法还是去替换nums[m] &#x3D;&#x3D; target情况下的指针操作</p><br>此时把i = m+1<br>这样，<br>循环不变量i保持[0,i-1]的元素始终小于等于target<br>j始终保持[j+1,length-1]元素大于target<br>因此最终j指向从右侧起的第一个小于等于target的元素，如果恰好target存在，那么j即为右边界</li><li><p>取巧方法（至少保证<strong>数据离散</strong>，下面默认数组只有<strong>整数</strong>）</p></li></ol><ul><li>把查找最右边的target转化为查找最左边的target+1<br><br>这样的话i - 1就是有边界，如果target存在的话</li><li>查找最左边的 等价于 查找target-0.5,并返回i（i是第一个大于大于target-0.5的元素就是第一个target）<br>查找最右边的 等价于 查找target+0.5，并返回j（j是从右边开始第一个小于等于target+0.5的，也就是最右边的target）</li></ul><h3 id="使用哈希表优化"><a href="#使用哈希表优化" class="headerlink" title="使用哈希表优化"></a>使用哈希表优化</h3><p>两数之和问题<br><br><br>给定一个整数数组 nums 和一个目标元素 target ，请在数组中搜索“和”为 target 的两个元素，并返回它们的数组索引。保证只有唯一一组解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法一：暴力枚举 */</span></span><br><span class="line"><span class="type">int</span>[] twoSumBruteForce(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 两层循环，时间复杂度为 O(n^2)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; size; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面暴力枚举，下面使用哈希表优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 方法二：辅助哈希表 */</span></span><br><span class="line"><span class="type">int</span>[] twoSumHashTable(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 辅助哈希表，空间复杂度为 O(n)</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 单层循环，时间复杂度为 O(n)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dic.containsKey(target - nums[i])) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; dic.get(target - nums[i]), i &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        dic.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把元素的值作为key，索引作为value。</p><h2 id="哈希查找："><a href="#哈希查找：" class="headerlink" title="哈希查找："></a>哈希查找：</h2><p>把搜索数据和目标数据建立为键值对映射</p><h2 id="树查找："><a href="#树查找：" class="headerlink" title="树查找："></a>树查找：</h2><p>对于指定的树搜索（比如二叉搜索树）</p><p>复杂度总结</p><table><thead><tr><th align="center"></th><th align="center">线性搜索</th><th align="center">二分查找</th><th align="center">树查找（很多时候指的是二叉搜索树）</th><th align="center">哈希查找</th></tr></thead><tbody><tr><td align="center">查找元素</td><td align="center">O(n)</td><td align="center">O(logn)</td><td align="center">O(logn)</td><td align="center">O(1)</td></tr><tr><td align="center">插入</td><td align="center">O(1),（实际上指的给数组链表插入，因为线性搜索不要求顺序因此可以直接插在动态数组末尾或者链表首部）</td><td align="center">O(n)，（有序，只能插入特定的位置）</td><td align="center">O（logn)</td><td align="center">O(1)</td></tr><tr><td align="center">删除特定元素</td><td align="center">O(n)（不管数组还是链表，都要先遍历到特定元素消耗一个O(n)）</td><td align="center">O(n)(注意链表一般不用二分搜索，因为无法以O(1)找到中点)</td><td align="center">O(logn)</td><td align="center">O(1)</td></tr><tr><td align="center">额外空间</td><td align="center">O(1)</td><td align="center">O(1)</td><td align="center">O(n)</td><td align="center">O(n)</td></tr><tr><td align="center">数据预处理</td><td align="center"></td><td align="center">排序O(nlogn)</td><td align="center">建树O(nlogn)</td><td align="center">建表O(n)</td></tr><tr><td align="center">数据是否有序</td><td align="center">无序</td><td align="center">有序</td><td align="center">有序</td><td align="center">无序</td></tr></tbody></table><p>复习一下树和哈希表</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;暴力搜索&quot;&gt;&lt;a href=&quot;#暴力搜索&quot; class=&quot;headerlink&quot; title=&quot;暴力搜索&quot;&gt;&lt;/a&gt;暴力搜索&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;线性搜索：常用于数组链表等线性结构&lt;/li&gt;
&lt;li&gt;广度优先和深度优先：用于图树&lt;br&gt;
**优点是通用简单，无需预处理数据，也不需要额外的数据结构**
&lt;br&gt;时间复杂度O(N)&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T10:10:09.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。</p><span id="more"></span><p>和动态规划有相似，都依赖最优子结构，但原理不同：</p><ol><li>动态规划根据之前截断所有决策考虑当前决策，使用过去子问题的解构建当前子问题的解</li><li>贪心不考虑过去的决策，一路向前进行贪心选择不断缩小问题范围</li></ol><h1 id="优点和局限性"><a href="#优点和局限性" class="headerlink" title="优点和局限性"></a>优点和局限性</h1><ol><li>优点：简单，效率高</li><li>确定：没有证明的情况下无法保证一定找到正确答案</li></ol><h1 id="适用"><a href="#适用" class="headerlink" title="适用"></a>适用</h1><ol><li>可以保证找到最优解</li><li>可以找到近似最优解（次优解，同时问题允许次优解）</li></ol><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol><li>贪心选择性质： 只有局部最优始终可以全局最优，才能保证得到最优解</li><li>最优子结构：原问题的最优解包含子问题的最优解</li></ol><h1 id="解题步骤"><a href="#解题步骤" class="headerlink" title="解题步骤"></a>解题步骤</h1><ol><li>问题分析：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及</li><li>确定贪心策略：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li><li>正确性证明：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li></ol><h1 id="例题引入"><a href="#例题引入" class="headerlink" title="例题引入"></a>例题引入</h1><p>给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 $-1$ 。</p><p>这个题用动态规划可以严谨的解答，但我们尝试一下贪心</p><p>可以贪心的选择不大于且最接近的硬币</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 零钱兑换：贪心 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">coinChangeGreedy</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amt)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设 coins 列表有序</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coins.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 循环进行贪心选择，直到无剩余金额</span></span><br><span class="line">    <span class="keyword">while</span> (amt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 找到小于且最接近剩余金额的硬币</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; coins[i] &gt; amt) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 选择 coins[i]</span></span><br><span class="line">        amt -= coins[i];</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若未找到可行方案，则返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> amt == <span class="number">0</span> ? count : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时间复杂度降低到了O(amt&#x2F;min(coins))<br>但是某些组合不成立，比如[1,20,50].三个20才是最优解，贪心的结果会是50+1*10，一共十个硬币</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><h2 id="分数背包问题"><a href="#分数背包问题" class="headerlink" title="分数背包问题"></a>分数背包问题</h2><p>给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，<strong>但可以选择物品的一部分，价值根据选择的重量比例计算</strong>，问在限定背包容量下背包中物品的最大价值。示例如下图所示。</p><ol><li>和0-1背包很像，装填包含当前物品i和容量c，目标是最大价值，但是这个允许选择物品的一部分</li></ol><p>可以引入单位重量的价值：val[i-1] &#x2F; wgt[i - 1]  </p><ol start="2"><li>贪心策略确定<br>最大化背包内物品总价值，实际上本质就是最大化单位重量下的物品价值<ol><li>单位价值从低到高排序</li><li>遍历，每轮贪心的选择单位价值最高的</li><li>如果容量不足填入部分</li></ol></li><li>实现：可以先构造一个Item类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.event.ItemEvent;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Item</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.w = w;</span><br><span class="line">        <span class="built_in">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">fractionalKnapsack</span><span class="params">(<span class="type">int</span>[] wgt, <span class="type">int</span>[] val, <span class="type">int</span> cap)</span> &#123;</span><br><span class="line">    Item[] items = <span class="keyword">new</span> <span class="title class_">Item</span>[wgt.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wgt.length; i++) &#123;</span><br><span class="line">        items[i] = <span class="keyword">new</span> <span class="title class_">Item</span>(wgt[i], val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((<span class="type">double</span>)item.v/item.w)));</span><br><span class="line">    <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Item item : items)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(item.w &lt;= cap)</span><br><span class="line">        &#123;</span><br><span class="line">            res += item.v;</span><br><span class="line">            cap -= item.w;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            res += (<span class="type">double</span>) item.v/ item.w * cap;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度O(nlogn),空间复杂度O(n)</p><ol start="4"><li>正确性证明<br>反证法：</li></ol><p><strong>核心思想</strong>：如果存在一个比贪心解更优的“最优解”，那么这个最优解一定可以通过“交换”，变得和贪心解更像，并且价值还能变得更高。但这与“最优解”的定义相矛盾。</p><p><strong>证明步骤：</strong></p><ol><li><p><strong>假设存在更优解</strong>：<br>假设我们的贪心策略（永远优先装单位价值最高的物品）得到的解是 <code>G</code>。同时，假设存在一个不完全遵循此策略，但价值却比 <code>G</code> 更高的最优解，我们称之为 <code>O</code>。</p></li><li><p><strong>找到第一个分歧点</strong>：<br>既然解 <code>O</code> 和解 <code>G</code> 不一样，那么必然存在某个物品，它们装入的重量不同。我们按单位价值从高到低检查所有物品，找到<strong>第一个</strong> <code>G</code> 和 <code>O</code> 装入重量不同的物品，记为物品 <code>i</code>。</p><ul><li>根据贪心策略，<code>G</code> 会尽可能多地装入物品 <code>i</code>。因此，<code>G</code> 中物品 <code>i</code> 的重量必然<strong>大于</strong> <code>O</code> 中物品 <code>i</code> 的重量。</li></ul></li><li><p><strong>分析最优解 <code>O</code> 的构成</strong>：</p><ul><li>解 <code>O</code> 少装了单位价值较高的物品 <code>i</code>，但为了达到最优（甚至超过 <code>G</code>），它必然在<strong>某个单位价值更低的物品 <code>j</code></strong> 上，装入了比 <code>G</code> 更多的重量。</li></ul></li><li><p><strong>执行“替换”操作</strong>：</p><ul><li>现在我们来调整“最优解” <code>O</code>：从 <code>O</code> 中取出一小部分单位价值较低的物品 <code>j</code>，用等量的单位价值较高的物品 <code>i</code> 来替换。</li><li>由于 <code>O</code> 中 <code>j</code> 有富余，<code>i</code> 有空缺，这个替换操作是完全可行的。</li></ul></li><li><p><strong>得出矛盾</strong>：</p><ul><li>因为物品 <code>i</code> 的单位价值<strong>高于</strong>物品 <code>j</code>，这个替换操作在总重量不变的情况下，<strong>必然会使总价值增加</strong>。</li><li>这意味着，我们刚刚把所谓的“最优解 <code>O</code>”变得更优了。这与 <code>O</code> 本身就是最优解的假设相矛盾！</li></ul></li></ol><p><strong>结论</strong>：因此，最初的假设（存在一个比贪心解更优的解）是错误的。贪心策略得到的解就是最优解。</p><h2 id="最大容量问题"><a href="#最大容量问题" class="headerlink" title="最大容量问题"></a>最大容量问题</h2><p>输入一个数组 $ht$ ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。</p><p>容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差。</p><p>请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。示例如下图所示。</p><p><img src="/img_25.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/img_25.png"></p><p><strong>分析</strong></p><ol><li>容器由任意两个隔板围城，因此本题状态就是两个隔板的索引，记为[i,j]</li><li>容量等于短板高度×索引差。因此cap[i,j] &#x3D; min(ht[i],ht[j])*(j-i)。这个显然可以暴力遍历，时间复杂度O(n^2)</li><li>贪心策略：<br> <img src="/img_26.png" alt="/img/算法笔记/基本算法//img/算法笔记/基本算法/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/img_26.png"><br> 选取一个状态[i,j],满足索引i&lt;j,并且先暂定ht[i] &lt; ht[j]<br> 如果此时将长板j向向短板i靠近，则容量一定会减小<br> 因为，移动长板j后，宽度一定减小，但是高度由短板决定，高度只能不变或者变小。<br> 所以能得到，想要容量变大必须向内收缩短板i，才有可能使容量变大。<br> 可以得到贪心策略的执行过程：<br> 1. 初始状态，i,j指针分列数组两端<br> 2. 计算当前的cap[i,j]<br> 3. 比较板i和j的高度，短板向内移动一格<br> 4. 循环执行2.和3.，直到i和j相遇</li><li>循环最多n轮，时间复杂度O(n),空间复杂度O(1)<br> i,j,res,使用O(1)的空间<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxCapacity</span><span class="params">(<span class="type">int</span>[] ht)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化i，j</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>,j = ht.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> Math.min(ht[i],ht[j]) * (j - i);</span><br><span class="line">        res = Math.max(res,cap);</span><br><span class="line">        <span class="keyword">if</span>(ht[i] &lt; ht[j])</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>正确性证明：<br>贪心比穷举快是因为每轮都会跳过一些状态，实际上跳过的就是长板向内移动的状态，这样前面已经说过容量肯定变小，因此被跳过的状态都不可能是最优解，跳过并不会导致错过最优解。</li></ol><h2 id="最大切分城际问题"><a href="#最大切分城际问题" class="headerlink" title="最大切分城际问题"></a>最大切分城际问题</h2><p>给定一个正整数 $n$ ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少。</p><ol><li><p>贪心策略  </p><ol><li>假设从n分出一个2，2(n-2)在n&gt;&#x3D;4时一定大于n，说明n大于等于4时，切分出一个2后乘积变大，说明大于等于4的整数都应该切分，最终因子只剩1,2,3</li><li>接下来，看看1，2，3因子哪个最优。显然1最差，1*(n-1)必定乘积减小，1应该和其他因子合并；当n &#x3D; 6时，3<em>3&gt;2</em>2*2，意味着如果由3个二应当合并成两个3</li></ol><p> 因此最终，</p><ol><li>输入整数n，不断切分因子3直到剩余余数0，1，2</li><li>余数为0不必处理</li><li>余数为2，不继续划分保留</li><li>余数为1，由于2<em>2&gt;1</em>3，将最后一个3换成2</li></ol></li><li><p>实现<br>不必循环切分，直接整除3得3的个数，对3取模得余数，不过当n&lt;&#x3D;3时必须拆分一个1，乘积为1*(n-2)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProductCutting</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>*(n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> n/<span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> n%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a-<span class="number">1</span>)*<span class="number">2</span>*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,a)*<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>正确性证明：<br>反证法，分析n&gt;&#x3D;4：</p><ol><li>所有因子&lt;&#x3D;3:假设存在大于等于4的因子x，一定能进一步分为2(x-2)，从而获得更大或者相等的乘积</li><li>不包含1：假设包含1，1可以融合进其他因子，可以获得更大的乘积</li><li>做多包含两个2：如果有3个2，一定可以替换成两个3.</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。&lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归复杂度分析</title>
    <link href="https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
    <id>https://stellogic.github.io/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</id>
    <published>2025-09-15T01:19:35.000Z</published>
    <updated>2025-09-15T09:29:16.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何系统性分析递归算法的复杂度（最终优化版）"><a href="#如何系统性分析递归算法的复杂度（最终优化版）" class="headerlink" title="如何系统性分析递归算法的复杂度（最终优化版）"></a><strong>如何系统性分析递归算法的复杂度（最终优化版）</strong></h2><p>分析递归算法的复杂度，核心在于将算法的递推逻辑转化为清晰的数学模型，并选择最恰当的工具进行求解。本指南将为您呈现一个从时间到空间、从建模到求解的完整分析框架。</p><span id="more"></span><h3 id="开篇：分析决策流程图"><a href="#开篇：分析决策流程图" class="headerlink" title="开篇：分析决策流程图"></a><strong>开篇：分析决策流程图</strong></h3><p>在开始之前，可以根据以下流程图来选择最适合您的分析路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                  拿到一个递归算法</span><br><span class="line">                        ↓</span><br><span class="line">        1. 写出时间/空间递推关系式</span><br><span class="line">                        ↓</span><br><span class="line">[时间复杂度分析] ├──────────────────| [空间复杂度分析]</span><br><span class="line">      ↓                                    ↓</span><br><span class="line">2. 观察递推式形式                      分析最大递归深度 × 单次调用空间</span><br><span class="line">      ↓</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│ T(n)=aT(n/b)+f(n)？                          │</span><br><span class="line">│      ├─ 是 ─&gt; ✅ 优先：主方法                 │</span><br><span class="line">│      │         (若不适用，则转为递归树法)        │</span><br><span class="line">│      ↓ 否                                      │</span><br><span class="line">│                                              │</span><br><span class="line">│ T(n)=T(n-c)+f(n) 或 T(n)=aT(n-c)+f(n)？       │</span><br><span class="line">│      ├─ 是 ─&gt; ✅ **展开求和 (或递归树法)**      │</span><br><span class="line">│      │         (例如: T(n)=T(n-1)+n)           │</span><br><span class="line">│      ↓ 否                                      │</span><br><span class="line">│                                              │</span><br><span class="line">│ 其他复杂形式？ (如 T(n)=T(n/a)+T(n/b)+f(n))   │</span><br><span class="line">│      └─&gt; ✅ **通用后备：递归树法**             │</span><br><span class="line">│            (用于猜测，再用替换法证明)          │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br><span class="line">      ↓</span><br><span class="line">3. 特殊视角：是否满足“单次处理成本O(1)”？</span><br><span class="line">      └─ 是 ─&gt; ✅ **聚合分析法**</span><br></pre></td></tr></table></figure><hr><h3 id="第一部分：时间复杂度分析"><a href="#第一部分：时间复杂度分析" class="headerlink" title="第一部分：时间复杂度分析"></a><strong>第一部分：时间复杂度分析</strong></h3><p>时间复杂度的分析重点在于量化递归过程中的总计算量。</p><h4 id="第一步：建立递推关系式（分析的基石）"><a href="#第一步：建立递推关系式（分析的基石）" class="headerlink" title="第一步：建立递推关系式（分析的基石）"></a><strong>第一步：建立递推关系式（分析的基石）</strong></h4><p>这是所有分析的起点。您需要将代码逻辑翻译成一个数学表达式 <code>T(n)</code>，它描述了处理规模为 <code>n</code> 的问题所需的总时间。</p><p>一个标准的递推关系式包含两部分：</p><ul><li><strong>递归成本</strong>：为解决原问题，递归调用了多少次函数 (<code>a</code>)？每次调用的子问题规模是多大 (<code>n/b</code>)？</li><li>**本地成本 <code>f(n)</code>**：在单次函数调用中，除了递归调用外，执行了多少“本地”计算（如循环、判断、合并结果等）？</li></ul><p><strong>标准形式</strong>：<code>T(n) = a * T(n/b) + f(n)</code></p><p><strong>示例：归并排序 (Merge Sort)</strong></p><ul><li><strong>递推关系式</strong>：<code>T(n) = 2T(n/2) + O(n)</code><ul><li><code>2T(n/2)</code>：两次递归调用，每次处理一半数据。</li><li><code>O(n)</code>：合并两个有序数组的 <code>merge</code> 操作成本。</li></ul></li></ul><blockquote><p><strong>重要前提：明确分析场景</strong><br>在开始分析前，务必明确您分析的是<strong>最坏情况 (Worst Case)</strong> 还是 **平均情况 (Average Case)**。对于某些算法，这两种情况的递推式截然不同。</p><ul><li><strong>快速排序 (Quicksort) 示例</strong>：<ul><li><strong>最坏情况</strong> (主元划分极不均衡): <code>T(n) = T(n-1) + O(n)</code> → 解得 <code>O(n²)</code>。</li><li><strong>平均&#x2F;最好情况</strong> (主元划分较均匀): <code>T(n) = 2T(n/2) + O(n)</code> → 解得 <code>O(n log n)</code>。</li></ul></li></ul></blockquote><h4 id="第二步：选择求解方法（决策流程）"><a href="#第二步：选择求解方法（决策流程）" class="headerlink" title="第二步：选择求解方法（决策流程）"></a><strong>第二步：选择求解方法（决策流程）</strong></h4><p>得到递推关系式后，下一步就是求解它。您可以根据关系式的特点，选择最高效的分析“武器”。</p><hr><h4 id="分析武器详解"><a href="#分析武器详解" class="headerlink" title="分析武器详解"></a><strong>分析武器详解</strong></h4><p><strong>武器一：主方法 (Master Theorem) — 公式捷径</strong></p><p>这是求解 <code>T(n) = a * T(n/b) + f(n)</code> (a&gt;&#x3D;1,b&gt;1)形式的“利器”。核心是比较 <strong><code>f(n)</code></strong> 与 <strong><code>n^(log_b a)</code></strong> 的增长速度：</p><ol><li><p>**情况一 (子问题主导)**：若 <code>f(n) = O(n^(log_b a - ε))</code> 对于某个常数 <code>ε &gt; 0</code>，则 <code>T(n) = Θ(n^(log_b a))</code>。</p><ul><li>通俗讲：<code>f(n)</code> 的增长速度<strong>显著慢于</strong> <code>n^(log_b a)</code>。</li></ul></li><li><p>**情况二 (成本均衡)**：若 <code>f(n) = Θ(n^(log_b a))</code>，则 <code>T(n) = Θ(n^(log_b a) * log n)</code>。</p><ul><li>通俗讲：<code>f(n)</code> 的增长速度<strong>等于</strong> <code>n^(log_b a)</code>。</li></ul></li><li><p>**情况三 (本地成本主导)**：若 <code>f(n) = Ω(n^(log_b a + ε))</code> 对于某个常数 <code>ε &gt; 0</code>，且满足正则条件 <code>a * f(n/b) ≤ c * f(n)</code> (对于某个常数 <code>c &lt; 1</code> 和所有足够大的 <code>n</code>)，则 <code>T(n) = Θ(f(n))</code>。</p><ul><li>通俗讲：<code>f(n)</code> 的增长速度<strong>显著快于</strong> <code>n^(log_b a)</code>。</li></ul></li></ol><p><strong>实际上，可以认为 f(n) 代表本地操作数增长，g(n) &#x3D; n^(log_b a) 代表基础子问题操作数增长（递归树叶节点操作数），谁趋势<code>显著大</code>就保留谁，一样的话就再乘上一个logn</strong><br><strong>显著大：h(n) &#x3D; f(n) &#x2F; g(n)，如果h(n)至少是一个多项式(n^k,k大于0)，意味着f(n)显著大于g(n)</strong></p><p>关于g(n),g(n)实际上是a^(树高次方)进行数学恒等变换得到的，代表递归树的总叶结点数量，每个节点数量，每个节点的操作树一般都是f(1)是个常数，因此这个式子可以代表子问题总操作数</p><blockquote><p><strong>正则条件 <code>a * f(n/b) ≤ c * f(n)</code> 的通俗理解</strong>：<br>这个条件确保 <code>f(n)</code> 的增长是“稳健的”，不会在递归深入时出现剧烈波动。它本质上是要求：**子问题 <code>a * f(n/b)</code> 的总本地成本，必须小于或等于根节点本地成本 <code>f(n)</code> 的一个常数比例 <code>c</code>**（其中 <code>c&lt;1</code>）。这保证了总成本主要由根节点的 <code>f(n)</code> 决定，而不会被子问题的成本“反超”。绝大多数常见的多项式、对数函数都满足此条件。</p></blockquote><blockquote><p><strong>局限性与扩展</strong>：主方法并非万能，其三个情况之间存在“间隙”(gap)，无法覆盖所有函数。</p><ul><li><strong>一个常见的“间隙”情况（主方法扩展）</strong>：当 <code>f(n) = Θ(n^(log_b a) * log^k n)</code> 且 <code>k ≥ 0</code> 时，标准主方法不直接适用。此时，解为 **<code>T(n) = Θ(n^(log_b a) * log^(k+1) n)</code>**。</li></ul><p>  例如，对于递推式 <code>T(n) = 2T(n/2) + O(n log n)</code>，这里 <code>a=2, b=2</code>, <code>log_b a = 1</code>。<code>f(n) = n log n</code>，属于 <code>k=1</code> 的情况。其解为 <code>T(n) = Θ(n * log² n)</code>。</p></blockquote><p><strong>武器二：递归树法 (Recursion Tree Method) — 直观通用</strong></p><p>当主方法不适用或想更深入理解时，递归树是最好的工具。</p><p><strong>分析步骤</strong>：</p><ol><li><strong>画树</strong>：将递推式展开成一棵树，每个节点代表一次函数调用的本地成本。</li><li><strong>算每层成本</strong>：计算树的每一层所有节点的成本之和。</li><li><strong>算树高</strong>：确定从根节点到叶子节点的最长路径长度。</li><li><strong>累加求和</strong>：将所有层的成本累加起来，得到总复杂度。</li></ol><p><strong>示例1 (均匀分割)：归并排序 <code>T(n) = 2T(n/2) + cn</code></strong></p><ul><li><strong>每层成本</strong>：无论在哪一层，该层所有节点的成本之和总是 <code>cn</code>。</li><li><strong>树高</strong>：<code>log₂n</code>。</li><li><strong>总成本</strong>：每层成本 × 树高 &#x3D; <code>cn * log₂n</code> → <code>O(n log n)</code>。</li></ul><p><strong>示例2 (非均匀分割)：<code>T(n) = T(n/3) + T(2n/3) + n</code></strong></p><ul><li><strong>画树</strong>：这是一棵非完全二叉树，每一层的节点大小不同。</li><li><strong>每层成本</strong>：根节点成本是 <code>n</code>。下一层是 <code>n/3</code> 和 <code>2n/3</code>，成本和仍为 <code>n</code>。可以发现，每一层的成本之和都是 <code>n</code>。</li><li><strong>树高</strong>：树的高度由最长的路径决定，即 <code>n -&gt; (2/3)n -&gt; (2/3)²n -&gt; ... -&gt; 1</code>。高度 <code>h</code> 满足 <code>(2/3)^h * n = 1</code>，解得 <code>h = log_(3/2) n</code>。</li><li><strong>总成本</strong>：<code>n * log_(3/2) n</code> → <code>O(n log n)</code>。这个例子展示了递归树处理复杂分割的强大能力。</li></ul><blockquote><p><strong>⚠️ 递归树法的常见陷阱：误判叶子节点数量</strong><br>对于 <code>T(n) = aT(n/b) + f(n)</code> 形式的递归，叶子节点的总数是 <code>a^h</code>，其中 <code>h</code> 是树高。这个总数等于 **<code>n^(log_b a)</code>**。在计算与叶子节点相关的成本时（通常是递归的终止条件 <code>T(1)</code>），必须使用这个正确的数量级，而不是简单地认为是 <code>n</code>。</p></blockquote><p><strong>武器三：替换法 (Substitution Method) — 严谨证明</strong></p><p>此方法本质是数学归纳法，通常配合递归树使用：先用递归树猜测一个复杂度上界，再用替换法来严格证明这个猜测是成立的。</p><p><strong>武器四：聚合分析法  — 总量视角</strong><br>注：此处的聚合分析指直接累加算法各部分的总工作量  </p><p>此方法跳出求解单次递归的递推关系，通过直接计算整个算法生命周期内的工作总量来确定复杂度。</p><p><strong>✅ 适用信号</strong>：</p><ul><li><strong>有限处理次数</strong>：通过“单向移动指针”或“<code>visited</code>状态标记”等机制，保证每个核心元素在其生命周期内只被处理有限次（通常是1次）。</li><li><strong>恒定单次成本</strong>：处理单个工作单元的本地操作成本为 **<code>O(1)</code>**，通常借助哈希表等高效数据结构实现。实际上是每个单元的操作树不随子问题规模而变化</li></ul><p><strong>分析步骤</strong>：<br><code>总复杂度 = (一次性初始化成本) + (工作单元总数) × (每个单元的处理次数) × (单次处理成本)</code></p><p><strong>示例：根据前序和中序遍历重建二叉树 (使用哈希表)</strong></p><ol><li><strong>适用性判断</strong>：<ul><li>前序遍历的索引 <code>preIndex</code> 只增不减，保证每个节点只被创建一次。（满足特征1）</li><li>通过哈希表 <code>inorderMap</code> 查找根节点索引，成本为 <code>O(1)</code>。（满足特征2）</li></ul></li><li><strong>分析</strong>：<ul><li>一次性成本：构建 <code>inorderMap</code> &#x3D; <code>O(N)</code>。</li><li>核心工作量：<code>N</code>个节点 × <code>1</code>次处理 × <code>O(1)</code>单次成本 &#x3D; <code>O(N)</code>。</li><li><strong>总复杂度</strong> &#x3D; <code>O(N) + O(N) = O(N)</code>。</li></ul></li></ol><hr><h3 id="第二部分：空间复杂度分析"><a href="#第二部分：空间复杂度分析" class="headerlink" title="第二部分：空间复杂度分析"></a><strong>第二部分：空间复杂度分析</strong></h3><p>递归算法的空间复杂度主要由<strong>递归调用栈 (Call Stack)</strong> 的深度决定。它衡量的是算法在执行期间内存占用的<strong>峰值</strong>。</p><h4 id="核心公式"><a href="#核心公式" class="headerlink" title="核心公式"></a><strong>核心公式</strong></h4><p><strong>调用栈空间复杂度 &#x3D; 最大递归深度 × 每次递归调用所需的空间</strong></p><blockquote><h4 id="一个更完整的视角：调用栈空间-vs-辅助空间"><a href="#一个更完整的视角：调用栈空间-vs-辅助空间" class="headerlink" title="一个更完整的视角：调用栈空间 vs. 辅助空间"></a><strong>一个更完整的视角：调用栈空间 vs. 辅助空间</strong></h4><p>一个算法的<strong>总空间复杂度</strong>是<strong>调用栈空间</strong>与算法明确创建的<strong>辅助空间</strong>（如数组、哈希表等）中的<strong>最大值</strong>。</p><p><strong>总空间复杂度 &#x3D; Max(调用栈空间, 辅助空间)</strong></p><p><strong>关于返回值的说明</strong>：通常，空间复杂度分析关注的是算法运行过程中的<strong>临时内存占用</strong>，不包括最终输出结果本身所需的空间。</p><p><strong>示例</strong>：一个递归函数，对一棵有 <code>N</code> 个节点的平衡二叉树进行遍历，并将所有节点值存入一个结果列表中。</p><ul><li><strong>调用栈空间</strong>：树的高度为 <code>O(log N)</code>。</li><li><strong>辅助空间</strong>：结果列表需要存储 <code>N</code> 个节点值，空间为 <code>O(N)</code>。</li><li><strong>最终空间复杂度</strong>：<code>Max(O(log N), O(N)) = O(N)</code>。</li></ul></blockquote><h4 id="系统分析步骤"><a href="#系统分析步骤" class="headerlink" title="系统分析步骤"></a><strong>系统分析步骤</strong></h4><p><strong>第一步：确定最大递归深度</strong><br>这是决定调用栈空间复杂度的<strong>最关键因素</strong>。</p><ul><li>**线性递归 (如：阶乘)**：最大深度为 <code>O(n)</code>。</li><li>**树形递归 (如：斐波那契数列)**：虽然总调用次数是指数级的，但执行是深度优先的。最长的调用链是从 <code>n</code> 到 <code>1</code>，因此最大深度仍为 <code>O(n)</code>。</li><li><strong>二叉树深度遍历</strong>：递归深度取决于树的高度 <code>h</code>。对于平衡二叉树，深度为 <code>O(log n)</code>；对于链状的极端情况，深度为 <code>O(n)</code>。</li></ul><p><strong>第二步：分析单次调用的空间消耗</strong><br>在绝大多数情况下，如果不创建与输入规模 <code>n</code> 相关的动态数据结构，单次调用的空间消耗是常数级别的，即 <code>O(1)</code>。</p><blockquote><p><strong>⚠️ 注意隐式空间开销</strong><br>在分析单次调用的空间时，要警惕那些看起来像是 <code>O(1)</code> 但实际上会创建新对象的语言特性。</p><ul><li><strong>示例 (Python)<strong>：在递归函数中如果使用了字符串或列表的</strong>切片 (slicing)</strong> 作为参数传递，例如 <code>recursive_call(arr[1:])</code>，这通常会创建一个<strong>新的、长度为 n-1 的副本</strong>，导致单次调用的空间消耗为 <code>O(n)</code>，从而极大地增加了总空间复杂度。</li><li><strong>正确做法</strong>：应通过传递<strong>索引或指针</strong>（如 <code>recursive_call(arr, start_index + 1)</code>)来避免这种不必要的空间开销，维持单次调用的空间为 <code>O(1)</code>。</li></ul></blockquote><p><strong>第三步：综合计算总的空间复杂度</strong><br>结合前两步的结果，并考虑算法使用的辅助空间，得出最终结论。</p><h4 id="优化考量：尾递归-Tail-Recursion"><a href="#优化考量：尾递归-Tail-Recursion" class="headerlink" title="优化考量：尾递归 (Tail Recursion)"></a><strong>优化考量：尾递归 (Tail Recursion)</strong></h4><p>如果一个递归函数的最后一步操作是调用自身（尾调用），支持该优化的编译器可以复用当前栈帧，将<strong>调用栈空间</strong>复杂度从 <code>O(n)</code> 降低到 <code>O(1)</code>。</p><blockquote><p><strong>注意</strong>：许多主流编程语言（如 <strong>Python、Java</strong>）的解释器&#x2F;编译器<strong>默认不支持</strong>尾递归优化。因此，在这些环境中不能想当然地认为空间复杂度会被优化。</p></blockquote><hr><h3 id="第三部分：总结与常见陷阱"><a href="#第三部分：总结与常见陷阱" class="headerlink" title="第三部分：总结与常见陷阱"></a><strong>第三部分：总结与常见陷阱</strong></h3><h4 id="核心分析方法对比表"><a href="#核心分析方法对比表" class="headerlink" title="核心分析方法对比表"></a><strong>核心分析方法对比表</strong></h4><table><thead><tr><th align="left">方法</th><th align="left">适用场景</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left"><strong>主方法</strong></td><td align="left"><code>T(n)=aT(n/b)+f(n)</code> 形式的递推式</td><td align="left">快速、公式化、结论直接</td><td align="left">有“间隙”，不通用，无法处理非标准形式</td></tr><tr><td align="left"><strong>递归树法</strong></td><td align="left">几乎所有递推式，尤其主方法失效时</td><td align="left">直观、通用、能处理复杂分割</td><td align="left">过程相对繁琐，涉及级数求和</td></tr><tr><td align="left"><strong>替换法</strong></td><td align="left">需要严格数学证明的场合</td><td align="left">最严谨，是复杂度的最终证明</td><td align="left">需要先“猜测”一个解，过程复杂</td></tr><tr><td align="left"><strong>聚合</strong></td><td align="left">每个工作单元处理次数有限且单次成本O(1)</td><td align="left">思路巧妙，跳出递推式，计算简单</td><td align="left">适用场景非常有限，条件苛刻</td></tr></tbody></table><h4 id="常见分析陷阱"><a href="#常见分析陷阱" class="headerlink" title="常见分析陷阱"></a><strong>常见分析陷阱</strong></h4><ol><li><p><strong>陷阱一：混淆“调用总次数”与“最大递归深度”</strong></p><ul><li><strong>辨析</strong>：时间复杂度关心<strong>总工作量</strong>（调用总次数），而空间复杂度关心内存占用的<strong>峰值</strong>（最大递归深度）。</li><li><strong>反例速查</strong>：朴素的斐波那契数列 <code>fib(n)</code>，时间复杂度为 <code>O(2^n)</code>（指数级的调用次数），但空间复杂度仅为 <code>O(n)</code>（线性的递归深度）。</li></ul></li><li><p><strong>陷阱二：公式不是万能的，别乱套！</strong></p><ul><li><strong>辨析</strong>：每种方法都有其严格的适用范围。当不确定时，回归最通用的<strong>递归树法</strong>。</li><li><strong>反例速查</strong>：递推式 <code>T(n) = T(n-1) + n</code> 不符合主方法的结构，强行套用会出错。使用递归树法则能清晰地看到其成本累加为 <code>n + (n-1) + ... + 1</code>，结果为 <code>O(n²)</code>。</li></ul></li><li><p><strong>陷阱三：<code>f(n)</code> 是魔鬼，细节决定成败！</strong></p><ul><li><strong>辨析</strong>：在建立递推关系式 <code>T(n) = aT(n/b) + f(n)</code> 时，必须精确分析除递归调用外的所有“本地成本”<code>f(n)</code>。</li><li><strong>反例速查</strong>：归并排序中，合并操作的成本是 <code>f(n)=O(n)</code>，这是决定其 <code>O(n log n)</code> 复杂度的关键。如果误认为 <code>f(n)=O(1)</code>，会得出完全错误的结论。</li></ul></li><li><p><strong>陷阱四：忽略 <code>f(n)</code> 中的“隐形成本”</strong></p><ul><li><strong>辨析</strong>：<code>f(n)</code> 的计算必须细致入微。一个看似简单的循环或函数调用，其成本可能并非 <code>O(1)</code>。</li><li><strong>反例速查</strong>：考虑一个在 <code>n</code> 个元素上进行递归的函数，每次递归中，它都循环遍历一个大小为 <code>k</code> 的辅助数组。此时 <code>f(n)</code> 应该是 <code>O(k)</code> 而非 <code>O(1)</code>。另一个例子是在 <code>f(n)</code> 中执行了字符串拼接操作，在某些语言中，<code>n</code> 次拼接 <code>n</code> 个字符的成本可能是 <code>O(n²)</code>，而不是 <code>O(n)</code>。</li></ul></li></ol><hr><p><strong>一个构建递归树的例子</strong>  </p><h3 id="第一步：写出递推关系式"><a href="#第一步：写出递推关系式" class="headerlink" title="第一步：写出递推关系式"></a>第一步：写出递推关系式</h3><p>根据上面的算法思想，我们可以得出归并排序的时间复杂度递推关系式：</p><ul><li><strong>分解</strong>：找到中间点，只需要 <code>O(1)</code> 的时间。</li><li><strong>解决</strong>：递归调用两次，每次处理一半的数据。所以这部分的代价是 <code>2 * T(n/2)</code>。</li><li><strong>合并</strong>：<code>merge</code> 操作需要遍历两个子数组，将它们合并成一个新的数组，这个过程的时间复杂度是 <code>O(n)</code>。</li></ul><p>因此，总的时间复杂度递推式为：<br><strong>T(n) &#x3D; 2T(n&#x2F;2) + cn</strong><br>(为了方便计算，我们用 <code>cn</code> 来表示 <code>O(n)</code> 这一项，其中 <code>c</code> 是一个常数)</p><h3 id="第二步：构建并分析递归树"><a href="#第二步：构建并分析递归树" class="headerlink" title="第二步：构建并分析递归树"></a>第二步：构建并分析递归树</h3><p>现在，我们开始画出这个递推关系式对应的递归树。</p><h4 id="1-树的结构"><a href="#1-树的结构" class="headerlink" title="1. 树的结构"></a>1. 树的结构</h4><ul><li><strong>根节点</strong>：代表原始问题 <code>T(n)</code>。它有两个子节点，代表两个规模为 <code>n/2</code> 的子问题。根节点自身的工作量（合并代价）是 <code>cn</code>。</li><li><strong>第二层</strong>：有两个节点，每个节点代表一个 <code>T(n/2)</code> 的问题。对于每个节点，它自身的工作量是 <code>c(n/2)</code>，并且它又会产生两个规模为 <code>n/4</code> 的子问题。</li><li><strong>第三层</strong>：有四个节点，每个节点代表一个 <code>T(n/4)</code> 的问题，每个节点的工作量是 <code>c(n/4)</code>。</li><li><strong>……</strong></li><li><strong>叶子节点</strong>：当问题规模缩小到 1 时，递归到达终点。这代表 <code>T(1)</code>，其时间复杂度为 <code>O(1)</code>，我们记为常数 <code>c</code>。</li></ul><h4 id="2-可视化递归树"><a href="#2-可视化递归树" class="headerlink" title="2. 可视化递归树"></a>2. 可视化递归树</h4><p>下面是这个过程的可视化图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">              cn (代价)                     -----&gt;  第 0 层: 总代价 = cn</span><br><span class="line">             /  \</span><br><span class="line">            /    \</span><br><span class="line">           /      \</span><br><span class="line">     T(n/2)        T(n/2)</span><br><span class="line">       |             |</span><br><span class="line">    c(n/2)          c(n/2)                  -----&gt;  第 1 层: 总代价 = 2 * c(n/2) = cn</span><br><span class="line">     / \           / \</span><br><span class="line">    /   \         /   \</span><br><span class="line">T(n/4) T(n/4)   T(n/4) T(n/4)</span><br><span class="line">  |      |       |      |</span><br><span class="line">c(n/4) c(n/4)   c(n/4) c(n/4)             -----&gt;  第 2 层: 总代价 = 4 * c(n/4) = cn</span><br><span class="line"> ...    ...     ...    ...</span><br><span class="line"></span><br><span class="line">  |      |       |      |</span><br><span class="line"> T(1)   T(1)     ...    T(1)                   -----&gt;  第 k 层 (叶子层)</span><br></pre></td></tr></table></figure><h4 id="3-分析树的属性"><a href="#3-分析树的属性" class="headerlink" title="3. 分析树的属性"></a>3. 分析树的属性</h4><p><strong>a) 计算每一层的代价：</strong></p><ul><li>第 0 层 (根节点)：代价是 <code>cn</code>。</li><li>第 1 层：有两个节点，每个节点的代价是 <code>c(n/2)</code>，所以总代价是 <code>2 * c(n/2) = cn</code>。</li><li>第 2 层：有 <code>2^2 = 4</code> 个节点，每个节点的代价是 <code>c(n/4)</code>，所以总代价是 <code>4 * c(n/4) = cn</code>。</li><li>…</li><li>第 <code>i</code> 层：有 <code>2^i</code> 个节点，每个节点的代价是 <code>c(n / 2^i)</code>，所以总代价是 <code>2^i * c(n / 2^i) = cn</code>。</li></ul><p><strong>观察发现：</strong> 在这棵树中，每一层的总代价都是 <code>cn</code>。</p><p><strong>b) 计算树的深度（高度）：</strong></p><p>递归树的深度取决于问题规模从 <code>n</code> 缩小到 1 需要多少步。<br>假设树的深度为 <code>k</code>（从第 0 层开始）。在第 <code>k</code> 层，子问题的规模是 <code>n / 2^k</code>。<br>当递归到达叶子节点时，问题规模为 1。<br>所以，我们令 <code>n / 2^k = 1</code>，解得 <code>2^k = n</code>，即 <code>k = log₂n</code>。</p><p>因此，这棵树的高度大约为 <code>log₂n</code>。层数是从 0 到 <code>log₂n</code>，总共有 <code>log₂n + 1</code> 层。</p><h3 id="第三步：累加所有层的代价"><a href="#第三步：累加所有层的代价" class="headerlink" title="第三步：累加所有层的代价"></a>第三步：累加所有层的代价</h3><p>现在我们把所有层的代价加起来，得到算法的总运行时间。</p><p>总代价 &#x3D; (每一层的代价) × (树的层数)<br><code>T(n) = cn + cn + cn + ... + cn</code> (共 <code>log₂n</code> 层)</p><p><strong>注意</strong>：这里还需要加上最后一层叶子节点的代价。<br>最后一层（第 <code>log₂n</code> 层）有 <code>n</code> 个叶子节点 (<code>2^(log₂n) = n</code>)，每个节点的代价是 <code>T(1) = c</code>。所以最后一层的总代价是 <code>n * c = cn</code>。</p><p>精确的计算是：<br><code>T(n) = Σ (从 i=0 到 log₂n - 1) [cn] + c * n</code> (最后一层叶子节点的代价)<br><code>T(n) = cn * log₂n + cn</code></p><h3 id="第四步：得出最终复杂度"><a href="#第四步：得出最终复杂度" class="headerlink" title="第四步：得出最终复杂度"></a>第四步：得出最终复杂度</h3><p>根据上面的求和结果 <code>cn * log₂n + cn</code>，我们使用大O表示法来评估其渐进复杂度。忽略低阶项 <code>cn</code> 和常数系数 <code>c</code>，我们得到：</p><p><strong>T(n) &#x3D; O(n log n)</strong></p><h3 id="总结：递归树法分析步骤回顾"><a href="#总结：递归树法分析步骤回顾" class="headerlink" title="总结：递归树法分析步骤回顾"></a>总结：递归树法分析步骤回顾</h3><ol><li><strong>写出递推式</strong>：<code>T(n) = 2T(n/2) + cn</code>。</li><li><strong>画出递归树</strong>：清晰地展示出每一层的节点数和每个节点的代价。</li><li><strong>计算每层总代价</strong>：发现每一层的代价都是 <code>cn</code>。</li><li><strong>计算树的高度</strong>：高度为 <code>log₂n</code>。</li><li><strong>累加总代价</strong>：将每一层的代价乘以树的高度，即 <code>cn * log₂n</code>。</li><li><strong>得出结论</strong>：最终时间复杂度为 <code>O(n log n)</code>。</li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如何系统性分析递归算法的复杂度（最终优化版）&quot;&gt;&lt;a href=&quot;#如何系统性分析递归算法的复杂度（最终优化版）&quot; class=&quot;headerlink&quot; title=&quot;如何系统性分析递归算法的复杂度（最终优化版）&quot;&gt;&lt;/a&gt;&lt;strong&gt;如何系统性分析递归算法的复杂度（最终优化版）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;分析递归算法的复杂度，核心在于将算法的递推逻辑转化为清晰的数学模型，并选择最恰当的工具进行求解。本指南将为您呈现一个从时间到空间、从建模到求解的完整分析框架。&lt;/p&gt;</summary>
    
    
    
    <category term="基本算法" scheme="https://stellogic.github.io/categories/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="基本算法" scheme="https://stellogic.github.io/tags/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CS61A 学习随笔（二）</title>
    <link href="https://stellogic.github.io/2025/05/09/CS61A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://stellogic.github.io/2025/05/09/CS61A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2025-05-09T00:13:30.000Z</published>
    <updated>2025-05-09T14:48:50.718Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎来到本周的 CS61A 学习笔记！</p><p>上周突然感觉学的东西太多容易忘记，于是开始随手把学到的重要东西记下来（或者截屏下来），在周末生成一篇笔记。</p><span id="more"></span><p>主要目的是方便我以后回顾，也期待和各位交流。<br>发现错误可以联系我</p><p>本次包括了从递归到容器（container）章节的，当然也有我写作业时发现的一些小问题。<br>至于前面几章（也就是随笔一）是否会补上，随缘吧。</p><h2 id="Python-基础拾遗"><a href="#Python-基础拾遗" class="headerlink" title="Python 基础拾遗"></a>Python 基础拾遗</h2><p>在深入具体主题之前，先回顾几个 Python 中常见但易混淆的基础点。</p><h3 id="print-输出与交互式解释器返回值"><a href="#print-输出与交互式解释器返回值" class="headerlink" title="print() 输出与交互式解释器返回值"></a><code>print()</code> 输出与交互式解释器返回值</h3><ul><li><strong><code>print()</code> 输出</strong>：<code>print()</code> 函数的作用是显示对象转换成字符串后的内容。对于字符串对象，它通常不带引号，更侧重于“人类可读”的表示。</li><li><strong>交互式解释器显示的返回值</strong>：当你在 Python 交互式解释器（REPL）中输入一个表达式并执行后，解释器会显示该表达式的官方字符串表示形式，即调用对象的 <code>repr()</code> 方法得到的结果。对于字符串，这通常会带有引号，以明确表示其类型和精确值。</li></ul><h3 id="赋值与求值顺序"><a href="#赋值与求值顺序" class="headerlink" title="赋值与求值顺序"></a>赋值与求值顺序</h3><ul><li><strong>赋值顺序</strong>：Python 中的赋值操作遵循“先右后左”的原则。即先计算赋值符号（<code>=</code>）右边的表达式的值，然后将这个值绑定到左边的变量名上。</li><li>**短路求值 (Short-circuiting)**：对于逻辑运算符 <code>and</code> 和 <code>or</code>，Python 会进行短路求值。<ul><li><code>A and B</code>: 如果 <code>A</code> 为假，则整个表达式必为假，不会再评估 <code>B</code>。</li><li><code>A or B</code>: 如果 <code>A</code> 为真，则整个表达式必为真，不会再评估 <code>B</code>。<br>显示的是最后被评估的那个操作数的值。</li></ul></li></ul><h3 id="帧-Frame-与环境"><a href="#帧-Frame-与环境" class="headerlink" title="帧 (Frame) 与环境"></a>帧 (Frame) 与环境</h3><p>在新帧 (frame) 中绑定的参数值来源于创建这个帧的那个环境。这一点对于理解闭包 (closures) 等高级概念至关重要。</p><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 (Recursion)"></a>递归 (Recursion)</h2><p>递归是一种强大的编程技巧，函数通过调用自身来解决问题。</p><h3 id="递归函数的构成-The-Anatomy-of-a-Recursive-Function"><a href="#递归函数的构成-The-Anatomy-of-a-Recursive-Function" class="headerlink" title="递归函数的构成 (The Anatomy of a Recursive Function)"></a>递归函数的构成 (The Anatomy of a Recursive Function)</h3><p>一个典型的递归函数通常包含以下几个部分：</p><ol><li>**函数定义头部 (<code>def</code>语句)**：与普通函数类似，定义函数名和参数。</li><li>**基本情况 (Base Cases)**：<ul><li>这是递归的终止条件。</li><li>条件语句（如 <code>if</code>）用于检查是否达到基本情况。</li><li>基本情况的求解<strong>不涉及</strong>进一步的递归调用，直接返回一个结果。</li></ul></li><li>**递归情况 (Recursive Cases)**：<ul><li>如果未达到基本情况，则进入递归情况。</li><li>在递归情况中，问题会被分解成一个或多个规模更小但结构相同的子问题。</li><li>函数会<strong>调用自身</strong>来解决这些子问题。</li><li>通常会将子问题的解组合起来，形成原问题的解。</li></ul></li></ol><h3 id="迭代是递归的一种特殊情况-Iteration-is-a-special-case-of-recursion"><a href="#迭代是递归的一种特殊情况-Iteration-is-a-special-case-of-recursion" class="headerlink" title="迭代是递归的一种特殊情况 (Iteration is a special case of recursion)"></a>迭代是递归的一种特殊情况 (Iteration is a special case of recursion)</h3><p>虽然我们通常感觉递归比迭代复杂，但从理论上讲，任何迭代过程都可以用特定形式的递归（通常是尾递归）来表达。</p><h3 id="递归的信任飞跃-The-Recursive-Leap-of-Faith"><a href="#递归的信任飞跃-The-Recursive-Leap-of-Faith" class="headerlink" title="递归的信任飞跃 (The Recursive Leap of Faith)"></a>递归的信任飞跃 (The Recursive Leap of Faith)</h3><p>理解和编写递归函数时，“递归的信任飞跃”是一个非常有用的思维模式。其核心思想是：</p><p><strong>相信你的函数能够正确处理规模更小的子问题。</strong></p><p>以阶乘函数 <code>fact(n)</code> 为例：<br><code>n! = n * (n-1)!</code> (当 n &gt; 0)<br><code>0! = 1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fact</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 基本情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 递归情况</span></span><br><span class="line">        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>) <span class="comment"># 信任 fact(n-1) 能正确计算 (n-1)!</span></span><br></pre></td></tr></table></figure><p>验证 <code>fact</code> 是否正确实现：</p><ol><li><strong>验证基本情况</strong>：当 <code>n == 0</code> 时，<code>fact(0)</code> 返回 <code>1</code>。这是正确的。</li><li><strong>将 <code>fact</code> 视为一个功能抽象</strong>：暂时不关心 <code>fact</code> 内部如何工作，只关心它的功能——计算阶乘。</li><li><strong>假设 <code>fact(n-1)</code> 是正确的</strong>：这是信任飞跃的核心。我们假设 <code>fact(n-1)</code> 能够完美地计算出 <code>(n-1)!</code> 的值。</li><li><strong>验证 <code>fact(n)</code> 在假设下的正确性</strong>：基于 <code>fact(n-1)</code> 返回 <code>(n-1)!</code> 的假设，<code>fact(n)</code> 返回 <code>n * fact(n-1)</code>，即 <code>n * (n-1)!</code>，这正是 <code>n!</code> 的定义。因此，<code>fact(n)</code> 是正确的。</li></ol><p>只要基本情况正确，并且递归步骤能正确地将问题规模缩小并最终达到基本情况，那么递归的信任就能得到回报。</p><h3 id="递归示例：Luhn-算法的部分求和"><a href="#递归示例：Luhn-算法的部分求和" class="headerlink" title="递归示例：Luhn 算法的部分求和"></a>递归示例：Luhn 算法的部分求和</h3><p>Luhn 算法常用于验证信用卡号等识别码。以下是其求和部分的一个递归实现（假设 <code>split(n)</code> 函数可以将数字 <code>n</code> 分为 <code>all_but_last</code> 和 <code>last</code> 两部分，<code>sum_digits(k)</code> 计算数字 <code>k</code> 的各位数字之和）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">luhn_sum</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:  <span class="comment"># 基本情况</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 递归情况</span></span><br><span class="line">        all_but_last, last = split(n)</span><br><span class="line">        <span class="comment"># 信任 luhn_sum_double 能正确处理 all_but_last</span></span><br><span class="line">        <span class="keyword">return</span> luhn_sum_double(all_but_last) + last</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">luhn_sum_double</span>(<span class="params">n</span>):</span><br><span class="line">    all_but_last, last = split(n)</span><br><span class="line">    luhn_digit = sum_digits(<span class="number">2</span> * last) <span class="comment"># 对末位加倍并求和</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:  <span class="comment"># 基本情况</span></span><br><span class="line">        <span class="keyword">return</span> luhn_digit</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 递归情况</span></span><br><span class="line">        <span class="comment"># 信任 luhn_sum 能正确处理 all_but_last</span></span><br><span class="line">        <span class="keyword">return</span> luhn_sum(all_but_last) + luhn_digit</span><br></pre></td></tr></table></figure><h2 id="递归与迭代的转换"><a href="#递归与迭代的转换" class="headerlink" title="递归与迭代的转换"></a>递归与迭代的转换</h2><p>递归和迭代在很多情况下可以相互转换。</p><h3 id="将递归转换为迭代-Converting-Recursion-to-Iteration"><a href="#将递归转换为迭代-Converting-Recursion-to-Iteration" class="headerlink" title="将递归转换为迭代 (Converting Recursion to Iteration)"></a>将递归转换为迭代 (Converting Recursion to Iteration)</h3><p>这通常需要思考递归调用栈是如何工作的，并尝试用循环和显式的状态变量（或数据结构如栈）来模拟这个过程。关键是识别出递归过程中哪些信息需要被“记住”和“恢复”。</p><p><strong>示例：<code>sum_digits</code> (计算数字各位之和)</strong></p><p>递归版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_digits_recursive</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:  <span class="comment"># 基本情况</span></span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 递归情况</span></span><br><span class="line">        all_but_last, last = split(n) <span class="comment"># 假设 split(n) 将 n 分为 n//10 和 n%10</span></span><br><span class="line">        <span class="comment"># A partial sum (last) + What&#x27;s left to sum (sum_digits_recursive(all_but_last))</span></span><br><span class="line">        <span class="keyword">return</span> sum_digits_recursive(all_but_last) + last</span><br></pre></td></tr></table></figure><p>迭代版本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_digits_iterative</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;</span></span><br><span class="line">    digit_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        digit_sum = digit_sum + (n % <span class="number">10</span>) <span class="comment"># 累加最后一位</span></span><br><span class="line">        n = n // <span class="number">10</span>                    <span class="comment"># 去掉最后一位</span></span><br><span class="line">    <span class="keyword">return</span> digit_sum</span><br></pre></td></tr></table></figure><p>转换思路：</p><ul><li>递归中的参数 <code>n</code> 和部分和（通过返回值和加法隐式管理）是状态。</li><li>迭代中使用 <code>digit_sum</code> 显式维护累加和，用 <code>n</code> 的变化来控制循环。</li></ul><h3 id="将迭代转换为递归-Converting-Iteration-to-Recursion"><a href="#将迭代转换为递归-Converting-Iteration-to-Recursion" class="headerlink" title="将迭代转换为递归 (Converting Iteration to Recursion)"></a>将迭代转换为递归 (Converting Iteration to Recursion)</h3><p>这通常更为公式化，因为迭代是递归的一种特殊情况（尾递归）。</p><p><strong>核心思想：迭代过程中的状态可以作为参数传递给递归函数。</strong></p><p><strong>示例：<code>sum_digits</code> (迭代转递归)</strong></p><p>迭代版本 (如上 <code>sum_digits_iterative(n)</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代版本回顾</span></span><br><span class="line"><span class="comment"># def sum_digits_iterative(n):</span></span><br><span class="line"><span class="comment">#     digit_sum = 0 # 状态变量: 当前数字的总和</span></span><br><span class="line"><span class="comment">#     while n &gt; 0:  # 循环条件</span></span><br><span class="line"><span class="comment">#         # 假设 split(n) 返回 n_prefix, last_digit</span></span><br><span class="line"><span class="comment">#         # 或者更常见的做法是:</span></span><br><span class="line"><span class="comment">#         last = n % 10</span></span><br><span class="line"><span class="comment">#         n = n // 10         # 更新状态变量 n</span></span><br><span class="line"><span class="comment">#         digit_sum = digit_sum + last # 更新状态变量 digit_sum</span></span><br><span class="line"><span class="comment">#     return digit_sum</span></span><br></pre></td></tr></table></figure><p>递归版本 (<code>sum_digits_rec</code>)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">sum_digits_rec</span>(<span class="params">n, digit_sum_so_far</span>): <span class="comment"># 状态 n 和 digit_sum_so_far 作为参数传入</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:  <span class="comment"># 基本情况：当 n 没有位数了</span></span><br><span class="line">        <span class="keyword">return</span> digit_sum_so_far</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 假设 split(n) 返回 n_prefix, last_digit</span></span><br><span class="line">        <span class="comment"># 或者更常见的做法是:</span></span><br><span class="line">        new_n = n // <span class="number">10</span></span><br><span class="line">        last = n % <span class="number">10</span></span><br><span class="line">        <span class="comment"># 递归调用，更新后的状态作为参数传递</span></span><br><span class="line">        <span class="keyword">return</span> sum_digits_rec(new_n, digit_sum_so_far + last)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始调用</span></span><br><span class="line"><span class="comment"># sum_digits_rec(original_n, 0)</span></span><br></pre></td></tr></table></figure><p>转换的关键步骤和理解：</p><ol><li><strong>识别状态变量</strong>：在迭代版本中，<code>n</code> 和 <code>digit_sum</code> 是在循环中不断变化的状态。</li><li><strong>将状态变量作为参数</strong>：在递归版本中，这些状态变量成为递归函数的参数。所以 <code>sum_digits_rec</code> 有两个参数 <code>n</code> 和 <code>digit_sum_so_far</code> (对应迭代中的 <code>digit_sum</code>)。</li><li>**基本情况 (Base Case)**：迭代的循环终止条件 (如 <code>while n &gt; 0</code> 的反面是 <code>n == 0</code>) 对应递归的基本情况。当 <code>n == 0</code> 时，说明所有位数都处理完了，递归结束，返回当前的 <code>digit_sum_so_far</code>。</li><li>**递归步骤 (Recursive Step)**：迭代循环体中的操作对应递归步骤。<ul><li>在迭代中，我们取 <code>last</code>，更新 <code>n</code>，更新 <code>digit_sum</code>。</li><li>在递归中，我们取 <code>last</code>，然后用更新后的 <code>n</code> (即 <code>new_n</code>) 和更新后的 <code>digit_sum_so_far</code> (即 <code>digit_sum_so_far + last</code>) 来进行下一次递归调用。</li></ul></li></ol><p><strong>老师想表达的意思总结：</strong></p><p>通过这两个方向的转换例子，老师想强调：</p><ol><li><strong>等价性</strong>：对于很多问题，递归和迭代是两种等价的解决思路，可以实现相同的功能。</li><li><strong>状态管理</strong>：<ul><li>迭代通过循环体内的变量赋值来更新和管理状态。</li><li>递归通过将状态作为函数参数传递，并在每次递归调用时传入更新后的状态。</li></ul></li><li><strong>转换思路</strong>：<ul><li><strong>递归转迭代</strong>：思考递归调用栈是如何工作的，尝试用循环和显式的栈（或几个变量）来模拟这个过程，关键是识别出递归过程中哪些信息需要被“记住”和“恢复”。</li><li><strong>迭代转递归</strong>：识别出迭代过程中随循环变化的核心状态变量，将这些变量作为递归函数的参数。循环的条件变为递归的终止条件，循环体内的操作变为递归调用时参数的更新。</li></ul></li></ol><p>“迭代是递归的特殊情况”的深层含义：任何一个循环都可以被看作是一个线性的、顺序的递归调用序列，其中每次递归调用的返回地址都是固定的（即回到循环的下一个迭代步骤）。而更广义的递归（比如树形递归）则没有这种严格的线性结构。尾递归因为其递归调用是最后一步，所以它可以被优化掉调用栈的开销，从而在行为上非常接近迭代。</p><h3 id="递归示例：swipe-n-先倒序再正序打印数字"><a href="#递归示例：swipe-n-先倒序再正序打印数字" class="headerlink" title="递归示例：swipe(n) - 先倒序再正序打印数字"></a>递归示例：<code>swipe(n)</code> - 先倒序再正序打印数字</h3><p>问题：编写一个函数 <code>swipe(n)</code>，它能先倒序打印数字 <code>n</code> 的各位，然后（如果 <code>n</code> 是多位数）再正序打印 <code>n</code> 的各位。中间的那个数字（如果是奇数位数）或最内层递归处理的数字（如果是偶数位数的基本情况）只打印一次。</p><p>例如 <code>swipe(2837)</code> 应打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">3</span><br><span class="line">7</span><br></pre></td></tr></table></figure><p><code>swipe(283)</code> 应打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>代码结构：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">swipe</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">10</span>:  <span class="comment"># 基本情况</span></span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">    <span class="keyword">else</span>:       <span class="comment"># 递归情况</span></span><br><span class="line">        <span class="built_in">print</span>(n % <span class="number">10</span>)      <span class="comment"># 1. 打印最后一位 (倒序部分)</span></span><br><span class="line">        swipe(n // <span class="number">10</span>)     <span class="comment"># 2. 对剩下的部分执行完整的 swipe 操作 (信任飞跃!)</span></span><br><span class="line">        <span class="built_in">print</span>(n % <span class="number">10</span>)      <span class="comment"># 3. 再次打印最后一位 (正序部分)</span></span><br></pre></td></tr></table></figure><p><strong>理解 <code>swipe(n)</code> 的执行（以 <code>swipe(283)</code> 为例）：</strong></p><ol><li><strong>调用 <code>swipe(283)</code></strong>:<ul><li><code>n = 283</code> (不是 <code>&lt; 10</code>)</li><li><code>print(283 % 10)</code>  &#x3D;&gt; 打印 <code>3</code></li><li><strong>调用 <code>swipe(283 // 10)</code> 即 <code>swipe(28)</code> (递归的信任飞跃)</strong><ul><li><strong>进入 <code>swipe(28)</code></strong>:<ul><li><code>n = 28</code> (不是 <code>&lt; 10</code>)</li><li><code>print(28 % 10)</code> &#x3D;&gt; 打印 <code>8</code></li><li><strong>调用 <code>swipe(28 // 10)</code> 即 <code>swipe(2)</code> (递归的信任飞跃)</strong><ul><li><strong>进入 <code>swipe(2)</code></strong>:<ul><li><code>n = 2</code> (是 <code>&lt; 10</code>)</li><li><code>print(2)</code> &#x3D;&gt; 打印 <code>2</code></li><li><code>swipe(2)</code> 执行完毕，返回到 <code>swipe(28)</code> 的调用点。</li></ul></li></ul></li><li><code>swipe(28)</code> 继续执行，<code>print(28 % 10)</code> &#x3D;&gt; 打印 <code>8</code></li><li><code>swipe(28)</code> 执行完毕，返回到 <code>swipe(283)</code> 的调用点。</li></ul></li></ul></li><li><code>swipe(283)</code> 继续执行，<code>print(283 % 10)</code> &#x3D;&gt; 打印 <code>3</code></li><li><code>swipe(283)</code> 执行完毕。</li></ul></li></ol><p>输出序列：<code>3</code> (来自 swipe(283)) -&gt; <code>8</code> (来自 swipe(28)) -&gt; <code>2</code> (来自 swipe(2)) -&gt; <code>8</code> (来自 swipe(28)) -&gt; <code>3</code> (来自 swipe(283))。</p><p><strong>为什么这个“信任”是合理的？</strong><br>因为递归最终会达到一个<strong>基本情况</strong> (<code>n &lt; 10</code>)，这个基本情况不需要进一步递归就能直接解决。</p><ul><li><code>swipe(283)</code> 信任 <code>swipe(28)</code></li><li><code>swipe(28)</code> 信任 <code>swipe(2)</code></li><li><code>swipe(2)</code> 是基本情况，直接 <code>print(2)</code>。<br>因为 <code>swipe(2)</code> 正确工作，所以 <code>swipe(28)</code> 对 <code>swipe(2)</code> 的信任得到回报。<code>swipe(28)</code> 利用 <code>swipe(2)</code> 的正确结果（打印 <code>2</code>），在它前后各打印一个 <code>8</code>，于是 <code>swipe(28)</code> 也正确工作了。<br>同理，因为 <code>swipe(28)</code> 正确工作，<code>swipe(283)</code> 对 <code>swipe(28)</code> 的信任也得到回报，最终 <code>swipe(283)</code> 也正确工作。</li></ul><h3 id="树形递归-Tree-Recursion"><a href="#树形递归-Tree-Recursion" class="headerlink" title="树形递归 (Tree Recursion)"></a>树形递归 (Tree Recursion)</h3><p>当一个函数在递归过程中进行多次自身调用时，就形成了树形递归。</p><p><strong>示例：<code>count_partitions(n, m)</code></strong></p><p>计算将正整数 <code>n</code> 分解成最大部分不超过 <code>m</code> 的不同正整数之和的方法数。<br>例如，<code>count_partitions(6, 4)</code> 表示将 6 分解成最大部分不超过 4 的和的方法数。<br>如 <code>2+4</code>, <code>1+1+4</code>, <code>3+3</code>, <code>1+2+3</code>, <code>1+1+1+3</code>, <code>2+2+2</code>, <code>1+1+2+2</code>, <code>1+1+1+1+2</code>, <code>1+1+1+1+1+1</code>。</p><p>递归分解思路：</p><ol><li>**使用至少一个 <code>m</code>**：如果使用 <code>m</code>，则问题转化为对 <code>n-m</code> 进行分解，最大部分仍不超过 <code>m</code>。即 <code>count_partitions(n-m, m)</code>。</li><li>**不使用任何 <code>m</code>**：如果不用 <code>m</code>，则问题转化为对 <code>n</code> 进行分解，但最大部分不超过 <code>m-1</code>。即 <code>count_partitions(n, m-1)</code>。</li></ol><p>总方法数 &#x3D; (使用 <code>m</code> 的方法数) + (不使用 <code>m</code> 的方法数)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_partitions</span>(<span class="params">n, m</span>):</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:      <span class="comment"># 基本情况1: n 已被完全分解</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> n &lt; <span class="number">0</span>:     <span class="comment"># 基本情况2: 无效分解 (n 减为负数)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> m == <span class="number">0</span>:    <span class="comment"># 基本情况3: 没有可用的部分了 (除非 n 也为0，上面已处理)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 递归情况:</span></span><br><span class="line">        with_m = count_partitions(n - m, m)  <span class="comment"># 使用当前最大部分 m</span></span><br><span class="line">        without_m = count_partitions(n, m - <span class="number">1</span>) <span class="comment"># 不使用当前最大部分 m</span></span><br><span class="line">        <span class="keyword">return</span> with_m + without_m</span><br></pre></td></tr></table></figure><p>树形递归通常涉及探索多种不同的选择路径。</p><h2 id="Python-数据结构"><a href="#Python-数据结构" class="headerlink" title="Python 数据结构"></a>Python 数据结构</h2><h3 id="序列-Sequences"><a href="#序列-Sequences" class="headerlink" title="序列 (Sequences)"></a>序列 (Sequences)</h3><p>列表 (list) 和字符串 (string) 都是 Python 中的序列类型。它们共享一些通用操作。</p><h4 id="数据类型的闭包性质-The-Closure-Property-of-Data-Types"><a href="#数据类型的闭包性质-The-Closure-Property-of-Data-Types" class="headerlink" title="数据类型的闭包性质 (The Closure Property of Data Types)"></a>数据类型的闭包性质 (The Closure Property of Data Types)</h4><p>一个组合数据值的方法如果满足闭包性质，意味着：<br><strong>组合的结果本身也可以用同样的方法进行组合。</strong></p><p>闭包性质非常强大，因为它允许我们创建层次结构。例如，列表可以包含其他列表作为元素，这些子列表本身又可以包含其他列表，以此类推，形成嵌套结构。<br><code>Lists can contain lists as elements (in addition to anything else)</code></p><h4 id="序列聚合-Sequence-Aggregation"><a href="#序列聚合-Sequence-Aggregation" class="headerlink" title="序列聚合 (Sequence Aggregation)"></a>序列聚合 (Sequence Aggregation)</h4><p>Python 提供了一些内置函数来对可迭代对象（包括序列）进行聚合操作：</p><ul><li><code>sum(iterable[, start]) -&gt; value</code>: 返回可迭代对象中所有数字（非字符串）的和，再加上可选的 <code>start</code> 值（默认为 0）。如果可迭代对象为空，返回 <code>start</code>。</li><li><code>max(iterable[, key=func]) -&gt; value</code> 或 <code>max(a, b, c, ... [, key=func]) -&gt; value</code>: 返回可迭代对象中最大的项，或多个参数中最大的一个。可选的 <code>key</code> 函数用于自定义比较。</li><li><code>all(iterable) -&gt; bool</code>: 如果可迭代对象中所有元素的布尔值为 <code>True</code>（或者可迭代对象为空），则返回 <code>True</code>。</li></ul><h3 id="列表-Lists"><a href="#列表-Lists" class="headerlink" title="列表 (Lists)"></a>列表 (Lists)</h3><p>列表是可变的、有序的元素集合。</p><h4 id="列表切片创建新值-Slicing-Creates-New-Values"><a href="#列表切片创建新值-Slicing-Creates-New-Values" class="headerlink" title="列表切片创建新值 (Slicing Creates New Values)"></a>列表切片创建新值 (Slicing Creates New Values)</h4><p>对列表进行切片操作会创建一个新的列表，其中包含原始列表中指定范围的元素的副本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">digits = [<span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">8</span>]</span><br><span class="line">start = digits[:<span class="number">1</span>]    <span class="comment"># start 会是 [1] (一个新列表)</span></span><br><span class="line">middle = digits[<span class="number">1</span>:<span class="number">3</span>]  <span class="comment"># middle 会是 [8, 2] (一个新列表)</span></span><br><span class="line">end = digits[<span class="number">2</span>:]      <span class="comment"># end 会是 [2, 8] (一个新列表)</span></span><br></pre></td></tr></table></figure><p>原始列表 <code>digits</code> 保持不变。<code>start</code>, <code>middle</code>, <code>end</code> 都是全新的列表对象。</p><h4 id="列表索引与拼接"><a href="#列表索引与拼接" class="headerlink" title="列表索引与拼接"></a>列表索引与拼接</h4><ul><li><strong>负索引</strong>：从列表末尾开始计数，最右边元素的索引是 <code>-1</code>。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nested_list = [<span class="number">1</span>, [<span class="literal">True</span>, [<span class="number">3</span>]]]</span><br><span class="line"><span class="built_in">print</span>(nested_list[-<span class="number">1</span>]) <span class="comment"># 输出: [True, [3]]</span></span><br></pre></td></tr></table></figure></li><li><strong>列表相加（拼接）</strong>：使用 <code>+</code> 运算符可以将两个或多个列表拼接起来，生成一个包含所有元素的新列表。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">list2 = [<span class="number">3</span>]</span><br><span class="line">list3 = [<span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">combined_list = list1 + list2 + list3</span><br><span class="line"><span class="built_in">print</span>(combined_list) <span class="comment"># 输出: [1, 2, 3, 4, 5] (这是一个新列表)</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="列表推导式-List-Comprehensions"><a href="#列表推导式-List-Comprehensions" class="headerlink" title="列表推导式 (List Comprehensions)"></a>列表推导式 (List Comprehensions)</h4><p>列表推导式提供了一种简洁的方式来创建列表。它通过描述列表中的元素来生成新的列表。</p><p>基本形式：<br><code>[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt;]</code></p><p>带条件的形式：<br><code>[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt; if &lt;condition&gt;]</code></p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">letters = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>]</span><br><span class="line"><span class="comment"># 根据索引列表 [3, 4, 6, 8] 从 letters 构建新列表</span></span><br><span class="line">selected_letters = [letters[i] <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]]</span><br><span class="line"><span class="built_in">print</span>(selected_letters) <span class="comment"># 输出: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;m&#x27;, &#x27;o&#x27;]</span></span><br><span class="line"></span><br><span class="line">odds = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">plus_one_to_odds = [x + <span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> odds]</span><br><span class="line"><span class="built_in">print</span>(plus_one_to_odds) <span class="comment"># 输出: [2, 4, 6, 8, 10]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 odds 中选出能被 25 整除的数 (即 25 % x == 0)</span></span><br><span class="line">divisible_by_25 = [x <span class="keyword">for</span> x <span class="keyword">in</span> odds <span class="keyword">if</span> <span class="number">25</span> % x == <span class="number">0</span>] <span class="comment"># 假设原意是 x 是 25 的因子</span></span><br><span class="line"><span class="built_in">print</span>(divisible_by_25) <span class="comment"># 输出: [1, 5]</span></span><br></pre></td></tr></table></figure><p>列表推导式中的 <code>if &lt;condition&gt;</code> 部分允许我们只选择序列中满足特定条件的元素来构建新列表。</p><h4 id="range-对象与-list"><a href="#range-对象与-list" class="headerlink" title="range 对象与 list"></a><code>range</code> 对象与 <code>list</code></h4><p>虽然 <code>range</code> 和 <code>list</code> 都是序列类型，但它们有所不同：</p><ul><li><code>range(n)</code> 生成一个表示从 0 到 <code>n-1</code> 的数字序列的对象，它不直接存储所有数字，而是按需生成，非常节省内存。<code>range</code> 包含 <code>start</code> 但不含 <code>end</code>。</li><li><code>list</code> 是一个实际存储所有元素的容器。<br>可以通过 <code>list()</code> 函数将 <code>range</code> 对象转换成列表：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">5</span>)) <span class="comment"># my_list 会是 [0, 1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串-Strings"><a href="#字符串-Strings" class="headerlink" title="字符串 (Strings)"></a>字符串 (Strings)</h3><p>字符串是不可变的字符序列。</p><h4 id="字符串作为序列"><a href="#字符串作为序列" class="headerlink" title="字符串作为序列"></a>字符串作为序列</h4><p>字符串也支持许多序列操作，如长度获取 (<code>len()</code>) 和元素选择（索引）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city = <span class="string">&#x27;Berkeley&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(city))    <span class="comment"># 输出: 8</span></span><br><span class="line"><span class="built_in">print</span>(city[<span class="number">3</span>])      <span class="comment"># 输出: &#x27;k&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：字符串的一个元素本身也是一个字符串，只是长度为1。例如 <code>city[3]</code> 的结果 <code>&#39;k&#39;</code> 仍然是字符串类型。</p><h4 id="in-和-not-in-运算符"><a href="#in-和-not-in-运算符" class="headerlink" title="in 和 not in 运算符"></a><code>in</code> 和 <code>not in</code> 运算符</h4><p>对于字符串，<code>in</code> 和 <code>not in</code> 运算符可以用来检查一个子字符串是否存在于另一个字符串中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;here&#x27;</span> <span class="keyword">in</span> <span class="string">&quot;Where&#x27;s Waldo?&quot;</span>)  <span class="comment"># 输出: True</span></span><br></pre></td></tr></table></figure><p>这与列表不同，在列表中 <code>in</code> 通常检查单个元素是否存在，而不是子序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">234</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])       <span class="comment"># 输出: False (234 不是列表中的一个元素)</span></span><br><span class="line"><span class="built_in">print</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>] <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]) <span class="comment"># 输出: False (列表 [2,3,4] 不是列表中的一个元素)</span></span><br></pre></td></tr></table></figure><p>总结：在列表中，你只能逐个元素查找。但在字符串中，你可以查找连续的子串。</p><h3 id="字典-Dictionaries"><a href="#字典-Dictionaries" class="headerlink" title="字典 (Dictionaries)"></a>字典 (Dictionaries)</h3><p>字典是键值对 (key-value pairs) 的集合，其中键必须是唯一的且不可变的。</p><h4 id="字典的基本操作与特性"><a href="#字典的基本操作与特性" class="headerlink" title="字典的基本操作与特性"></a>字典的基本操作与特性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;<span class="number">1</span>: <span class="string">&#x27;item&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(my_dict) <span class="comment"># 输出: &#123;1: &#x27;item&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 值可以是列表</span></span><br><span class="line">d = &#123;<span class="number">1</span>: [<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>], <span class="number">3</span>: <span class="string">&#x27;third&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d[<span class="number">1</span>])    <span class="comment"># 输出: [&#x27;first&#x27;, &#x27;second&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(d))  <span class="comment"># 输出: 2 (字典中有两个键值对)</span></span><br></pre></td></tr></table></figure><p><strong>如果想将一个键与多个值关联，应该使用一个序列（如列表）作为该键的值。</strong><br>例如，若想让键 <code>1</code> 关联到 ‘first’ 和 ‘second’，应该这样做：<code>&#123;1: [&#39;first&#39;, &#39;second&#39;]&#125;</code> 而不是尝试 <code>&#123;1: &#39;first&#39;, 1: &#39;second&#39;&#125;</code> (后者会导致键 <code>1</code> 的值被 ‘second’ 覆盖)。</p><h4 id="字典的限制-Limitations-on-Dictionaries"><a href="#字典的限制-Limitations-on-Dictionaries" class="headerlink" title="字典的限制 (Limitations on Dictionaries)"></a>字典的限制 (Limitations on Dictionaries)</h4><ol><li><strong>键的不可变性</strong>：字典的键不能是列表、字典或其他任何可变类型 (mutable type)。这是因为 Python 内部实现字典时，通常需要对键进行哈希计算。</li><li><strong>键的唯一性</strong>：字典中两个键不能相等。一个给定的键最多只能对应一个值。如果赋给已存在键一个新值，旧值会被覆盖。</li></ol><p>第一条限制与 Python 字典的底层实现有关。第二条限制是字典这种数据结构抽象的一部分。</p><h4 id="字典推导式-Dictionary-Comprehensions"><a href="#字典推导式-Dictionary-Comprehensions" class="headerlink" title="字典推导式 (Dictionary Comprehensions)"></a>字典推导式 (Dictionary Comprehensions)</h4><p>与列表推导式类似，字典推导式提供了一种简洁的方式来创建字典。</p><p>完整形式：<br><code>&#123;&lt;key_expression&gt;: &lt;value_expression&gt; for &lt;name&gt; in &lt;iterable_expression&gt; if &lt;filter_expression&gt;&#125;</code></p><p>简化形式 (无条件过滤)：<br><code>&#123;&lt;key_expression&gt;: &lt;value_expression&gt; for &lt;name&gt; in &lt;iterable_expression&gt;&#125;</code></p><p>字典推导式的求值过程：</p><ol><li>创建一个新的、以当前帧为父帧的帧。</li><li>创建一个空的结果字典，这个空字典将是整个表达式的值。</li><li>对于 <code>&lt;iterable_expression&gt;</code> 求值结果中的每一个元素：<br>A.  将 <code>&lt;name&gt;</code> 绑定到当前元素（在步骤1创建的新帧中）。<br>B.  如果存在 <code>&lt;filter_expression&gt;</code> 并且其求值为真 (True)：<br>将由 <code>&lt;key_expression&gt;</code> 求值结果作为键，<code>&lt;value_expression&gt;</code> 求值结果作为值的键值对，添加到结果字典中。</li></ol><h2 id="个人思考（来自草稿）"><a href="#个人思考（来自草稿）" class="headerlink" title="个人思考（来自草稿）"></a>个人思考（来自草稿）</h2><ul><li>“感觉树形递归总和分类相加有关”<ul><li>这个观察很敏锐！树形递归问题，如 <code>count_partitions</code>，通常将问题分解为几个子问题（树的分支），而原问题的解是这些子问题解的某种组合（常常是相加，如计数问题；或取最优，如优化问题）。每个分支代表一种分类或一种选择。</li></ul></li></ul><p>希望这份整理后的笔记对你有所帮助！<br>&#96;&#96;&#96;</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;欢迎来到本周的 CS61A 学习笔记！&lt;/p&gt;
&lt;p&gt;上周突然感觉学的东西太多容易忘记，于是开始随手把学到的重要东西记下来（或者截屏下来），在周末生成一篇笔记。&lt;/p&gt;</summary>
    
    
    
    <category term="学习笔记" scheme="https://stellogic.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CS61A" scheme="https://stellogic.github.io/tags/CS61A/"/>
    
    <category term="Python" scheme="https://stellogic.github.io/tags/Python/"/>
    
    <category term="递归" scheme="https://stellogic.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="迭代" scheme="https://stellogic.github.io/tags/%E8%BF%AD%E4%BB%A3/"/>
    
    <category term="数据结构" scheme="https://stellogic.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="编程概念" scheme="https://stellogic.github.io/tags/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://stellogic.github.io/2025/05/04/hello-world/"/>
    <id>https://stellogic.github.io/2025/05/04/hello-world/</id>
    <published>2025-05-04T04:46:00.000Z</published>
    <updated>2025-05-09T14:49:02.306Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo<i class="fas fa-external-link-alt"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation<i class="fas fa-external-link-alt"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting<i class="fas fa-external-link-alt"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub<i class="fas fa-external-link-alt"></i></a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing<i class="fas fa-external-link-alt"></i></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server<i class="fas fa-external-link-alt"></i></a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating<i class="fas fa-external-link-alt"></i></a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
    <summary type="html">这是我的第一篇 Hexo 博客文章！学习使用 Clexy 主题。</summary>
    
    
    
    
  </entry>
  
</feed>
