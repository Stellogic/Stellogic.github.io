[{"title":"CS61A 学习随笔（二）","url":"/2025/05/09/CS61A%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","content":"欢迎来到本周的 CS61A 学习笔记！\n上周突然感觉学的东西太多容易忘记，于是开始随手把学到的重要东西记下来（或者截屏下来），在周末生成一篇笔记。\n\n主要目的是方便我以后回顾，也期待和各位交流。发现错误可以联系我\n本次包括了从递归到容器（container）章节的，当然也有我写作业时发现的一些小问题。至于前面几章（也就是随笔一）是否会补上，随缘吧。\nPython 基础拾遗在深入具体主题之前，先回顾几个 Python 中常见但易混淆的基础点。\nprint() 输出与交互式解释器返回值\nprint() 输出：print() 函数的作用是显示对象转换成字符串后的内容。对于字符串对象，它通常不带引号，更侧重于“人类可读”的表示。\n交互式解释器显示的返回值：当你在 Python 交互式解释器（REPL）中输入一个表达式并执行后，解释器会显示该表达式的官方字符串表示形式，即调用对象的 repr() 方法得到的结果。对于字符串，这通常会带有引号，以明确表示其类型和精确值。\n\n赋值与求值顺序\n赋值顺序：Python 中的赋值操作遵循“先右后左”的原则。即先计算赋值符号（=）右边的表达式的值，然后将这个值绑定到左边的变量名上。\n**短路求值 (Short-circuiting)**：对于逻辑运算符 and 和 or，Python 会进行短路求值。\nA and B: 如果 A 为假，则整个表达式必为假，不会再评估 B。\nA or B: 如果 A 为真，则整个表达式必为真，不会再评估 B。显示的是最后被评估的那个操作数的值。\n\n\n\n帧 (Frame) 与环境在新帧 (frame) 中绑定的参数值来源于创建这个帧的那个环境。这一点对于理解闭包 (closures) 等高级概念至关重要。\n递归 (Recursion)递归是一种强大的编程技巧，函数通过调用自身来解决问题。\n递归函数的构成 (The Anatomy of a Recursive Function)一个典型的递归函数通常包含以下几个部分：\n\n**函数定义头部 (def语句)**：与普通函数类似，定义函数名和参数。\n**基本情况 (Base Cases)**：\n这是递归的终止条件。\n条件语句（如 if）用于检查是否达到基本情况。\n基本情况的求解不涉及进一步的递归调用，直接返回一个结果。\n\n\n**递归情况 (Recursive Cases)**：\n如果未达到基本情况，则进入递归情况。\n在递归情况中，问题会被分解成一个或多个规模更小但结构相同的子问题。\n函数会调用自身来解决这些子问题。\n通常会将子问题的解组合起来，形成原问题的解。\n\n\n\n迭代是递归的一种特殊情况 (Iteration is a special case of recursion)虽然我们通常感觉递归比迭代复杂，但从理论上讲，任何迭代过程都可以用特定形式的递归（通常是尾递归）来表达。\n递归的信任飞跃 (The Recursive Leap of Faith)理解和编写递归函数时，“递归的信任飞跃”是一个非常有用的思维模式。其核心思想是：\n相信你的函数能够正确处理规模更小的子问题。\n以阶乘函数 fact(n) 为例：n! = n * (n-1)! (当 n &gt; 0)0! = 1\ndef fact(n):    if n == 0:  # 基本情况        return 1    else:       # 递归情况        return n * fact(n-1) # 信任 fact(n-1) 能正确计算 (n-1)!\n\n验证 fact 是否正确实现：\n\n验证基本情况：当 n == 0 时，fact(0) 返回 1。这是正确的。\n将 fact 视为一个功能抽象：暂时不关心 fact 内部如何工作，只关心它的功能——计算阶乘。\n假设 fact(n-1) 是正确的：这是信任飞跃的核心。我们假设 fact(n-1) 能够完美地计算出 (n-1)! 的值。\n验证 fact(n) 在假设下的正确性：基于 fact(n-1) 返回 (n-1)! 的假设，fact(n) 返回 n * fact(n-1)，即 n * (n-1)!，这正是 n! 的定义。因此，fact(n) 是正确的。\n\n只要基本情况正确，并且递归步骤能正确地将问题规模缩小并最终达到基本情况，那么递归的信任就能得到回报。\n递归示例：Luhn 算法的部分求和Luhn 算法常用于验证信用卡号等识别码。以下是其求和部分的一个递归实现（假设 split(n) 函数可以将数字 n 分为 all_but_last 和 last 两部分，sum_digits(k) 计算数字 k 的各位数字之和）：\ndef luhn_sum(n):    if n &lt; 10:  # 基本情况        return n    else:       # 递归情况        all_but_last, last = split(n)        # 信任 luhn_sum_double 能正确处理 all_but_last        return luhn_sum_double(all_but_last) + lastdef luhn_sum_double(n):    all_but_last, last = split(n)    luhn_digit = sum_digits(2 * last) # 对末位加倍并求和    if n &lt; 10:  # 基本情况        return luhn_digit    else:       # 递归情况        # 信任 luhn_sum 能正确处理 all_but_last        return luhn_sum(all_but_last) + luhn_digit\n\n递归与迭代的转换递归和迭代在很多情况下可以相互转换。\n将递归转换为迭代 (Converting Recursion to Iteration)这通常需要思考递归调用栈是如何工作的，并尝试用循环和显式的状态变量（或数据结构如栈）来模拟这个过程。关键是识别出递归过程中哪些信息需要被“记住”和“恢复”。\n示例：sum_digits (计算数字各位之和)\n递归版本：\ndef sum_digits_recursive(n):    &quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;    if n &lt; 10:  # 基本情况        return n    else:       # 递归情况        all_but_last, last = split(n) # 假设 split(n) 将 n 分为 n//10 和 n%10        # A partial sum (last) + What&#x27;s left to sum (sum_digits_recursive(all_but_last))        return sum_digits_recursive(all_but_last) + last\n\n迭代版本：\ndef sum_digits_iterative(n):    &quot;&quot;&quot;Return the sum of the digits of positive integer n.&quot;&quot;&quot;    digit_sum = 0    while n &gt; 0:        digit_sum = digit_sum + (n % 10) # 累加最后一位        n = n // 10                    # 去掉最后一位    return digit_sum\n\n转换思路：\n\n递归中的参数 n 和部分和（通过返回值和加法隐式管理）是状态。\n迭代中使用 digit_sum 显式维护累加和，用 n 的变化来控制循环。\n\n将迭代转换为递归 (Converting Iteration to Recursion)这通常更为公式化，因为迭代是递归的一种特殊情况（尾递归）。\n核心思想：迭代过程中的状态可以作为参数传递给递归函数。\n示例：sum_digits (迭代转递归)\n迭代版本 (如上 sum_digits_iterative(n))：\n# 迭代版本回顾# def sum_digits_iterative(n):#     digit_sum = 0 # 状态变量: 当前数字的总和#     while n &gt; 0:  # 循环条件#         # 假设 split(n) 返回 n_prefix, last_digit#         # 或者更常见的做法是:#         last = n % 10#         n = n // 10         # 更新状态变量 n#         digit_sum = digit_sum + last # 更新状态变量 digit_sum#     return digit_sum\n\n递归版本 (sum_digits_rec)：\ndef sum_digits_rec(n, digit_sum_so_far): # 状态 n 和 digit_sum_so_far 作为参数传入    if n == 0:  # 基本情况：当 n 没有位数了        return digit_sum_so_far    else:        # 假设 split(n) 返回 n_prefix, last_digit        # 或者更常见的做法是:        new_n = n // 10        last = n % 10        # 递归调用，更新后的状态作为参数传递        return sum_digits_rec(new_n, digit_sum_so_far + last)# 初始调用# sum_digits_rec(original_n, 0)\n\n转换的关键步骤和理解：\n\n识别状态变量：在迭代版本中，n 和 digit_sum 是在循环中不断变化的状态。\n将状态变量作为参数：在递归版本中，这些状态变量成为递归函数的参数。所以 sum_digits_rec 有两个参数 n 和 digit_sum_so_far (对应迭代中的 digit_sum)。\n**基本情况 (Base Case)**：迭代的循环终止条件 (如 while n &gt; 0 的反面是 n == 0) 对应递归的基本情况。当 n == 0 时，说明所有位数都处理完了，递归结束，返回当前的 digit_sum_so_far。\n**递归步骤 (Recursive Step)**：迭代循环体中的操作对应递归步骤。\n在迭代中，我们取 last，更新 n，更新 digit_sum。\n在递归中，我们取 last，然后用更新后的 n (即 new_n) 和更新后的 digit_sum_so_far (即 digit_sum_so_far + last) 来进行下一次递归调用。\n\n\n\n老师想表达的意思总结：\n通过这两个方向的转换例子，老师想强调：\n\n等价性：对于很多问题，递归和迭代是两种等价的解决思路，可以实现相同的功能。\n状态管理：\n迭代通过循环体内的变量赋值来更新和管理状态。\n递归通过将状态作为函数参数传递，并在每次递归调用时传入更新后的状态。\n\n\n转换思路：\n递归转迭代：思考递归调用栈是如何工作的，尝试用循环和显式的栈（或几个变量）来模拟这个过程，关键是识别出递归过程中哪些信息需要被“记住”和“恢复”。\n迭代转递归：识别出迭代过程中随循环变化的核心状态变量，将这些变量作为递归函数的参数。循环的条件变为递归的终止条件，循环体内的操作变为递归调用时参数的更新。\n\n\n\n“迭代是递归的特殊情况”的深层含义：任何一个循环都可以被看作是一个线性的、顺序的递归调用序列，其中每次递归调用的返回地址都是固定的（即回到循环的下一个迭代步骤）。而更广义的递归（比如树形递归）则没有这种严格的线性结构。尾递归因为其递归调用是最后一步，所以它可以被优化掉调用栈的开销，从而在行为上非常接近迭代。\n递归示例：swipe(n) - 先倒序再正序打印数字问题：编写一个函数 swipe(n)，它能先倒序打印数字 n 的各位，然后（如果 n 是多位数）再正序打印 n 的各位。中间的那个数字（如果是奇数位数）或最内层递归处理的数字（如果是偶数位数的基本情况）只打印一次。\n例如 swipe(2837) 应打印：\n7382837\nswipe(283) 应打印：\n38283\n\n代码结构：\ndef swipe(n):    if n &lt; 10:  # 基本情况        print(n)    else:       # 递归情况        print(n % 10)      # 1. 打印最后一位 (倒序部分)        swipe(n // 10)     # 2. 对剩下的部分执行完整的 swipe 操作 (信任飞跃!)        print(n % 10)      # 3. 再次打印最后一位 (正序部分)\n\n理解 swipe(n) 的执行（以 swipe(283) 为例）：\n\n调用 swipe(283):\nn = 283 (不是 &lt; 10)\nprint(283 % 10)  &#x3D;&gt; 打印 3\n调用 swipe(283 // 10) 即 swipe(28) (递归的信任飞跃)\n进入 swipe(28):\nn = 28 (不是 &lt; 10)\nprint(28 % 10) &#x3D;&gt; 打印 8\n调用 swipe(28 // 10) 即 swipe(2) (递归的信任飞跃)\n进入 swipe(2):\nn = 2 (是 &lt; 10)\nprint(2) &#x3D;&gt; 打印 2\nswipe(2) 执行完毕，返回到 swipe(28) 的调用点。\n\n\n\n\nswipe(28) 继续执行，print(28 % 10) &#x3D;&gt; 打印 8\nswipe(28) 执行完毕，返回到 swipe(283) 的调用点。\n\n\n\n\nswipe(283) 继续执行，print(283 % 10) &#x3D;&gt; 打印 3\nswipe(283) 执行完毕。\n\n\n\n输出序列：3 (来自 swipe(283)) -&gt; 8 (来自 swipe(28)) -&gt; 2 (来自 swipe(2)) -&gt; 8 (来自 swipe(28)) -&gt; 3 (来自 swipe(283))。\n为什么这个“信任”是合理的？因为递归最终会达到一个基本情况 (n &lt; 10)，这个基本情况不需要进一步递归就能直接解决。\n\nswipe(283) 信任 swipe(28)\nswipe(28) 信任 swipe(2)\nswipe(2) 是基本情况，直接 print(2)。因为 swipe(2) 正确工作，所以 swipe(28) 对 swipe(2) 的信任得到回报。swipe(28) 利用 swipe(2) 的正确结果（打印 2），在它前后各打印一个 8，于是 swipe(28) 也正确工作了。同理，因为 swipe(28) 正确工作，swipe(283) 对 swipe(28) 的信任也得到回报，最终 swipe(283) 也正确工作。\n\n树形递归 (Tree Recursion)当一个函数在递归过程中进行多次自身调用时，就形成了树形递归。\n示例：count_partitions(n, m)\n计算将正整数 n 分解成最大部分不超过 m 的不同正整数之和的方法数。例如，count_partitions(6, 4) 表示将 6 分解成最大部分不超过 4 的和的方法数。如 2+4, 1+1+4, 3+3, 1+2+3, 1+1+1+3, 2+2+2, 1+1+2+2, 1+1+1+1+2, 1+1+1+1+1+1。\n递归分解思路：\n\n**使用至少一个 m**：如果使用 m，则问题转化为对 n-m 进行分解，最大部分仍不超过 m。即 count_partitions(n-m, m)。\n**不使用任何 m**：如果不用 m，则问题转化为对 n 进行分解，但最大部分不超过 m-1。即 count_partitions(n, m-1)。\n\n总方法数 &#x3D; (使用 m 的方法数) + (不使用 m 的方法数)。\ndef count_partitions(n, m):    if n == 0:      # 基本情况1: n 已被完全分解        return 1    elif n &lt; 0:     # 基本情况2: 无效分解 (n 减为负数)        return 0    elif m == 0:    # 基本情况3: 没有可用的部分了 (除非 n 也为0，上面已处理)        return 0    else:        # 递归情况:        with_m = count_partitions(n - m, m)  # 使用当前最大部分 m        without_m = count_partitions(n, m - 1) # 不使用当前最大部分 m        return with_m + without_m\n树形递归通常涉及探索多种不同的选择路径。\nPython 数据结构序列 (Sequences)列表 (list) 和字符串 (string) 都是 Python 中的序列类型。它们共享一些通用操作。\n数据类型的闭包性质 (The Closure Property of Data Types)一个组合数据值的方法如果满足闭包性质，意味着：组合的结果本身也可以用同样的方法进行组合。\n闭包性质非常强大，因为它允许我们创建层次结构。例如，列表可以包含其他列表作为元素，这些子列表本身又可以包含其他列表，以此类推，形成嵌套结构。Lists can contain lists as elements (in addition to anything else)\n序列聚合 (Sequence Aggregation)Python 提供了一些内置函数来对可迭代对象（包括序列）进行聚合操作：\n\nsum(iterable[, start]) -&gt; value: 返回可迭代对象中所有数字（非字符串）的和，再加上可选的 start 值（默认为 0）。如果可迭代对象为空，返回 start。\nmax(iterable[, key=func]) -&gt; value 或 max(a, b, c, ... [, key=func]) -&gt; value: 返回可迭代对象中最大的项，或多个参数中最大的一个。可选的 key 函数用于自定义比较。\nall(iterable) -&gt; bool: 如果可迭代对象中所有元素的布尔值为 True（或者可迭代对象为空），则返回 True。\n\n列表 (Lists)列表是可变的、有序的元素集合。\n列表切片创建新值 (Slicing Creates New Values)对列表进行切片操作会创建一个新的列表，其中包含原始列表中指定范围的元素的副本。\ndigits = [1, 8, 2, 8]start = digits[:1]    # start 会是 [1] (一个新列表)middle = digits[1:3]  # middle 会是 [8, 2] (一个新列表)end = digits[2:]      # end 会是 [2, 8] (一个新列表)\n原始列表 digits 保持不变。start, middle, end 都是全新的列表对象。\n列表索引与拼接\n负索引：从列表末尾开始计数，最右边元素的索引是 -1。nested_list = [1, [True, [3]]]print(nested_list[-1]) # 输出: [True, [3]]\n列表相加（拼接）：使用 + 运算符可以将两个或多个列表拼接起来，生成一个包含所有元素的新列表。list1 = [1, 2]list2 = [3]list3 = [4, 5]combined_list = list1 + list2 + list3print(combined_list) # 输出: [1, 2, 3, 4, 5] (这是一个新列表)\n\n列表推导式 (List Comprehensions)列表推导式提供了一种简洁的方式来创建列表。它通过描述列表中的元素来生成新的列表。\n基本形式：[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt;]\n带条件的形式：[&lt;expression&gt; for &lt;element&gt; in &lt;sequence&gt; if &lt;condition&gt;]\n示例：\nletters = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;]# 根据索引列表 [3, 4, 6, 8] 从 letters 构建新列表selected_letters = [letters[i] for i in [3, 4, 6, 8]]print(selected_letters) # 输出: [&#x27;d&#x27;, &#x27;e&#x27;, &#x27;m&#x27;, &#x27;o&#x27;]odds = [1, 3, 5, 7, 9]plus_one_to_odds = [x + 1 for x in odds]print(plus_one_to_odds) # 输出: [2, 4, 6, 8, 10]# 从 odds 中选出能被 25 整除的数 (即 25 % x == 0)divisible_by_25 = [x for x in odds if 25 % x == 0] # 假设原意是 x 是 25 的因子print(divisible_by_25) # 输出: [1, 5]\n列表推导式中的 if &lt;condition&gt; 部分允许我们只选择序列中满足特定条件的元素来构建新列表。\nrange 对象与 list虽然 range 和 list 都是序列类型，但它们有所不同：\n\nrange(n) 生成一个表示从 0 到 n-1 的数字序列的对象，它不直接存储所有数字，而是按需生成，非常节省内存。range 包含 start 但不含 end。\nlist 是一个实际存储所有元素的容器。可以通过 list() 函数将 range 对象转换成列表：my_list = list(range(5)) # my_list 会是 [0, 1, 2, 3, 4]\n\n字符串 (Strings)字符串是不可变的字符序列。\n字符串作为序列字符串也支持许多序列操作，如长度获取 (len()) 和元素选择（索引）：\ncity = &#x27;Berkeley&#x27;print(len(city))    # 输出: 8print(city[3])      # 输出: &#x27;k&#x27;\n注意：字符串的一个元素本身也是一个字符串，只是长度为1。例如 city[3] 的结果 &#39;k&#39; 仍然是字符串类型。\nin 和 not in 运算符对于字符串，in 和 not in 运算符可以用来检查一个子字符串是否存在于另一个字符串中：\nprint(&#x27;here&#x27; in &quot;Where&#x27;s Waldo?&quot;)  # 输出: True\n这与列表不同，在列表中 in 通常检查单个元素是否存在，而不是子序列。\nprint(234 in [1, 2, 3, 4, 5])       # 输出: False (234 不是列表中的一个元素)print([2, 3, 4] in [1, 2, 3, 4, 5]) # 输出: False (列表 [2,3,4] 不是列表中的一个元素)\n总结：在列表中，你只能逐个元素查找。但在字符串中，你可以查找连续的子串。\n字典 (Dictionaries)字典是键值对 (key-value pairs) 的集合，其中键必须是唯一的且不可变的。\n字典的基本操作与特性my_dict = &#123;1: &#x27;item&#x27;&#125;print(my_dict) # 输出: &#123;1: &#x27;item&#x27;&#125;# 值可以是列表d = &#123;1: [&#x27;first&#x27;, &#x27;second&#x27;], 3: &#x27;third&#x27;&#125;print(d[1])    # 输出: [&#x27;first&#x27;, &#x27;second&#x27;]print(len(d))  # 输出: 2 (字典中有两个键值对)\n如果想将一个键与多个值关联，应该使用一个序列（如列表）作为该键的值。例如，若想让键 1 关联到 ‘first’ 和 ‘second’，应该这样做：&#123;1: [&#39;first&#39;, &#39;second&#39;]&#125; 而不是尝试 &#123;1: &#39;first&#39;, 1: &#39;second&#39;&#125; (后者会导致键 1 的值被 ‘second’ 覆盖)。\n字典的限制 (Limitations on Dictionaries)\n键的不可变性：字典的键不能是列表、字典或其他任何可变类型 (mutable type)。这是因为 Python 内部实现字典时，通常需要对键进行哈希计算。\n键的唯一性：字典中两个键不能相等。一个给定的键最多只能对应一个值。如果赋给已存在键一个新值，旧值会被覆盖。\n\n第一条限制与 Python 字典的底层实现有关。第二条限制是字典这种数据结构抽象的一部分。\n字典推导式 (Dictionary Comprehensions)与列表推导式类似，字典推导式提供了一种简洁的方式来创建字典。\n完整形式：&#123;&lt;key_expression&gt;: &lt;value_expression&gt; for &lt;name&gt; in &lt;iterable_expression&gt; if &lt;filter_expression&gt;&#125;\n简化形式 (无条件过滤)：&#123;&lt;key_expression&gt;: &lt;value_expression&gt; for &lt;name&gt; in &lt;iterable_expression&gt;&#125;\n字典推导式的求值过程：\n\n创建一个新的、以当前帧为父帧的帧。\n创建一个空的结果字典，这个空字典将是整个表达式的值。\n对于 &lt;iterable_expression&gt; 求值结果中的每一个元素：A.  将 &lt;name&gt; 绑定到当前元素（在步骤1创建的新帧中）。B.  如果存在 &lt;filter_expression&gt; 并且其求值为真 (True)：将由 &lt;key_expression&gt; 求值结果作为键，&lt;value_expression&gt; 求值结果作为值的键值对，添加到结果字典中。\n\n个人思考（来自草稿）\n“感觉树形递归总和分类相加有关”\n这个观察很敏锐！树形递归问题，如 count_partitions，通常将问题分解为几个子问题（树的分支），而原问题的解是这些子问题解的某种组合（常常是相加，如计数问题；或取最优，如优化问题）。每个分支代表一种分类或一种选择。\n\n\n\n希望这份整理后的笔记对你有所帮助！&#96;&#96;&#96;\n","categories":["学习笔记"],"tags":["CS61A","Python","递归","迭代","数据结构","编程概念"]},{"title":"Hello World","url":"/2025/05/04/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n\n\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"分治","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB/","content":"定义和基本概念分治包括分和治两个阶段\n\n分：递归的将原问题划分为两个或者多个子问题，直到达到最小子问题\n治：从已知解的最小子问题开始，从低至顶将子问题的解进行合并，构建出原问题的解\n\n\n\n\n 总操作数是O(n + n^2&#x2F;2 + n) &#x3D; O(n^2&#x2F;2 + 2n)做差可证明只要n&gt;4分解后的操作数更小如果一直划分直到每个子数组只剩一个元素，即为归并排序如果设置多个划分点，原数组平均划分成k个子数组，即为桶排序2. 并行优化计算分治的子问题一般独立，可以并行解决，利于操作系统的并行优化  \n分治搜索O(logn)的搜索通常都使用了分治策略如二分查找  \n\n原问题可以分解：可以把原问题分解成在一半的子数组查找\n子问题独立：每轮处理一个子问题，不受其他子问题影响，当区间只剩一个元素或为空时，问题就变得足够简单，可以直接判断并求解。\n子问题无需合并：子问题解决意味着原问题解决下面是二分查找的递归实现，更能体现分治的特定/* 二分查找：问题 f(i, j) */int dfs(int[] nums, int target, int i, int j) &#123;    // 若区间为空，代表无目标元素，则返回 -1    if (i &gt; j) &#123;        return -1;    &#125;    // 计算中点索引 m    int m = (i + j) / 2;    if (nums[m] &lt; target) &#123;        // 递归子问题 f(m+1, j)        return dfs(nums, target, m + 1, j);    &#125; else if (nums[m] &gt; target) &#123;        // 递归子问题 f(i, m-1)        return dfs(nums, target, i, m - 1);    &#125; else &#123;        // 找到目标元素，返回其索引        return m;    &#125;&#125;/* 二分查找 */int binarySearch(int[] nums, int target) &#123;    int n = nums.length;    // 求解问题 f(0, n-1)    return dfs(nums, target, 0, n - 1);&#125;\n\n解决问题构建二叉树给定二叉树前序遍历preorder和中序遍历inorder,构建二叉树，并返回根节点例如preorder:[3,9,2,1,7]inorder:[9,3,1,2,7]\n\n分析\n\n能否分治\n\n问题可以分解：简单的可以划分为两个子问题。\n构建左子树\n构建右子树\n当然还要加上一个操作：初始化根节点。继续划分直到最小资问题（空子树）停止\n\n\n子问题是独立的：  左子树和右子树独立无交集。构建左子树只需要关心中序遍历和前序遍历对应的左子树部分。右子树也是  \n子问题可以合并：  得到了左子树和右子树（子问题的解），可以连接到根节点上，最终得到原问题的解\n\n\n如何划分子树  \n\n前序遍历：[根节点 | 左子树 | 右子树]\n中序节点：[左子树 | 根节点 | 右子树]\n\n\n一般化基于变量描述划分\n\n当前树根节点在preorder中的索引记为i\n当前树的根节点在inorder中的索引记为m\n当前树在inorder中的索引区间记为[l,r]\n\n 于是  \n\n\n\n\n根节点在preorder中的索引区间\n在inorder的索引区间\n\n\n\n当前树\ni\n[l,r]\n\n\n左子树\ni+1\n[l,m-1]\n\n\n右子树\ni+1+(m-l)\n[m+1,r]\n\n\n如下图：\n\n\n\n\n\n\n\n\n\n\n\n\n实现为了提高查询m的效率，使用哈希表存储inorder中元素到索引的映射。\nimport javax.swing.tree.TreeNode;TreeNode dfs(int[] preorder,Map&lt;Integer,Integer&gt; inorderMap,int i ,int l,int r)&#123;    //子树区间为空时终止    if(r - l &lt; 0)    &#123;        return null;    &#125;    TreeNode root = new TreeNode(preorder[i]);    // 查询当前根节点在中序遍历的索引m    int m = inorderMap.get(preorder[i]);    //子问题：构建左子树    root.left = dfs(preorder,inorderMap,i+1,l,m - 1);    //子问题：构建右子树    root.right = dfs(preorder,inorderMap,i+1+m-l,m+1,r);    return root;&#125;TreeNode buildTree(int[] preorder,int[] inorder)&#123;    //初始化哈希表存入inorder，元素为key，索引为value    Map&lt;Integer,Integer&gt; inorderMap = new  HashMap&lt;&gt;();    for(int i = 0;i &lt; inorder.length;i++)    &#123;        inorderMap.put(inorder[i],i);    &#125;    TreeNode root = dfs(preorder,inorderMap,0,0,inorder.length-1);    return root;&#125;\n\n时间复杂度：对于每个节点初始化一次，每个节点的操作都是O(1),因此总复杂度是O(N).点击看常见递归复杂度分析方法\n空间复杂度：O(n).哈希表O(n),递归调用栈在最差时树退化为链表成为O(n)\n\n汉诺塔问题给定三根柱子，记为 A、B 和 C 。起始状态下，柱子 A 上套着个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这个圆盘移到柱子 C 上，并保持它们的原有顺序不变（如图 12-10 所示）。在移动圆盘的过程中，需要遵守以下规则。\n\n圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入。\n每次只能移动一个圆盘。\n小圆盘必须时刻位于大圆盘之上。\n\n\n分析\n\n考虑基本情况f(1) 直接从a-&gt;c即可\nf(2)  \n最上方小圆盘a-&gt;b\n大圆盘a-&gt;c\n小圆盘b-&gt;c\n\n\nf(3)  \nb为目标，c为缓冲，两个小圆盘a-&gt;b(执行一个f(2))\n大圆盘a-&gt;c\nc为目标，a为缓冲，两个小圆盘b-&gt;c(执行一个f(2))\n\n\n把f(3)分解成了两个f(2)和一个f(1).这说明原问题是可以分解的，子问题是独立的，解决完子问题之后解可以合并\n\n\nf(n)可以分治  \nn-1个圆盘a-&gt;b，借助c\n1个圆盘a-&gt;c\nn-1个圆盘b-&gt;c，借助a \n\n\n\n\n实现\nimport java.util.List;/*移动一个圆盘*/void move(List&lt;Integer&gt; src, List&lt;Integer&gt; tar) &#123;    Integer pan = src.remove(src.size() - 1);    tar.add(pan);&#125;void dfs(int i, List&lt;Integer&gt; src,List&lt;Integer&gt; buf, List&lt;Integer&gt; tar)&#123;    /*如果src只剩一个圆盘直接移动接口*/    if(i == 1)    &#123;        move(src,tar);        return;    &#125;    //f(i-1),先把i-1个移动到buf    dfs(i - 1, src,tar,buf);    //f(1),移动最上面的大的    move(src,tar);    //f(i-1),buf的i-1个移动到tar    dfs(i - 1, buf,src,tar);&#125;void solveHanota(List&lt;Integer&gt; A,List&lt;Integer&gt; B, List&lt;Integer&gt; C)&#123;    int n = A.size();    dfs(n,A,B,C);&#125;\n\n时间复杂度：T(n) &#x3D; 2T(n-1) + O(1),不满足主定理的形式，画出递归树分析         T(n) -----O(1)的move操作    /    \\T(n-1)  T(n-1) -----O(2)的move                           \n  一共n+1层，每层操作数是2^(k),k属于[0,n]  最终和是1+2+4……+2^n,因此时间复杂度就是O(2^n)  也可以选择直接展开，或者通项\n空间复杂度：递归调用栈O(n)\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"全排列问题复杂度分析","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","content":"关于全排列问题的复杂度分析关键代码回顾为了方便对照，我们再看一下核心的剪枝逻辑：\n\n\n\n\n!selected[i]: 确保同一个位置的元素不会被重复使用（这是所有排列问题共有的）。\n!duplicated.contains(choice): 剪枝核心。确保在当前递归层级，对于数值相同的元素，只选择第一个未经访问的进行递归。\n\n\nnums = [1, 1, 2] 的递归树下面是 backtrack 函数为 [1, 1, 2] 生成全排列的递归树。树的每一层代表排列中的一个位置。\n                                      backtrack(state=[], choices=[1,1,2]，selected=[F,F,F])                                                    |                                                    | for i = 0..2                        +---------------------------+---------------------------+                        | i=0, choice=1             | i=1, choice=1             | i=2, choice=2                        | duplicated.add(1)         | duplicated.contains(1)?   | duplicated.add(2)                        |                           | --&gt; YES. PRUNED! (剪枝!)  |                        |                           | (在这一层，1已经用过了)     |                        V                           X                           V       backtrack(state=[1], choices=[1,1,2], selected=[T,F,F])      backtrack(state=[2], choices=[1,1,2], selected=[F,F,T])                        |                                                           |                        | for i = 0..2                                              | for i = 0..2    +-------------------+-------------------+                         +-------------+-------------+    | i=0, selected[0]? | i=1, choice=1     | i=2, choice=2           | i=0, choice=1 | i=1, choice=1 | i=2, selected[2]?    | --&gt; YES. Skip.    | duplicated.add(1) | duplicated.add(2)       | dup.add(1)    | dup.contains(1)?| --&gt; YES. Skip.    |                   |                   |                         |             | --&gt; YES. PRUNED!|    V                   V                   V                         V             X             Vbacktrack(state=[1,1],...)| backtrack(state=[1,2],...)|           backtrack(state=[2,1],...)    selected=[T,T,F]    |     selected=[T,F,T]    |               selected=[T,F,T]                        |                         |                               |                        | for i = 0..2            | for i = 0..2                  | for i = 0..2    +-------------------+     +-------------------+               +-------------------+    | i=0, selected? YES|     | i=0, selected? YES|               | i=0, selected? YES|    | i=1, selected? YES|     | i=1, choice=1     |               | i=1, choice=1     |    | i=2, choice=2     |     | i=2, selected? YES|               | i=2, selected? YES|    | state.size()==3   |     | state.size()==3   |               | state.size()==3   |    V                   V     V                   V               V                   V  res.add([1,1,2])    (backtrack) res.add([1,2,1]) (backtrack)   res.add([2,1,1])    (backtrack) \n\n\n\n\n\n树的解读：\n\n根节点 (第0层): state 为空。\n\nfor 循环开始，i=0，选择 nums[0] (值为1)。进入下一层递归。\ni=1，选择 nums[1] (值也为1)。但此时 duplicated 集合中已经包含了1，所以这个分支被剪掉了！这是避免重复排列的关键。\ni=2，选择 nums[2] (值为2)。进入下一层递归。\n\n\n第1层:\n\n左侧分支 (state&#x3D;):\nfor 循环遍历 [1,1,2]。nums[0] 已被选择 (selected[0]为true)，跳过。\ni=1，选择 nums[1] (值为1)。进入下一层。\ni=2，选择 nums[2] (值为2)。进入下一层。\n\n\n右侧分支 (state&#x3D;):\nfor 循环遍历 [1,1,2]。\ni=0，选择 nums[0] (值为1)。进入下一层。\ni=1，选择 nums[1] (值也为1)。但本层的 duplicated 集合已经有1了，剪枝！\ni=2 已被选择，跳过。\n\n\n\n\n叶子节点 (第3层):\n\n当 state 的长度达到3时，就找到了一个完整的排列。\n例如，从左侧分支一路下来，得到 [1, 1, 2]。这个排列被复制并添加到最终结果 res 中。\n然后函数返回（回溯），尝试其他可能性。\n\n\n\n\n从递归树分析复杂度1. 时间复杂度: O(n × n!)\n树的节点总数 (决定了 backtrack 函数被调用的次数):\n\n如果没有重复元素（例如 [1, 2, 3]），第0层有 n 个选择，第1层有 n-1 个选择，…，最后一层有1个选择。\n整棵树的节点总数大约是 n + n(n-1) + ... + n! ≈ O(n!)。\n虽然我们的剪枝策略砍掉了很多分支，但在进行复杂度分析时，我们通常考虑最坏情况，即所有元素都不同。因此，递归调用的总次数（即树的节点总数）是 O(n!) 级别的。\n\n\n每个节点内部的操作耗时:\n\n在树的非叶子节点，主要操作是 for 循环，它会执行 n 次。循环内部的操作（如 contains, add）是 O(1) 的。所以每个非叶子节点的时间开销是 O(n)。\n在树的叶子节点，当 state.size() == choices.length 时，会执行 res.add(new ArrayList&lt;Integer&gt;(state))。这个操作需要创建一个新列表并把 state 中的 n 个元素复制过去，时间开销是 **O(n)**。\n\n\n综合计算:\n\n算法的总时间主要由两部分构成：构建树的开销和在叶子节点复制结果的开销。\n叶子节点的数量就是最终不重复排列的数量，这个数量级是 O(n!)。\n仅仅是把所有叶子节点的结果复制到 res 列表中的总时间就是：**(叶子节点数量) × (每次复制的时间) ≈ O(n!) × O(n) &#x3D; O(n × n!)**。\n这个开销是算法时间复杂度的主要部分，因此总时间复杂度为 **O(n × n!)**。\n\n\n\n2. 空间复杂度: O($n^2$)空间复杂度我们看的是算法在任意时刻需要占用的最大辅助空间。\n\n递归调用栈的深度:\n\n从树的结构可以清晰地看到，从根节点到最深的叶子节点，路径的长度是 n。这意味着 backtrack 函数最多会嵌套调用 n 次。\n因此，递归调用栈所占用的空间是 **O(n)**。\n\n\n辅助数据结构:\n\nstate 列表：在递归过程中，它存储了当前的路径，其最大长度为 n。占用 O(n) 空间。\nselected 数组：长度始终为 n。占用 O(n) 空间。\nduplicated 集合：这个集合是在每个函数调用栈帧内创建的局部变量。因此，到最深时是1+2+3+……+n,是O(n^2)\n\n\n综合计算:\n\n因此，总的辅助空间复杂度是 O(n) + O(n) + O(n^2) &#x3D; **O(n^2)**。\n（注意：这不包括存储最终结果的 res 列表。如果算上它，空间复杂度将是 O(n × n!)）。\n\n\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"动态规划","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","content":"动态规划定义和概念将问题分解为一系列更小的子问题，并且通过储存子问题的解来避免重复计算，从而提高时间效率  \n\n\n\n\n与回溯、分治的区别：  \n\n分治递归的把原问题划分成多个独立的子问题直到最小问题，之后回溯中合并子问题的解得到原问题解\n动态规划也递归分解，但是动态规划的子问题是相互依赖的，会出现重叠子问题\n回溯算法在尝试和回退中穷举所有可能的解，并通过剪枝避免不必要的搜索分支。原问题的解由一系列决策步骤构成，我们可以将每个决策步骤之前的子序列看作一个子问题。\n\n特性\n最优子结构原问题的最优解是从子问题的最优解构建得来的\n无后效性给定一个确定的状态，它的未来发展只与当前状态有关，而与过去经历的所有状态无关就是说只依赖前序状态当前的已有的信息，但和前序状态时如何实现的无关\n\n问题判断总的来说，如果一个问题包含重叠子问题、最优子结构，并满足无后效性，那么它通常适合用动态规划求解。但实际上，很难直接判断，因此\n\n先观察问题是否适合使用回溯（穷举）解决（通常满足决策树模型，其中每一个节点代表一个决策，每一条路径代表一个决策序列。）\n之后看加分项和减分项  \n加分项：  \n问题包含最大（小）或最多（少）等最优化描述。\n问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其周围的状态存在递推关系。\n\n\n减分项：\n问题的目标是找出所有可能的解决方案，而不是找出最优解。\n问题描述中有明显的排列组合的特征，需要返回具体的多个方案。\n\n\n\n\n\n常规思路\n描述决策\n定义状态\n建立dp表\n推导状态转移方程\n确定边界条件\n\n状态：状态由所有决策变量构成。它应当包含描述解题进度的所有变量，其包含了足够的信息，能够用来推导出下一个状态。  \ndp表： 每个状态都对应一个子问题，我们会定义一个 dp表来存储所有子问题的解，状态的每个独立变量都是 dp表的一个维度。\n边界条件：边界条件在动态规划中用于初始化dp表，在搜索中用于剪枝。  \n状态转移方程： 递推公式  \n初始状态：（如1阶2阶）最小子问题的状态\n状态转移顺序的核心是要保证在计算当前问题的解时，所有它依赖的更小子问题的解都已经被正确地计算出来。\n其他\n不考虑时间的前提下，所有动态规划问题都可以用回溯（暴力搜索）进行求解，但递归树中存在大量的重叠子问题，效率极低。通过引入记忆化列表，可以存储所有计算过的子问题的解，从而保证重叠子问题只被计算一次。\n由于当前状态仅依赖某些局部状态，因此我们可以消除dp表的一个维度，从而降低空间复杂度。\n\n引入爬楼梯例题给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶，请问有多少种方案可以爬到楼顶？\n\n回溯穷举暴力：每轮除法上1阶或2阶，到达楼顶就方案数量加一，越过楼梯顶就剪枝\n /* 回溯 */void backtrack(List&lt;Integer&gt; choices, int state, int n, List&lt;Integer&gt; res) &#123;    // 当爬到第 n 阶时，方案数量加 1    if (state == n)        res.set(0, res.get(0) + 1);    // 遍历所有选择    for (Integer choice : choices) &#123;        // 剪枝：不允许越过第 n 阶        if (state + choice &gt; n)            continue;        // 尝试：做出选择，更新状态        backtrack(choices, state + choice, n, res);        // 回退    &#125;&#125;/* 爬楼梯：回溯 */int climbingStairsBacktrack(int n) &#123;    List&lt;Integer&gt; choices = Arrays.asList(1, 2); // 可选择向上爬 1 阶或 2 阶    int state = 0; // 从第 0 阶开始爬    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();    res.add(0); // 使用 res[0] 记录方案数量    backtrack(choices, state, n, res);    return res.get(0);&#125;\n暴力搜索  \n 得到一个结论dp[i] &#x3D; dp[i-1] + dp[i-2] 可以直接递归，和回溯都一样属于深度优先搜索  \n /* 搜索 */int dfs(int i) &#123;    // 已知 dp[1] 和 dp[2] ，返回之    if (i == 1 || i == 2)        return i;    // dp[i] = dp[i-1] + dp[i-2]    int count = dfs(i - 1) + dfs(i - 2);    return count;&#125;/* 爬楼梯：搜索 */int climbingStairsDFS(int n) &#123;    return dfs(n);&#125;\n  如图，递归树深度为n,时间复杂度为O(2^n)  \n 主要原因是有很多子问题重叠了，被重复计算了。  \n\n记忆化搜索我们期望所有重叠子问题只计算一次声明一个mem来记录每个子问题的解，搜索时重复子问题剪枝直接返回\n\n当首次计算dp[i]时，我们将其记录至 mem[i] ，以便之后使用。\n再次计算dp[i] 时，直接从mem[i]获取结果 /* 记忆化搜索 */int dfs(int i, int[] mem) &#123;    // 已知 dp[1] 和 dp[2] ，返回之    if (i == 1 || i == 2)        return i;    // 若存在记录 dp[i] ，则直接返回之    if (mem[i] != -1)        return mem[i];    // dp[i] = dp[i-1] + dp[i-2]    int count = dfs(i - 1, mem) + dfs(i - 2, mem);    // 记录 dp[i]    mem[i] = count;    return count;&#125;/* 爬楼梯：记忆化搜索 */int climbingStairsDFSMem(int n) &#123;    // mem[i] 记录爬到第 i 阶的方案总数，-1 代表无记录    int[] mem = new int[n + 1];    Arrays.fill(mem, -1);    return dfs(n, mem);&#125;\n\n 所有重叠子问题都只需计算一次，时间复杂度优化至 O(n)\n\n动态规划 记忆化搜索是从顶至底的方法 动态规划是从低至顶：从最小子问题的解开始，迭代构建更大子问题的解，直到得到原问题  \n /* 爬楼梯：动态规划 */int climbingStairsDP(int n) &#123;    if (n == 1 || n == 2)        return n;    // 初始化 dp 表，用于存储子问题的解    int[] dp = new int[n + 1];    // 初始状态：预设最小子问题的解    dp[1] = 1;    dp[2] = 2;    // 状态转移：从较小子问题逐步求解较大子问题    for (int i = 3; i &lt;= n; i++) &#123;        dp[i] = dp[i - 1] + dp[i - 2];    &#125;    return dp[n];&#125;\n 显然dp[i]只和dp[i-1]和dp[i-2]有关，因此不必使用dp储存所有子问题的解，利用两个变量滚动即可\n int climbingStairsDPComp(int n)&#123;    if(n == 1 || n == 2)    &#123;        return n;    &#125;    int a = 1,b = 2;    for(int i = 3;i&lt;n;i++)    &#123;        int temp = b;        b = a + b;        a = temp;        //每轮结束时，b就是第dp[i]    &#125;    return b;&#125;\n 空间复杂度降到O(1). 动态规划当前状态往往仅与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。这种空间优化技巧被称为“滚动变量”或“滚动数组”。\n\n\n更改爬楼梯问题说明最优子结构给定一个楼梯，你每步可以上 1阶或者 2阶，每一阶楼梯上都贴有一个非负整数，表示你在该台阶所需要付出的代价。给定一个非负整数数组 cost，其中 cost[i]表示在第 i个台阶需要付出的代价， cost[0]为地面（起始点）。请计算最少需要付出多少代价才能到达顶部？\n显然$dp[i] &#x3D; min(dp[i-1],dp[i-2]) + cost[i]$  \n也就是原问题的最优解是从子问题的最优解构建得来的。  \n实际上原来的爬楼梯问题如果换成问”最大方案数量”的等价问法，也相当于一种最优子结构  \n/* 爬楼梯最小代价：动态规划 */int minCostClimbingStairsDP(int[] cost) &#123;    int n = cost.length - 1;    if (n == 1 || n == 2)        return cost[n];    // 初始化 dp 表，用于存储子问题的解    int[] dp = new int[n + 1];    // 初始状态：预设最小子问题的解    dp[1] = cost[1];    dp[2] = cost[2];    // 状态转移：从较小子问题逐步求解较大子问题    for (int i = 3; i &lt;= n; i++) &#123;        dp[i] = Math.min(dp[i - 1], dp[i - 2]) + cost[i];    &#125;    return dp[n];&#125;\n这个dp[i]只由dp[i-1]和dp[i-2]决定，因此也可以两个变量滚动空间优化\nint minCostClimbingStairsDPComp(int[] cost)&#123;    int n = cost.length - 1;    if(n == 1|| n==2)    &#123;        return cost[n];    &#125;    int a = cost[1],b = cost[2];    for(int i = 3;i &lt;= n;i++)    &#123;        int temp = b;        b = Math.min(a,temp) + cost[i];        a = temp;        //b在每轮循环结束就是dp[i]    &#125;    return b;&#125;\n\n修改爬楼梯问题说明无后效性无后效性就是说，给定一个确定的状态，问题未来的发展只与当前状态有关，而与过去经历的所有状态无关。就是说只依赖前序状态当前的已有的信息，但和前序状态时如何实现的无关上面的爬楼梯问题都是这样。但如果加一个约束条件：给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶，但不能连续两轮跳 1阶，请问有多少种方案可以爬到楼顶？如果上一轮是跳1阶，下一轮必须跳2阶，意味着下一步选择不能有当前状态决定，还和前一个状态有关。但我们可以扩展状态的定义，状态[i,j]表示在第i阶，并且上一轮跳了j阶，j属于{1,2}。这样又满足了无后效性则有dp[i,j] &#x3D; dp[i,1] + dp[i,2] &#x3D; dp[i-1,2] + dp[i-2,1] + dp[i-2,2]\nint clim(int n)&#123;    if(n == 1 || n == 2)    &#123;        return 1;    &#125;    //初始化dp表    int[][]dp = new int[n+1][3];    dp[1][1] = 1;    dp[1][2] = 0;    dp[2][1] = 0;    dp[2][2] = 1;    //状态转移    for(int i = 3;i&lt;=n;i++)    &#123;        dp[i][1] = dp[i - 1][2];        dp[i][2] = dp[i-2][1]+dp[i-2][2];    &#125;    return dp[n][1]+dp[n][2];&#125;\n上面的可以通过扩展状态定义满足无后效性但是有时候会有无法做到给定一个共有 n阶的楼梯，你每步可以上 1阶或者 2阶。规定当爬到第 i阶时，系统自动会在第 2i阶上放上障碍物，之后所有轮都不允许跳到第 2i阶上。例如，前两轮分别跳到了第 2、3 阶上，则之后就不能跳到第 4、6 阶上。请问有多少种方案可以爬到楼顶？这个问题每次的跳跃都会影响未来的跳跃\n表格问题先判断问题能否回溯，之后根据加分减分可以尝试是否使用动态规划\n给定一个n*m的二维网格 grid ，网格中的每个单元格包含一个非负整数，表示该单元格的代价。机器人以左上角单元格为起始点，每次只能向下或者向右移动一步，直至到达右下角单元格。请返回从左上角到右下角的最小路径和。\n分析\n\n思考每轮决策，定义状态得到dp表  \n 本题每轮决策是从当前格子向下或者向右。因此状态应该包括行列索引两个变量，[i,j]  \n 状态[i,j]对应的子问题就是：从起点[0,0]走到[i,j]的最小代价路径和，记为dp[i,j]\n\n\n\n\n找出最优子结构进而推导状态转移方程 \n dp[i,j]&#x3D;min(dp[i-1,j],dp[i,j-1])+grid[i,j] (grid[i,j]是[i,j]处格点的代价)\n\n确定边界条件和状态转移顺序 \n 首行的状态只能由左边的状态得到，首列的状态只能由上班的状态得到。因此i&#x3D;0,j&#x3D;0就是边界条件\n 如图 14-13 所示，由于每个格子是由其左方格子和上方格子转移而来，因此我们使用循环来遍历矩阵，外循环遍历各行，内循环遍历各列。  这是为了保证计算当前解时，以来的更小子问题的解都被计算出来了\n\n\n实现因为子问题分解时从顶到底的思想，所以按照 暴力搜索、 记忆化搜索 、动态规划顺序展示\n\n暴力搜索\n/* 最小路径和：暴力搜索 */int minPathSumDFS(int[][] grid, int i, int j) &#123;    // 若为左上角单元格，则终止搜索    if (i == 0 &amp;&amp; j == 0) &#123;        return grid[0][0];    &#125;    // 若行列索引越界，则返回 +∞ 代价    if (i &lt; 0 || j &lt; 0) &#123;        return Integer.MAX_VALUE;    &#125;    // 计算从左上角到 (i-1, j) 和 (i, j-1) 的最小路径代价    int up = minPathSumDFS(grid, i - 1, j);    int left = minPathSumDFS(grid, i, j - 1);    // 返回从左上角到 (i, j) 的最小路径代价    return Math.min(left, up) + grid[i][j];&#125;\n每个状态都能向下和向右，从左上角到右下角需要m+n-2步，所以复杂度O(2^(m+n))\n\n记忆化搜索引入mem记忆列表记录子问题的解并对重叠子问题剪枝\n/* 最小路径和：记忆化搜索 */int minPathSumDFSMem(int[][] grid, int[][] mem, int i, int j) &#123;    // 若为左上角单元格，则终止搜索    if (i == 0 &amp;&amp; j == 0) &#123;        return grid[0][0];    &#125;    // 若行列索引越界，则返回 +∞ 代价    if (i &lt; 0 || j &lt; 0) &#123;        return Integer.MAX_VALUE;    &#125;    // 若已有记录，则直接返回    if (mem[i][j] != -1) &#123;        return mem[i][j];    &#125;    // 左边和上边单元格的最小路径代价    int up = minPathSumDFSMem(grid, mem, i - 1, j);    int left = minPathSumDFSMem(grid, mem, i, j - 1);    // 记录并返回左上角到 (i, j) 的最小路径代价    mem[i][j] = Math.min(left, up) + grid[i][j];    return mem[i][j];&#125;\n引入记忆后所有子问题的解只算一次，时间复杂度O(mn)\n\n动态规划\nint minPath(int[][] grid)&#123;    int n = grid.length,m = grid[0].length;//n是行数，m是列数    int[][] dp = new int[n][m];    dp[0][0] = grid[0][0];    //状态转移首行    for(int j = 1;j &lt; m;j++)    &#123;        dp[0][j] = dp[0][j - 1] + grid[0][j];    &#125;    //首列    for(int i = 1;i&lt;n;i++)    &#123;        dp[i][0] = dp[i-1][0]+grid[i][0];    &#125;    //其他行列    for(int i = 1;i&lt;n;i++)    &#123;        for(int j = 1;j&lt;m;j++)        &#123;            dp[i][j] = Math.min(dp[i][j-1],dp[i-1][j]) + grid[i][j];                    &#125;    &#125;    return dp[n-1][m-1];&#125;\n时间复杂度：O(mn),空间复杂度O(mn)(dp表)\n\n\n也可以空间优化，因为每个格子之和左边和上边的格子有关，因此可以只用一个单行数组实现dp表   （无法进一步优化，虽然对于每个格点只需要左侧和上方，左侧可以只用一个量，但是上方的对于每一行不同列的格点都不同，至少需要保存上面一整行）但，因为数组 dp 只能表示一行的状态，所以我们无法提前初始化首列状态，而是在遍历每行时更新它：\nint minPath(int[][] grid)&#123;    int n = grid.length,m = grid[0].length;    int[] dp = new int[m];    //状态转移:首行    dp[0] = grid[0][0];    for(int j = 1;j&lt;m;j++)    &#123;        dp[j] = dp[j - 1] + grid[0][j];    &#125;    //状态转移其余行    for(int i = 1;i&lt;n;i++)&#123;        //状态转移首列        dp[0] = dp[0] + grid[i][0];        //状态转移其他列        for(int j = 1;j&lt;m;j++)        &#123;            dp[j] = Math.min(dp[j-1],dp[j]) + grid[i][j];//dp[j-1]是已经被更新的左侧的，dp[j]被更新前是上面一行同列的元素        &#125;    &#125;    return dp[m-1];&#125;\n可以把空间复杂度降到O（m)\n0-1背包问题给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。\n这里物品编号从1开始所以i对于的wgt[i-1]\n可以看成n轮决策组成的过程，每个物体都有不放入和放入两种决策，满足决策树模型\n同时求的是最大价值，因此很可能能用动态规划\n\n思考每轮决策定义状态得到dp表\n 每个物品不放入背包，背包容量不变；放入背包容量减小。\n 定义状态：当前物品编号i和背包容量c。\n [i,c]对应子问题：前i个物品在容量为c的背包中的最大价值，记为dp[i,c]\n 待求解的是dp[n,cap]，需要一个（n+1）*(cap+1)的表\n\n找出最优子结构并推出状态转移方程\n 对i做决策时分为一下两种情况：\n\n不放入i,则dp[i,c] &#x3D; dp[i-1,c]\n放入i,则dp[i,c] &#x3D; dp[i-1,c-wgt[i-1]] + val[i-1]因此最终状态转移方程：dp[i,c] &#x3D; max(dp[i-1,c] , dp[i-1,c-wgt[i-1]] + val[i-1])\n\n\n确定边界条件和状态转移顺序\n\n边界：当物品或背包为0，最大价值为0.即为首行首列dp[i,0]和dp[0,c]为0\n每个其他dp都要由左上方的和正上方的两个状态确定，因此通过两层正循环遍历即可\n\n\n\n实现\n\n暴力搜索/* 0-1 背包：暴力搜索 */int knapsackDFS(int[] wgt, int[] val, int i, int c) &#123;    // 若已选完所有物品或背包无剩余容量，则返回价值 0    if (i == 0 || c == 0) &#123;        return 0;    &#125;    // 若超过背包容量，则只能选择不放入背包    if (wgt[i - 1] &gt; c) &#123;        return knapsackDFS(wgt, val, i - 1, c);    &#125;    // 计算不放入和放入物品 i 的最大价值    int no = knapsackDFS(wgt, val, i - 1, c);    int yes = knapsackDFS(wgt, val, i - 1, c - wgt[i - 1]) + val[i - 1];    // 返回两种方案中价值更大的那一个    return Math.max(no, yes);&#125;\n有很多重复\n记忆化搜索:借助记忆列表 mem 来记录子问题的解/* 0-1 背包：记忆化搜索 */int knapsackDFSMem(int[] wgt, int[] val, int[][] mem, int i, int c) &#123;    // 若已选完所有物品或背包无剩余容量，则返回价值 0    if (i == 0 || c == 0) &#123;        return 0;    &#125;    // 若已有记录，则直接返回    if (mem[i][c] != -1) &#123;        return mem[i][c];    &#125;    // 若超过背包容量，则只能选择不放入背包    if (wgt[i - 1] &gt; c) &#123;        return knapsackDFSMem(wgt, val, mem, i - 1, c);    &#125;    // 计算不放入和放入物品 i 的最大价值    int no = knapsackDFSMem(wgt, val, mem, i - 1, c);    int yes = knapsackDFSMem(wgt, val, mem, i - 1, c - wgt[i - 1]) + val[i - 1];    // 记录并返回两种方案中价值更大的那一个    mem[i][c] = Math.max(no, yes);    return mem[i][c];&#125;\n时间负载的取决于子问题的数量，也就是dp表的数量，降到了O(n*cap)\n动态规划int knapsackDP(int[] wgt,int[] val,int cap)&#123;    int n = wgt.length;    //初始化dp表    int[][] dp = new int[n+1][cap+1];    //状态转移    for(int i = 1;i &lt;= n;i++)    &#123;        for (int c = 1;c &lt;= cap;c++)        &#123;            if(wgt[i - 1] &gt; c)            &#123;                //如果超过背包容量，一定不选i                dp[i][c] = dp[i-1][c];            &#125;            else&#123;                dp[i][c] = Math.max(dp[i-1][c],dp[i-1][c - wgt[i-1]]+val[i-1]);            &#125;        &#125;    &#125;    return dp[n][cap];&#125;\n上面没有显示初始化首行首列，因为Java定义时直接所有元素为0\n\n时间复杂度空间复杂度都是O(n*cap)4. 空间优化每个状态只和上一行的状态(正上方左上方）有关，因此可以两个数组滚动前进。复杂度降低到O(n)还能继续降低，使用一个数组。但行序需要倒叙遍历因为，假设只有一个数组，开始遍历第i行时，该数组储存的还是i-1行的状态    1. 如果正序，遍历到dp[i,j]时，左上方的值已经被覆盖了    2. 如果倒叙，不存在覆盖问题（同一行代表同一元素，对应的背包容量缩减量相同）\nint knapsackDPComp(int[] wgt ,int[] val,int cap)&#123;    int n = wgt.length;    int[] dp = new int[cap + 1];    //状态转移    for(int i = i;i&lt;=n;i++)    &#123;        //倒叙遍历        for (int c =cap;c &gt;= 1;c--)        &#123;            if(wgt[i-1] &lt;= c)            &#123;                dp[c] = Math.max(dp[c],dp[c - wgt[i - 1] ]+ val[i-1]);                            &#125;        &#125;    &#125;    return dp[cap];&#125;\n\n完全背包问题给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品可以重复选取，问在限定背包容量下能放入物品的最大价值。\n\n思路：核心就是可以重复选取了状态[i,c]分为两种情况：\n不放入i：转移至[i-1,c]\n放入i：转移至[i,c-wgt[i-1]]状态方程  $dp[i, c] &#x3D; \\max(dp[i-1, c], dp[i, c - wgt[i-1]] + val[i-1])$\n\n\n\n/* 完全背包：动态规划 */int unboundedKnapsackDP(int[] wgt, int[] val, int cap) &#123;    int n = wgt.length;    // 初始化 dp 表    int[][] dp = new int[n + 1][cap + 1];    // 状态转移    for (int i = 1; i &lt;= n; i++) &#123;        for (int c = 1; c &lt;= cap; c++) &#123;            if (wgt[i - 1] &gt; c) &#123;                // 若超过背包容量，则不选物品 i                dp[i][c] = dp[i - 1][c];            &#125; else &#123;                // 不选和选物品 i 这两种方案的较大值                dp[i][c] = Math.max(dp[i - 1][c], dp[i][c - wgt[i - 1]] + val[i - 1]);            &#125;        &#125;    &#125;    return dp[n][cap];&#125;\n几乎一样，只是一处i-1变为i3. 空间优化   由于当前状态是从左边和上边的状态转移而来的，因此空间优化后应该对dp表中的每一行进行正序遍历。\n/* 完全背包：空间优化后的动态规划 */int unboundedKnapsackDPComp(int[] wgt, int[] val, int cap) &#123;    int n = wgt.length;    // 初始化 dp 表    int[] dp = new int[cap + 1];    // 状态转移    for (int i = 1; i &lt;= n; i++) &#123;        for (int c = 1; c &lt;= cap; c++) &#123;            if (wgt[i - 1] &gt; c) &#123;                // 若超过背包容量，则不选物品 i                dp[c] = dp[c];            &#125; else &#123;                // 不选和选物品 i 这两种方案的较大值                dp[c] = Math.max(dp[c], dp[c - wgt[i - 1]] + val[i - 1]);            &#125;        &#125;    &#125;    return dp[cap];&#125;\n零钱兑换问题一给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量，硬币面值至少为1。如果无法凑出目标金额，则返回 $-1$ \n\n可以看作完全背包的特殊情况\n物品对应硬币，重量对应面值，背包容量对应目标金额\n相反，这个要最小化硬币数量\n完全背包要求是不超过背包容量，零钱兑换要求是恰好\n\n\n思考每轮决策，定义状态得到dp表 [i,a]对应的子问题：前i种硬币能凑出金额a的最少硬币数量，记为dp[i,a] dp表(n+1)*(amt+1)\n找最优子结构状态转移方程dp[i,a] &#x3D; min(dp[i-1,a],dp[i,a-coins[i-1]] + 1)\n确定边界条件和转移顺序 目标金额为0，数量为0，即首列都为0 五硬币时，无法凑出，可以记为无限大，即首行都是无限大\n实现大多数语言没提供无限大，因此只能用整型int的最大值替代，但是这样+1操作可能溢出，因此采用amt+1表示无限，因为凑出amt的硬币最多就是amt（面值至少为1），返回前需要判断dp[n,amt]是否等于amt+1int coinChangeDP(int[] coins,int amt)&#123;    int n = coins.length;    int MAX = amt + 1;    //初始化dp表    int[][] dp = new int[n+1][amt+1];    //状态转移:首列行    for(int a = 1;a&lt;=amt;a++)    &#123;        dp[0][a] = MAX;    &#125;    //状态转移：其余列行    for(int i = 1;i &lt;= n;i++)    &#123;        for (int i = 1;i &lt;= n;i++)        &#123;            if(coins[i - 1] &gt; a)            &#123;                //超过目标金额，不选i                dp[i][a] = dp[i-1][a];            &#125;else&#123;                dp[i][a] = Math.min(dp[i - 1][a],dp[i][a - coins[i - 1]] + 1);                            &#125;        &#125;    &#125;    return dp[n][amt] != MAX ? dp[n][amt] : -1;&#125;\n空间优化\n\nimport java.util.Arrays;int coinChangeDPComp(int[] coins, int amt) &#123;    int n = coins.length;    int MAX = amt + 1;    int[] dp = new int[amt + 1];    Arrays.fill(dp,MAX);    dp[0] = 0;    for(int i = 1;i &lt;= n;i++)    &#123;        for(int a = 1;a &lt;= amt;a++)        &#123;            if(coins[i - 1] &gt; a)            &#123;                //如果超过目标金额，不选硬币                dp[a] = dp[a];            &#125;            else&#123;                dp[a] = Math.min(dp[a],dp[a - coins[i - 1] + 1]);            &#125;        &#125;    &#125;    return dp[amt] != MAX ? dp[amt] : -1;&#125;\n\n二给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问凑出目标金额的硬币组合数量。\n\n思路本题时求组合数量，因此子问题变为前i种硬币凑出金额a的组合数量，dp表尺寸依然是(n+1)*(amt+1)\n显然状态转移方程：dp[i, a] &#x3D; dp[i-1, a] + dp[i, a - coins[i-1]]\n 目标金额为0时，无需选择，因此dp[i,0]为1;没有硬币时组合数是0，即dp[0,a]为0\n\n实现\n/* 零钱兑换 II：动态规划 */int coinChangeIIDP(int[] coins, int amt) &#123;    int n = coins.length;    // 初始化 dp 表    int[][] dp = new int[n + 1][amt + 1];    // 初始化首列    for (int i = 0; i &lt;= n; i++) &#123;        dp[i][0] = 1;    &#125;    // 状态转移    for (int i = 1; i &lt;= n; i++) &#123;        for (int a = 1; a &lt;= amt; a++) &#123;            if (coins[i - 1] &gt; a) &#123;                // 若超过目标金额，则不选硬币 i                dp[i][a] = dp[i - 1][a];            &#125; else &#123;                // 不选和选硬币 i 这两种方案之和                dp[i][a] = dp[i - 1][a] + dp[i][a - coins[i - 1]];            &#125;        &#125;    &#125;    return dp[n][amt];&#125;\n优化空间\n/* 零钱兑换 II：空间优化后的动态规划 */int coinChangeIIDPComp(int[] coins, int amt) &#123;    int n = coins.length;    // 初始化 dp 表    int[] dp = new int[amt + 1];    dp[0] = 1;    // 状态转移    for (int i = 1; i &lt;= n; i++) &#123;        for (int a = 1; a &lt;= amt; a++) &#123;            if (coins[i - 1] &gt; a) &#123;                // 若超过目标金额，则不选硬币 i                dp[a] = dp[a];            &#125; else &#123;                // 不选和选硬币 i 这两种方案之和                dp[a] = dp[a] + dp[a - coins[i - 1]];            &#125;        &#125;    &#125;    return dp[amt];&#125;\n\n编辑距离问题（Levenshtein 距离）输入两个字符串 $s$ 和 $t$ ，返回将 $s$ 转换为 $t$ 所需的最少编辑步数。\n你可以在一个字符串中进行三种编辑操作：插入一个字符、删除一个字符、将字符替换为任意一个字符。\n\n思路分析可以看错决策树模型，字符串对应树节点，一轮决策（编辑操作）对应一条边。  如图，把hello转化成algo，从决策树的角度看，本题的目标是求解节点 hello 和节点 algo 之间的最短路径。\n思考每轮决策，定义状态得到dp表 每轮决策是对s进行一次编辑操作，希望编辑过程问题规模越来越小，这样方便构建子问题 设s，t长度分别n，m，先考虑尾部字符。  \n\n若s[n-1]和t[m-1]相同，可以跳过，考虑s[n-2]t[n-2]\n如果不同，对s进行一次操作（插入替换删除），使尾部字符相同，从而可以考虑更小规模的问题 也就是对s每次操作都会改变待匹配的字符。 定义状态[i,j]代表s，t当前考虑i，j字符对应子问题：将s的前i个字符更改为t的前j个字符所需的最小编辑步数，得到(i+1)*(j+1)的dp表\n\n\n最优子结构，状态转移方程问题dp[i,j]分为三种情况：\n\ns[i-1]后添加t[i-1]，则剩余子问题dp[i,j-1]\n删除s[i-1]，则剩余子问题dp[i-1,j]\n替换s[i-1]为t[i-1],剩余dp[i-1,j-1]\n特殊情况当s[i-1]和t[i-1]相同时，就是dp[i-1,j-1]\n\n 状态转移方程：dp[i,j] &#x3D; min(dp[i,j-1],dp[i-1,j],dp[i-1,j-1])+1 特殊情况：dp[i,j] &#x3D; dp[i-1,j-1]\n\n边界条件和状态转移顺序 两字符串都为空时，步数为0，即dp[0,0] &#x3D; 0 任意一个为空时，dp[0,j]和dp[i,0]分别为j，i dp[i,j]依赖左方，左上方，上方的解，因此正序循环即可\n\n\n\n\nint editDistanceDP(String s,String t)&#123;    int n = s.length(),m = t.length();    int[][] dp = new int[n+1][m+1];    //状态转移:首列首行    for (int i = 1;i &lt;= n;i++)    &#123;        dp[i][0] = i;    &#125;    for(int j = 1;j &lt;= m;j++)    &#123;        dp[0][j] = j;    &#125;    //状态转移：其他行列    for (int i = 1;i &lt;= n;i++)    &#123;        for(int j = 1;j&lt;=m;j++)        &#123;            if(s.charAt(i - 1) == t.charAt(j - 1))&#123;                dp[i][j] = dp[i - 1][j - 1];            &#125;else &#123;                dp[i][j] = Math.min(dp[i][j-1],dp[i-1][j],dp[i-1][j-1]) + 1;            &#125;        &#125;    &#125;    return dp[n][m];&#125;\n空间优化：dp[i,j]由上方，左方，左上方转移而来，正序遍历会丢失左上方，倒序遍历dp[i,j-1]无法构建，都不行但可以使用leftup暂存dp[i-1,j-1],从而可以正序遍历。\nint editDistanceDPComp(String s ,String t)&#123;    int n = s.length(),m = t.length();    int[] dp = new int[m + 1];    //状态转移：首行    for(int j = 1;j &lt;= m;j++)    &#123;        dp[j] = j;    &#125;    for(int i = 1;i &lt;= n;i++)    &#123;        int leftup = dp[0];//暂存dp[i-1,j-1]        dp[0] = i;        for(int j = 1;j &lt;= m;j++)        &#123;            int temp = dp[j];            if(s.charAt(i-1) == t.charAt(j - 1))&#123;                dp[i] = leftup;            &#125;else &#123;                dp[j] = Math.min(dp[j - 1],dp[j],leftup) + 1;            &#125;            leftup = temp;//dp[i-1][j-1] (左上方): 这是最棘手的部分。当我们准备计算 dp[j] 时，我们需要的 dp[i-1][j-1] 在哪里？它就是上一轮循环中 dp[j-1] 的旧值。但是，dp[j-1] 已经被更新为 dp[i][j-1] 了，它的旧值丢失了！在旧值被覆盖之前，把它保存下来        &#125;    &#125;    return dp[m];&#125;","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"回溯","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF/","content":"概念定义本质是穷举，核心思想是从一个初始状态除法，暴力搜索所有可能的解决方案，遇到正确的解记录，直到找到解或者尝试所有可能无法找到解经常使用深度优先搜索  \n\n\n复杂度分析见回溯复杂度分析.md\n尝试与回退经常使用这两个策略，遇到某个状态无法前进就撤销上一步选择例如，给定一棵二叉树，搜索并记录所有值为7的节点，请返回节点列表。\n/* 前序遍历：例题一 */void preOrder(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    if (root.val == 7) &#123;        // 记录解        res.add(root);    &#125;    preOrder(root.left);    preOrder(root.right);&#125;\n访问每个节点都表示尝试，越过叶节点return表示回退但回退不仅仅包括函数返回例，在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径。\n/* 前序遍历：例题二 */void preOrder(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    // 尝试    path.add(root); //path 需要在外部定义    if (root.val == 7) &#123;        // 记录解        res.add(new ArrayList&lt;&gt;(path));    &#125;    preOrder(root.left);    preOrder(root.right);    //回退，到最后遍历了root以及他的所有子节点也没找到，需要把root从path去掉    path.remove(path.size() - 1);    path.remove(path.size() - 1);&#125;\n这里我们信仰之越的契约是：相信preOrder能处理更小规模的子树，遍历子树的root以及所有节点，并把路径添加到res，让后穷举完所有结果后回退，把path回退到之前\n剪枝如果有约束条件可以尝试剪枝例，在二叉树中搜索所有值为7 的节点，请返回根节点到这些节点的路径，并要求路径中不包含值为3 的节点。我们需要添加剪枝操作，遇到值为3的节点则提前返回不再继续找\nimport javax.swing.tree.TreeNode;import java.util.ArrayList;void preOrder(TreeNode root) &#123;    //剪枝    if (root == null || root.val == 3) &#123;        return;    &#125;    //尝试    path.add(root);    if (root.val == 7) &#123;        //记录解        res.add(new ArrayList&lt;&gt;(path));    &#125;    //继续尝试左右边    preOrder(root.left);    preOrder(root.right);    //回退    path.remove(path.size() - 1);&#125;\n\n框架代码尝试-&gt;回退-&gt;剪枝state表示当前问题状态，choices表示当前状态下可做的选择\nimport javax.swing.plaf.nimbus.State;import java.awt.*;import java.util.List;void backtrack(State state, List&lt;Choices&gt; choices, List&lt;State&gt; res) &#123;    if (isSolution(state)) &#123;        recordSolution(state, res);        //如果找到一个解就可以结束则返回        return;    &#125;    //遍历所有选择    for (Choice choice : choices)    &#123;        //判断是否需要剪枝        if(isValid(state,choice))        &#123;            //尝试：做出选择，更新状态            makeChoice(state,choice);            //继续深入尝试            backtrack(state,choices,res);            //回退：撤销选择            undoChoice(state,choice);        &#125;    &#125;&#125;\n借助框架代码解决例题\nimport javax.swing.tree.TreeNode;import java.util.ArrayList;import java.util.Arrays;import java.util.List;boolean isSolution(List&lt;TreeNode&gt; state) &#123;    return !state.isEmpty() &amp;&amp; state.get(state.size() - 1).val == 7;&#125;void recordSolution(List&lt;TreeNode&gt; state, List&lt;List&lt;TreeNode&gt;&gt; res) &#123;    res.add(new ArrayList&lt;&gt;(state));&#125;boolean isValid(List&lt;TreeNode&gt; state, TreeNode choice) &#123;    return choice != null &amp;&amp; choice.val != 3;&#125;void makeChoice(List&lt;TreeNode&gt; state, TreeNode choice) &#123;    state.add(choice);&#125;void undoChoice(List&lt;TreeNode&gt; state, TreeNode choice) &#123;    state.remove(state.size() - 1);&#125;void backtrack(List&lt;TreeNode&gt; state, List&lt;TreeNode&gt; choices, List&lt;List&lt;TreeNode&gt;&gt; res) &#123;    if (isSolution(state)) &#123;        recordSolution(state, res);    &#125;    for (TreeNode choice : choices) &#123;        if (isValid(state, choice)) &#123;            makeChoice(state, choice);            backtrack(state, Arrays.asList(choice.left,choice.right),res);            undoChoice(state,choice);        &#125;    &#125;&#125;\n优点与局限本质是深度优先搜索，剪枝可以降低复杂度  \n复杂度： \n\n时间：遍历所有可能性，复杂度可能指数阶\n要保持当前状态（例如路径，剪枝的辅助变量）\n\n优化方式：  \n\n剪枝\n启发式搜索：引入策略或者估计值，优先搜索最有可能产生解的路径\n\n题目全排列问题输入一个整数数组，其中可能包含重复元素，返回所有可能的排列。   \n\n分析  \n\n可以使用回溯，把生成排列成一系列选择的结果。  \nchoices 就是输入数组所有元素\n\nstate 就是已经被选择的所有元素，并且唯一（当然值可能重复，但是选取的元素唯一）\n\n剪枝  \n\n重复选择剪枝：确保每个元素只被选择一次，引入selected，selected[i]表示choices[i]是否被选择\n相等元素剪枝： 可以引入一个哈希集合duplicated，标记尝试过的元素\n\n \n\n\n 两种剪枝的不同\n\n\n\n\n\n实现\n\n\nimport java.util.ArrayList;import java.util.HashSet;import java.util.List;void backtrack(List&lt;Integer&gt; state, int[] choices, boolean[] selected, List&lt;List&lt;Integer&gt;&gt; res) &#123;    // 当状态长度等于元素数量时记录,就是框架代码的issolution    if (state.size() == choices.length) &#123;        res.add(new ArrayList&lt;&gt;(state));        //需要 返回，不可能继续下去探索了        return;    &#125;    //遍历所有选择    Set&lt;Integer&gt; duplicated = new HashSet&lt;Integer&gt;();    for(int i = 0; i &lt; choices.length;i++) &#123;        int choice = choices[i];        //剪枝：不允许重复选择元素 且 不允许选择相等元素        //就是isValid        if (!selected[i] &amp;&amp; !duplicated.contains(choice))        &#123;            //尝试做出选择，相当于makeChoice            duplicated.add(choice); // 记录已经选择过的元素的值            selected[i] = true; //记录被选择过的元素本身（记录索引i就行其实）            state.add(choice);            //进行下一轮选择            backtrack(state,choices,selected,res);            //回退，相当于undoChoice            selected[i] = false;            state.remove(state.size() - 1);        &#125;    &#125;&#125;List&lt;List&lt;Integer&gt;&gt; permutations(int[] nums)&#123;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    backtrack(new ArrayList&lt;&gt;(),nums,new boolean[nums.length],res);    return res;&#125;\n\n复杂度：详见全排列问题复杂度分析.md\n时间复杂度：O(n * n!)\n空间复杂度: O(n^2)\n\n\n\n子集和问题无重复情况给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组无重复元素，每个元素可以被选取多次。请以列表形式返回这些组合，列表中不应包含重复组合。\n\n分析\n\n可以直接参考全排列问题。但集合元素可以无限次选取，因此不必借助selected\n /* 回溯算法：子集和 I */void backtrack(List&lt;Integer&gt; state, int target, int total, int[] choices, List&lt;List&lt;Integer&gt;&gt; res) &#123;    // 子集和等于 target 时，记录解    if (total == target) &#123;        res.add(new ArrayList&lt;&gt;(state));        return;    &#125;    // 遍历所有选择    for (int i = 0; i &lt; choices.length; i++) &#123;        // 剪枝：若子集和超过 target ，则跳过该选择        if (total + choices[i] &gt; target) &#123;            continue;        &#125;        // 尝试：做出选择，更新元素和 total        state.add(choices[i]);        // 进行下一轮选择        backtrack(state, target, total + choices[i], choices, res);        // 回退：撤销选择，恢复到之前的状态        state.remove(state.size() - 1);    &#125;&#125;/* 求解子集和 I（包含重复子集） */List&lt;List&lt;Integer&gt;&gt; subsetSumINaive(int[] nums, int target) &#123;    List&lt;Integer&gt; state = new ArrayList&lt;&gt;(); // 状态（子集）    int total = 0; // 子集和    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); // 结果列表（子集列表）    backtrack(state, target, total, nums, res);    return res;&#125;\n 但这样比如输入[3,4,5]和目标9，会输出[3,3,3] [4,5] [5,4],因为搜索过程的全排列是区分顺序的，但实际上的子集合是不区分顺序的，如图\n\n于是考虑剪枝  \n\n当第一轮选择[3,4]时会生成如[3,4……]这样的所有子集，\n之后第一轮选择4，第二轮如果选择3,就产生[4,3……],显然重复了，应当剪去\n\n 因为每一次都是从左向右尝试，因此越靠右侧剪掉的越多总之，只要让每次选择的元素索引$i_n,满足i_1&lt;&#x3D;i_2&lt;&#x3D;……&lt;&#x3D;i_n$,即可保证不重复，不满足的应当剪枝\n\n除此之外，还进行两个优化\n\n开启搜索前可以先把nums排序，这样遍历所有选择时，只要子集和超过target直接结束循环。因为后面元素更大，子集和一定超过target\n省去total，直接通过对target进行减法，total为0记录解实现\n\n\n\nimport java.util.ArrayList;import java.util.List;void backtrack(List&lt;Integer&gt; state, int target, in[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) &#123;    //子集和等于target时记录解    if (target == 0) &#123;        res.add(new ArrayList&lt;&gt;(state));        return;    &#125;    //遍历所有选择    //剪枝：从start开始遍历，防止生成重复子集    for (int i = start; i &lt; choices.length; i++) &#123;        //剪枝：如果子集和超过target，直接结束循环        //因为数组已经排序，小的尝试已经超过，后面大的没必要继续尝试        if (target - choices[i] &lt; 0) &#123;            break;        &#125;        // 尝试：做出选择，相当于makeChoice        state.add(choices[i]);        //继续探索,契约是相信backtrack能处理更小规模的问题，同时已经剪枝，在探索完后回退        backtrack(state, target - choices[i], choices, i, res);        //回退        state.remove(state.size() - 1);    &#125;&#125;List&lt;List&lt;Integer&gt;&gt; subsetSumI(int[] nums,int target)&#123;    List&lt;Integer&gt; state = new ArrayList&lt;&gt;();    Arrays.sort(nums);    int start = 0;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    backtrack(state,target,nums,start,res);    return res;&#125;\n\n时间复杂度： O(n^(target&#x2F;min))，详见回溯复杂度分析.md，实际上就是递归树的节点总数 * 每个节点的操作数\n空间复杂度: O(target)\n\n考虑重复元素给定一个正整数数组 nums 和一个目标正整数 target ，请找出所有可能的组合，使得组合中的元素和等于 target 。给定数组可能包含重复元素，每个元素只可被选择一次。请以列表形式返回这些组合，列表中不应包含重复组合。\n\n显然我们要进行向相等元素剪枝。由于数组是已排序的，因此相等元素都是相邻的。这意味着在某轮选择中，若当前元素与其左边元素相等，则说明它已经被选择过，因此直接跳过当前元素。\n每个元素只能选一次，也可以用start约束：选择$x_i后，下一轮直接从i+1开始遍历就行$\n\n实现\nimport java.util.ArrayList;import java.util.List;void backtrack(List&lt;Integer&gt; state, int target, int[] choices, int start, List&lt;List&lt;Integer&gt;&gt; res) &#123;    //isSolution    if (target == 0) &#123;        res.add(new ArrayList&lt;&gt;(state));        return;    &#125;    //遍历所有选择    //剪枝二：从start开始，避免重复子集    for(int i = start;i &lt; choices.length;i++)    &#123;        //剪枝1：子集和查过target，则直接结束        if(target - choices[i] &lt; 0)        &#123;            break;        &#125;        //剪枝四：如果元素和左边的相等，说明选取了想等元素跳过        if (i &gt; start &amp;&amp; choices[i] == choices[i-1])        &#123;            continue;        &#125;        //做出选择        state.add(choices[i]);        backtrack(state,target - choices[i],choices,i+1,res); // i+1相当于剪枝三：避免选择重复元素        //回退        state.remove(state.size() - 1);    &#125;&#125;List&lt;List&lt;Integer&gt;&gt; subsetSumII(int[] nums,int target)&#123;    List&lt;Integer&gt; state = new ArrayList&lt;&gt;();    Array.sort(nums);    int start = 0;    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    backtrack(state,target,nums,start,res);    return res;&#125;\n综合：\n时间复杂度（含输出）：O(n log n + 2^n + mL)。给出统一最坏上界可写成 O(n · 2^n)。辅助空间复杂度（不含结果集）：递归深度和当前路径 O(n)。若计入结果集，需再加 O(mL)。\n\n时间复杂度： 递归树最大深度是n，每层的选择是从n递减，但是每个路径深度不一定是n，可能提前结束。应该考虑每个元素都有两种可能，选择或者不选择，一共有$2^n$数量级个节点，每次遍历的操作量可以认为是O(1)(递归调用不算)，一共遍历了O(2^n)(因为要找到遍历所有可能所有节点)，复制解的操作，每次复制一个解的操作最差是O(n),最坏情况下可能几乎每个路径都有解，O(n2^n),因此最终就是O(n2^n) \n排序成本：Arrays.sort(nums) 是 O(n log n)。\n遍历成本（不算拷贝解）：回溯树中每个元素至多“选&#x2F;不选”，最坏节点数 O(2^n)。重复剪枝只降低常数，不改变指数级上界。所以遍历是 O(2^n)。\n输出成本（拷贝解）：每找到一个解要拷贝 O(L)（L 为解的长度，L ≤ n）。设解的个数为 m，则拷贝总成本 O(mL)。最坏情况下 m 可达 O(2^n)，于是 O(mL) ≤ O(n · 2^n)。\n因此总成本O(n*2^n)\n\n\n空间复杂度：调用栈O(N) + state O(n)最终就是O(N)\n\nn皇后问题根据国际象棋的规则，皇后可以攻击与同处一行、一列或一条斜线上的棋子。给定n 个皇后和一个 n*n大小的棋盘，寻找使得所有皇后之间无法相互攻击的摆放方案。     \n\nn*n 的棋盘有n^2个格子，就是choices。逐个放置皇后时每个每个时刻棋盘就是state\n考虑逐行放置：由于皇后数量和棋盘行数都是n，因此棋盘每行只允许放一个皇后。实际上也起到了剪枝的效果，避免同一行有多个皇后的所有搜索分支\n列和对角线剪枝  \n列：利用一个长度为n的布尔型数组cols记录每一列是否有皇后\n对角线，主对角线索引row - col为恒定值；次对角线row + col为恒定值。可以构造两个分别以行列和差的布尔数组代表每个对角线是否有皇后，长度2n-1\n\n\n\nimport java.util.ArrayList;import java.util.List;void backtrack(int row, int n, List&lt;List&lt;String&gt;&gt; state, List&lt;List&lt;List&lt;String&gt;&gt;&gt; res, boolean[] cols, boolean[] diags1, boolean[] diags2) &#123;    //isSolution,所有行放置完，记录解    if (row == n) &#123;        List&lt;List&lt;String&gt;&gt; copyState = new ArrayList&lt;&gt;();        for(List&lt;String&gt; sRow : state)        &#123;            copyState.add(new ArrayList&lt;&gt;(sRow));        &#125;        res.add(copyState);        return;    &#125;    //遍历所有的列    for(int col = 0;col &lt; n;col++)    &#123;        //计算格子对应的主对角线和次对角线        int diag1 = row - col + n -1;        int diag2 = row + col;        //剪枝：不允许列、对角线存在皇后        if( !col[col] &amp;&amp; !diags1[diag1] &amp;&amp; !diags2[diag2])        &#123;            //尝试:makechoice            state.get(row).set(col,&quot;Q&quot;);            cols[col] = diags1[diag1] = diags2[diag2] = false;            //继续放置            backtrack(row + 1,n,state,res,cols,diags1,diags1);            //回退            state.get(row).set(col,&quot;#&quot;);            cols[col] = diags1[diag1] = diags2[diag2] = false;        &#125;    &#125;&#125;List&lt;List&lt;List&lt;String&gt;&gt;&gt; nQueens(int n)&#123;    List&lt;List&lt;String&gt;&gt; state = new ArrayList&lt;&gt;();    for(int i = 0;i &lt; n;i++)    &#123;        List&lt;String&gt; row = new ArrayList&lt;&gt;();        for(int j = 0;j &lt; n;j++)&#123;            row.add(&quot;#&quot;);        &#125;        state.add(row);    &#125;    boolean[] cols = new boolean[n]; //记录列是否有皇后    boolean[] diags1 = new boolean[2*n-1];    boolean[] diags2 = new boolean[2*n-1];    backtrack(0,n,state,res,cols,diags1,diags2);    return res;&#125;\n\n\n时间复杂度：从第一行到最后一行依次有n,n-1……1个选择，递归树也就一共O(n!)个路径（或者说叶子节点）,复制添加操作O(n^2)，因此最终复杂度是O(n! +s* n^2)(s是解的数目)\n空间复杂度：\n递归深度 O(n)；三组布尔数组 O(n) 与 O(2n-1)。\n棋盘状态 state 为 n×n，O(n^2)。\n结果集存储占用 O(S·n^2)（按当前拷贝方式）。\n综合（不计输出）：O(n^2)；计入输出：O(n^2 + S·n^2)。\n\n\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"搜索","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%90%9C%E7%B4%A2/","content":"暴力搜索\n线性搜索：常用于数组链表等线性结构\n广度优先和深度优先：用于图树\n**优点是通用简单，无需预处理数据，也不需要额外的数据结构**\n时间复杂度O(N)\n\n\n\n自适应搜索二分查找用于数组，需要有序性。\n/* 二分查找（双闭区间） */int binarySearch(int[] nums, int target) &#123;    // 初始化双闭区间 [0, n-1] ，即 i, j 分别指向数组首元素、尾元素    int i = 0, j = nums.length - 1;    // 循环，当搜索区间为空时跳出（当 i &gt; j 时为空）    while (i &lt;= j) &#123;        int m = i + (j - i) / 2; // 计算中点索引 m        if (nums[m] &lt; target) // 此情况说明 target 在区间 [m+1, j] 中            i = m + 1;        else if (nums[m] &gt; target) // 此情况说明 target 在区间 [i, m-1] 中            j = m - 1;        else // 找到目标元素，返回其索引            return m;    &#125;    // 未找到目标元素，返回 -1    return -1;&#125;\n中点选取一般使用i+(j-i)&#x2F;2得到向下取整的(i+j)&#x2F;2,防止整数溢出\n还可以用于处理查找插入位置的问题\n给定一个长度为n的有序数组 nums 和一个元素 target ，数组可能存在重复元素。现将 target 插入数组 nums 中，并保持其有序性。若数组中已存在元素 target ，则插入到其左方。请返回插入后 target 在数组中的索引。\n\n/* 二分查找插入点（存在重复元素） */int binarySearchInsertion(int[] nums, int target) &#123;    int i = 0, j = nums.length - 1; // 初始化双闭区间 [0, n-1]    while (i &lt;= j) &#123;        int m = i + (j - i) / 2; // 计算中点索引 m        if (nums[m] &lt; target) &#123;            i = m + 1; // target 在区间 [m+1, j] 中        &#125; else if (nums[m] &gt; target) &#123;            j = m - 1; // target 在区间 [i, m-1] 中        &#125; else &#123;            j = m - 1; // 首个小于 target 的元素在区间 [i, m-1] 中        &#125;    &#125;    // 返回插入点 i    return i;&#125;\ni,j是循环不变量。i始终保持[0,i-1]处的元素小于targetj始终保持[j+1,length-1]处的元素大于等于target因此最终当j&gt;i时循环停止，i指向首个大于或者等于target的元素，也就是插入的位置\n查找左边界实际上和上面查找插入点类似，只是需要额外在不包含target时返回-1如果不包含target有两种结果\n\ni越界等于length\nnums[1] !&#x3D; target/* 二分查找最左一个 target */int binarySearchLeftEdge(int[] nums, int target) &#123;    // 等价于查找 target 的插入点    int i = binary_search_insertion.binarySearchInsertion(nums, target);    // 未找到 target ，返回 -1    if (i == nums.length || nums[i] != target) &#123;        return -1;    &#125;    // 找到 target ，返回索引 i    return i;&#125;\n\n查找右边界\n通用解法还是去替换nums[m] &#x3D;&#x3D; target情况下的指针操作\n\n此时把i = m+1\n\n这样，\n\n循环不变量i保持[0,i-1]的元素始终小于等于target\n\nj始终保持[j+1,length-1]元素大于target\n\n因此最终j指向从右侧起的第一个小于等于target的元素，如果恰好target存在，那么j即为右边界\n\n取巧方法（至少保证数据离散，下面默认数组只有整数）\n\n\n\n把查找最右边的target转化为查找最左边的target+1这样的话i - 1就是有边界，如果target存在的话\n查找最左边的 等价于 查找target-0.5,并返回i（i是第一个大于大于target-0.5的元素就是第一个target）\n查找最右边的 等价于 查找target+0.5，并返回j（j是从右边开始第一个小于等于target+0.5的，也就是最右边的target）\n\n使用哈希表优化两数之和问题给定一个整数数组 nums 和一个目标元素 target ，请在数组中搜索“和”为 target 的两个元素，并返回它们的数组索引。保证只有唯一一组解\n/* 方法一：暴力枚举 */int[] twoSumBruteForce(int[] nums, int target) &#123;    int size = nums.length;    // 两层循环，时间复杂度为 O(n^2)    for (int i = 0; i &lt; size - 1; i++) &#123;        for (int j = i + 1; j &lt; size; j++) &#123;            if (nums[i] + nums[j] == target)                return new int[] &#123; i, j &#125;;        &#125;    &#125;    return new int[0];&#125;\n上面暴力枚举，下面使用哈希表优化\n/* 方法二：辅助哈希表 */int[] twoSumHashTable(int[] nums, int target) &#123;    int size = nums.length;    // 辅助哈希表，空间复杂度为 O(n)    Map&lt;Integer, Integer&gt; dic = new HashMap&lt;&gt;();    // 单层循环，时间复杂度为 O(n)    for (int i = 0; i &lt; size; i++) &#123;        if (dic.containsKey(target - nums[i])) &#123;            return new int[] &#123; dic.get(target - nums[i]), i &#125;;        &#125;        dic.put(nums[i], i);    &#125;    return new int[0];&#125;\n把元素的值作为key，索引作为value。\n哈希查找：把搜索数据和目标数据建立为键值对映射\n树查找：对于指定的树搜索（比如二叉搜索树）\n复杂度总结\n\n\n\n\n线性搜索\n二分查找\n树查找（很多时候指的是二叉搜索树）\n哈希查找\n\n\n\n查找元素\nO(n)\nO(logn)\nO(logn)\nO(1)\n\n\n插入\nO(1),（实际上指的给数组链表插入，因为线性搜索不要求顺序因此可以直接插在动态数组末尾或者链表首部）\nO(n)，（有序，只能插入特定的位置）\nO（logn)\nO(1)\n\n\n删除特定元素\nO(n)（不管数组还是链表，都要先遍历到特定元素消耗一个O(n)）\nO(n)(注意链表一般不用二分搜索，因为无法以O(1)找到中点)\nO(logn)\nO(1)\n\n\n额外空间\nO(1)\nO(1)\nO(n)\nO(n)\n\n\n数据预处理\n\n排序O(nlogn)\n建树O(nlogn)\n建表O(n)\n\n\n数据是否有序\n无序\n有序\n有序\n无序\n\n\n复习一下树和哈希表\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"回溯复杂度分析","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","content":"回溯算法复杂度分析的核心思想分析回溯算法的时间复杂度，本质上是在分析其递归搜索树的规模。因为回溯算法在最坏情况下会遍历整个解空间树，所以其时间复杂度通常是指数级别或阶乘级别的。  \n\n\n\n其实就是递归复杂度分析.md中的递归树的方法\n一个通用的、简化的分析公式是：\n时间复杂度 ≈ 递归调用次数 × 每次递归中执行的操作数\n更精确地说，这可以分解为两个关键部分的分析：\n\n解空间树的节点总数：这代表了递归函数被调用的最多次数。\n每个节点上的操作耗时：这指的是在单次递归函数调用中，除了递归调用自身之外，其他操作（如循环、判断、添加结果等）所花费的时间。\n\n分析起来可能比较困难，但我们可以通过估算递归代码将计算多少个不同的状态，以及在每个递归调用中发生了多少次操作来进行估计。\n\n分析回溯算法复杂度的思考顺序遵循以下步骤，可以帮助你清晰、准确地分析出回溯算法的时间复杂度。\n第一步：画出（或想象出）递归搜索树这是最重要的一步。你需要明确算法的搜索过程是怎样的，这通常可以用一棵树来表示。\n\n树的宽度（分支因子）：在递归的每一层，你有多少种选择？这决定了每个节点有多少个子节点。\n树的深度：递归会进行多少层？这通常与输入数据的规模 n 相关。\n\n示例：\n\n全排列问题：对于 n 个不同的元素，第一层有 n 个选择，第二层有 n-1 个选择，以此类推。\n子集问题：对于 n 个元素，每个元素都有“选”和“不选”两种状态，所以每层都有 2 个分支。\n\n第二步：计算递归树的节点总数根据递归树的结构，估算树中节点的总数。这是复杂度的主要决定因素。\n\n**排列问题 (Permutations)**：\n\n输入 [1, 2, 3] 的递归树，第一层有3个节点，第二层每个节点下有2个分支，第三层有1个分支。叶子节点的数量是 3 * 2 * 1 = 3!。\n总的节点数大约是 n! 级别的。\n复杂度估算：通常为 **O(n!)**。\n\n\n**子集问题 (Subsets) &#x2F; 组合问题 (Combinations)**：\n\n对于 n 个元素，每个元素都有“选”与“不选”两种可能，因此解空间的大小是 2^n。\n递归树的深度为 n，节点总数是 1 + 2 + 4 + ... + 2^n，这是一个等比数列，总和约为 2^n。\n复杂度估算：通常为 **O(2^n)**。\n\n\n**N皇后问题 (N-Queens)**：\n\n第一行皇后有 N 个位置可选，第二行最多有 N-1 个，以此类推。\n虽然看起来是 N* (N-1) * ...，但由于剪枝（皇后间的攻击规则），实际搜索空间远小于 N^N，但大于 N!。不过在最坏情况下的上界分析中，通常近似为 **O(N!)**。\n\n\n**解数独 (Sudoku Solver)**：\n\n假设有 m 个空格需要填。每个空格最多有 9 种选择。\n复杂度估算：最坏情况下是 **O(9^m)**，其中 m 是待填空格的数量。\n\n\n\n第三步：分析单次递归调用的时间复杂度现在，看你的 backtrack 函数内部，除了递归调用 backtrack(...) 之外，还做了哪些操作？\n\n循环：函数内部是否有 for 循环？循环的次数是多少？\n例如，在全排列问题中，for 循环遍历所有选择，复杂度为 O(n)。\n在组合问题中，for 循环也可能遍历 O(n) 次。\n\n\n构造结果：当找到一个合法解时（通常在递归的叶子节点），需要将当前路径（path）复制一份并存入最终结果（result）中。\n如果路径的长度是 k，那么这个复制操作的耗时就是 O(k)。在很多问题中，路径的最大长度是 n，所以这里耗时 O(n)。\n\n\n\n第四步：整合计算，得出最终复杂度将前两步的结果相乘，并进行简化。\n\n**全排列问题 (Permutations of n distinct elements)**：\n\n节点总数（叶子节点）：n!\n到达每个叶子节点时，需要 O(n) 的时间复制路径。\n总时间复杂度：O(n * n!)。\n\n\n**子集问题 (Subsets of n elements)**：\n\n节点总数：2^n\n每个子集都需要被拷贝到结果列表中，平均长度为 O(n)。\n总时间复杂度：O(n * 2^n)。\n\n\n**组合问题 (Combinations - C(n, k))**：\n\n节点总数（叶子节点）：C(n, k)\n每个组合的长度是 k，复制耗时 O(k)。\n总时间复杂度：O(k * C(n, k))。\n\n\n\n第五步：考虑剪枝的影响回溯算法的精髓在于“剪枝”（Pruning），即提前终止那些不可能产生合法解的搜索路径。\n\n对于复杂度分析：通常我们分析的是最坏情况时间复杂度，此时可以不考虑剪枝带来的优化，或者只考虑那些非常明确、一定会发生的剪枝。\n剪枝的意义：虽然最坏时间复杂度可能不变，但剪枝能极大地优化算法在平均情况下的性能，使其能够处理更大规模的数据。例如，在N皇后问题中，剪枝是算法能够实际运行的关键。\n\n总结与范例\n\n\n问题类型\n递归树特点\n节点&#x2F;状态数\n单次操作耗时\n最终时间复杂度\n\n\n\n全排列\n深度为n，每层分支数递减 (n, n-1, …)\nO(n!)\nO(n) (复制结果)\nO(n * n!)\n\n\n子集\n深度为n，每层分支数为2\nO(2^n)\nO(n) (复制结果)\nO(n * 2^n)\n\n\n组合\n深度为k，分支数变化\nO(C(n, k))\nO(k) (复制结果)\nO(k * C(n, k))\n\n\nN皇后\n深度为N，分支数 &lt;&#x3D; N\nO(N!)\nO(N) 或 O(1) (检查合法性)\nO(N!)\n\n\n记住，分析回溯算法的复杂度不需要像数学推导那样百分之百精确，尤其是在面试中。关键是能够清晰地画出递归树模型，并基于模型估算出复杂度的量级，讲清楚你的分析思路。\n\n下面是子集和问题的复杂度分析详细分析过程第一步：画出（或想象出）递归搜索树这是理解算法行为的核心。我们以一个具体的例子来可视化这棵树：nums = [2, 3, 6], target = 7。\n                      ([], target=7, start=0)                     /           |           \\         (i=0, pick 2)     (i=1, pick 3)     (i=2, pick 6)                   /             |             \\      ([2], target=5, start=0)  ([3], target=4, start=1)  ([6], target=1, start=2)      /         |         \\           /         \\           \\(i=0, p 2) (i=1, p 3) (i=2, p 6) (i=1, p 3) (i=2, p 6)     (i=2, p 6) -&gt; Pruned (1-6&lt;0)    /           |         |           |         \\([2,2], t=3) ([2,3], t=2) ([2,6], t=-1) ([3,3], t=1) ([3,6], t=-2)   ...          ...       Pruned!       ...       Pruned!    |([2,2,3], t=0) -&gt; Found a solution!\n\n从这棵树中，我们可以观察到两个重要特性：\n\n树的宽度（分支数量）：在树的任意一个节点，它要向下递归的分支数量最多是 n 个（即 nums 数组的长度）。因为 for 循环从 start 开始，所以分支数会小于等于 n。\n树的深度：树的深度不是固定的 n。它取决于 target 的大小和 nums 中元素的大小。在最坏的情况下，如果我们每次都选择 nums 中最小的元素（假设 min_val），那么递归的最大深度将是 target / min_val。为了简化，我们称其深度为 D，其中 D 约等于 target。\n\n第二步：计算递归树的节点总数由于这不是一棵结构规整的 2^n 或 n! 树，精确计算节点数非常困难。但我们可以估算一个上界。\n\n**分支因子 (Branching Factor)**：最多为 n。\n**最大深度 (Max Depth)**：最多为 target / min_val。\n\n在不考虑任何剪枝的情况下，这棵树的节点总数可以粗略地估算为 **O(n^D)**，即 **O(n^(target&#x2F;min_val))**。\n这个估算虽然非常粗略，但它正确地指出了复杂度的关键：它对 target 的值是指数级的，对 n 也是指数级的。剪枝（target - choices[i] &lt; 0）会砍掉很多分支，但最坏情况下的复杂度量级依然是这个。\n第三步：分析单次递归调用的时间复杂度现在我们看 backtrack 函数内部做了什么（除了递归调用本身）：\n\nif (target == 0)：这是一个 O(1) 的判断。\nres.add(new ArrayList&lt;&gt;(state)): 这是一个关键操作。当找到一个解时，需要将当前的 state (路径) 复制一份放入结果集 res 中。如果 state 的长度是 k，这个复制操作的时间复杂度就是 O(k)。在我们的问题中，路径的最大长度 k 不会超过 target（因为 nums 里的都是正整数），所以这里的时间是 **O(target)**。\nfor 循环：for (int i = start; i &lt; choices.length; i++)。这个循环最多执行 n 次。\n循环内部：state.add() 和 state.remove() 通常可以看作是 O(1) 的操作。\n\n所以，在每个非叶子节点，主要耗时是 for 循环，为 O(n)。在每个作为解的叶子节点，主要耗时是复制结果，为 O(target)。\n第四步：整合计算，得出最终复杂度时间复杂度：\n时间复杂度主要由两部分构成：\n\n遍历整个搜索树的成本。\n找到解时，复制解的成本。\n\n综合来看，总的时间复杂度由搜索树的节点总数主导。\n\n总节点数：如上分析，约为 O(n^(target&#x2F;min_val))。\n每个节点的操作：主要是 O(n) 的循环。\n\n因此，一个比较宽松的上界是 节点数 * 每个节点的操作，但这并不精确。更通用的做法是直接用搜索空间的大小来表示复杂度。\n最终，该算法的时间复杂度被认为是 **O(n^(target&#x2F;min_val))**。这是一个比较标准的对这类问题的复杂度描述，它清晰地表达了算法性能与 n 和 target 的指数关系。\n空间复杂度：\n空间复杂度也由两部分构成：\n\n递归调用栈的深度：即我们递归树的最大深度。如前所述，最大深度是 D = target / min_val。所以这部分的复杂度是 **O(target)**。\n临时状态 state 的空间：state 列表存储了当前的组合路径，其最大长度也是递归的深度，所以也是 **O(target)**。\n\n因此，不包括存储最终结果 res 的空间，算法的辅助空间复杂度是 **O(target)**。\n\n总结对该“组合总和”问题的回溯算法复杂度分析如下：\n\n思考顺序：\n\n识别问题类型：意识到这是“组合总和”问题，元素可重复使用。\n构建递归树模型：确定树的宽度（分支数，n）和深度（target）。\n估算搜索空间：根据宽度和深度，估算出节点总数的量级为 O(n^target)。\n分析单点操作：找出函数内最耗时的操作，如循环（O(n)）和结果复制（O(target)）。\n整合复杂度：确定时间复杂度由搜索空间大小主导，即 O(n^target)。分析空间复杂度由递归深度主导，即 O(target)。\n\n\n最终结论：\n\n时间复杂度: **O(n^(target&#x2F;min_val))**。其中 n 是候选数字的个数，target 是目标和，min_val 是候选数字中的最小值。这个复杂度表示算法的性能在最坏情况下与 n 和 target 呈指数关系。\n空间复杂度: **O(target)**。这主要是由递归栈的深度和存储当前路径的临时列表所决定的（不计入存储所有结果所需的空间）。\n\n\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"贪心算法","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","content":"定义在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。\n\n\n\n和动态规划有相似，都依赖最优子结构，但原理不同：\n\n动态规划根据之前截断所有决策考虑当前决策，使用过去子问题的解构建当前子问题的解\n贪心不考虑过去的决策，一路向前进行贪心选择不断缩小问题范围\n\n优点和局限性\n优点：简单，效率高\n确定：没有证明的情况下无法保证一定找到正确答案\n\n适用\n可以保证找到最优解\n可以找到近似最优解（次优解，同时问题允许次优解）\n\n特性\n贪心选择性质： 只有局部最优始终可以全局最优，才能保证得到最优解\n最优子结构：原问题的最优解包含子问题的最优解\n\n解题步骤\n问题分析：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及\n确定贪心策略：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。\n正确性证明：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。\n\n例题引入给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 $-1$ 。\n这个题用动态规划可以严谨的解答，但我们尝试一下贪心\n可以贪心的选择不大于且最接近的硬币\n/* 零钱兑换：贪心 */int coinChangeGreedy(int[] coins, int amt) &#123;    // 假设 coins 列表有序    int i = coins.length - 1;    int count = 0;    // 循环进行贪心选择，直到无剩余金额    while (amt &gt; 0) &#123;        // 找到小于且最接近剩余金额的硬币        while (i &gt; 0 &amp;&amp; coins[i] &gt; amt) &#123;            i--;        &#125;        // 选择 coins[i]        amt -= coins[i];        count++;    &#125;    // 若未找到可行方案，则返回 -1    return amt == 0 ? count : -1;&#125;\n这个时间复杂度降低到了O(amt&#x2F;min(coins))但是某些组合不成立，比如[1,20,50].三个20才是最优解，贪心的结果会是50+1*10，一共十个硬币\n题目分数背包问题给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值。示例如下图所示。\n\n和0-1背包很像，装填包含当前物品i和容量c，目标是最大价值，但是这个允许选择物品的一部分\n\n可以引入单位重量的价值：val[i-1] &#x2F; wgt[i - 1]  \n\n贪心策略确定最大化背包内物品总价值，实际上本质就是最大化单位重量下的物品价值\n单位价值从低到高排序\n遍历，每轮贪心的选择单位价值最高的\n如果容量不足填入部分\n\n\n实现：可以先构造一个Item类\n\nimport java.awt.event.ItemEvent;import java.util.Arrays;import java.util.Comparator;class Item &#123;    int w;    int v;    public Item(int w, int v) &#123;        this.w = w;        this.v = v;    &#125;&#125;double fractionalKnapsack(int[] wgt, int[] val, int cap) &#123;    Item[] items = new Item[wgt.length];    for (int i = 0; i &lt; wgt.length; i++) &#123;        items[i] = new Item(wgt[i], val[i]);    &#125;    Arrays.sort(items, Comparator.comparingDouble(item -&gt; -((double)item.v/item.w)));    double res = 0;    for(Item item : items)    &#123;        if(item.w &lt;= cap)        &#123;            res += item.v;            cap -= item.w;        &#125;else &#123;            res += (double) item.v/ item.w * cap;            return ;        &#125;    &#125;    return res;&#125;\n时间复杂度O(nlogn),空间复杂度O(n)\n\n正确性证明反证法：\n\n核心思想：如果存在一个比贪心解更优的“最优解”，那么这个最优解一定可以通过“交换”，变得和贪心解更像，并且价值还能变得更高。但这与“最优解”的定义相矛盾。\n证明步骤：\n\n假设存在更优解：假设我们的贪心策略（永远优先装单位价值最高的物品）得到的解是 G。同时，假设存在一个不完全遵循此策略，但价值却比 G 更高的最优解，我们称之为 O。\n\n找到第一个分歧点：既然解 O 和解 G 不一样，那么必然存在某个物品，它们装入的重量不同。我们按单位价值从高到低检查所有物品，找到第一个 G 和 O 装入重量不同的物品，记为物品 i。\n\n根据贪心策略，G 会尽可能多地装入物品 i。因此，G 中物品 i 的重量必然大于 O 中物品 i 的重量。\n\n\n分析最优解 O 的构成：\n\n解 O 少装了单位价值较高的物品 i，但为了达到最优（甚至超过 G），它必然在某个单位价值更低的物品 j 上，装入了比 G 更多的重量。\n\n\n执行“替换”操作：\n\n现在我们来调整“最优解” O：从 O 中取出一小部分单位价值较低的物品 j，用等量的单位价值较高的物品 i 来替换。\n由于 O 中 j 有富余，i 有空缺，这个替换操作是完全可行的。\n\n\n得出矛盾：\n\n因为物品 i 的单位价值高于物品 j，这个替换操作在总重量不变的情况下，必然会使总价值增加。\n这意味着，我们刚刚把所谓的“最优解 O”变得更优了。这与 O 本身就是最优解的假设相矛盾！\n\n\n\n结论：因此，最初的假设（存在一个比贪心解更优的解）是错误的。贪心策略得到的解就是最优解。\n最大容量问题输入一个数组 $ht$ ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。\n容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差。\n请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。示例如下图所示。\n\n分析\n\n容器由任意两个隔板围城，因此本题状态就是两个隔板的索引，记为[i,j]\n容量等于短板高度×索引差。因此cap[i,j] &#x3D; min(ht[i],ht[j])*(j-i)。这个显然可以暴力遍历，时间复杂度O(n^2)\n贪心策略：  选取一个状态[i,j],满足索引i&lt;j,并且先暂定ht[i] &lt; ht[j] 如果此时将长板j向向短板i靠近，则容量一定会减小 因为，移动长板j后，宽度一定减小，但是高度由短板决定，高度只能不变或者变小。 所以能得到，想要容量变大必须向内收缩短板i，才有可能使容量变大。 可以得到贪心策略的执行过程： 1. 初始状态，i,j指针分列数组两端 2. 计算当前的cap[i,j] 3. 比较板i和j的高度，短板向内移动一格 4. 循环执行2.和3.，直到i和j相遇\n循环最多n轮，时间复杂度O(n),空间复杂度O(1) i,j,res,使用O(1)的空间int maxCapacity(int[] ht)&#123;    //初始化i，j    int i =0,j = ht.length-1;    int res = 0;    while (i &lt; j)&#123;        int cap = Math.min(ht[i],ht[j]) * (j - i);        res = Math.max(res,cap);        if(ht[i] &lt; ht[j])        &#123;            i++;        &#125;        else &#123;            j--;        &#125;    &#125;    return res;&#125;\n正确性证明：贪心比穷举快是因为每轮都会跳过一些状态，实际上跳过的就是长板向内移动的状态，这样前面已经说过容量肯定变小，因此被跳过的状态都不可能是最优解，跳过并不会导致错过最优解。\n\n最大切分城际问题给定一个正整数 $n$ ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少。\n\n贪心策略  \n\n假设从n分出一个2，2(n-2)在n&gt;&#x3D;4时一定大于n，说明n大于等于4时，切分出一个2后乘积变大，说明大于等于4的整数都应该切分，最终因子只剩1,2,3\n接下来，看看1，2，3因子哪个最优。显然1最差，1*(n-1)必定乘积减小，1应该和其他因子合并；当n &#x3D; 6时，33&gt;22*2，意味着如果由3个二应当合并成两个3\n\n 因此最终，\n\n输入整数n，不断切分因子3直到剩余余数0，1，2\n余数为0不必处理\n余数为2，不继续划分保留\n余数为1，由于22&gt;13，将最后一个3换成2\n\n\n实现不必循环切分，直接整除3得3的个数，对3取模得余数，不过当n&lt;&#x3D;3时必须拆分一个1，乘积为1*(n-2)\nint maxProductCutting(int n)&#123;    if(n &lt;= 3)    &#123;        return 1*(n-1);    &#125;    int a = n/3;    int b = n%3;    if(b == 1)&#123;        return (int)Math.pow(3,a-1)*2*2;    &#125;    if(b == 2)    &#123;        return (int)Math.pow(3,a)*2;    &#125;    return (int)Math.pow(3,1);&#125;\n\n正确性证明：反证法，分析n&gt;&#x3D;4：\n\n所有因子&lt;&#x3D;3:假设存在大于等于4的因子x，一定能进一步分为2(x-2)，从而获得更大或者相等的乘积\n不包含1：假设包含1，1可以融合进其他因子，可以获得更大的乘积\n做多包含两个2：如果有3个2，一定可以替换成两个3.\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"排序","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","content":"评价维度\n运行效率（时间复杂度，还有常数项也尽可能小）\n就地性（原地排序再原数组直接操作不必借助辅助数组，节省内存）\n稳定性（排序前后相等元素相对位置不变）\n自适应性（利用输入数据的信息减少计算量，达到更优）\n是否基于比较（基于比较的依赖于”&gt;,&lt;,&#x3D;”,理论最优时间复杂度是(O(nlogn)；非比较排序不用比较运算符，速度快但通用性差)\n**目前没有发现上面所有都好的算法**\n\n\n\n选择排序/* 选择排序 */void selectionSort(int[] nums) &#123;    int n = nums.length;    // 外循环：未排序区间为 [i, n-1]    for (int i = 0; i &lt; n - 1; i++) &#123;        // 内循环：找到未排序区间内的最小元素        int k = i;        for (int j = i + 1; j &lt; n; j++) &#123;            if (nums[j] &lt; nums[k])                k = j; // 记录最小元素的索引        &#125;        // 将该最小元素与未排序区间的首个元素交换        int temp = nums[i];        nums[i] = nums[k];        nums[k] = temp;    &#125;&#125;\n特点：\n\n时间复杂度O(n方)，非自适应。(n-1)到2求和\n空间复杂度O(1),原地排序。\n非稳定性排序\n\n冒泡/* 冒泡排序（标志优化） */void bubbleSortWithFlag(int[] nums) &#123;    // 外循环：未排序区间为 [0, i]    for (int i = nums.length - 1; i &gt; 0; i--) &#123;        boolean flag = false; // 初始化标志位        // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端        for (int j = 0; j &lt; i; j++) &#123;            if (nums[j] &gt; nums[j + 1]) &#123;                // 交换 nums[j] 与 nums[j + 1]                int tmp = nums[j];                nums[j] = nums[j + 1];                nums[j + 1] = tmp;                flag = true; // 记录交换元素            &#125;        &#125;        if (!flag)            break; // 此轮“冒泡”未交换任何元素，直接跳出    &#125;&#125;\n\n时间复杂度O(n*n),优化后是自适应排序。(n-1)到1求和\n空间复杂度O(1)，原地排序\n稳定性排序\n\n插入排序类似整理扑克牌，从未排序区间选一个基准元素，把ta和左侧已排序区间逐一比较并插入到正确地方\n/* 插入排序 从小到大*/void insertionSort(int[] nums) &#123;    //外循环，已经排序的区间是[0,i-1]    for (int i = 1;i&lt; nums.length;i++)    &#123;        int base = nums[i],j = i - 1;        //把base插入已排序区间的合适位置        while(j &gt;= 0 &amp;&amp; nums[j] &gt; base)        &#123;            /*           把比base大的元素都向右移动，           因为我们已经存取了索引为i的元素为base，所以不必担心覆盖             */            nums[j+1] = nums[j];            j--;        &#125;        //循环结束时，j索引一定是第一个不大于base的元素        //原本的j+1索引的元素是第一个大于base的元素，已经向右移动了        //因此直接插入在j+1即可        nums[j + 1] = base;    &#125;&#125;\n\n时间复杂度O(n*n),自适应性。1加到(n-1)。遇到有序数组时，内循环（插入操作）会提前终止，达到最佳复杂度O(n).\n空间复杂度O(1),原地排序。\n稳定排序。插入时我们插入在相等元素右侧。\n\n虽然复杂度是O(n*n),但数据量小时可能比快排更快\n实践中插入排序使用频率高于冒泡和选择\n冒泡： 基于元素交换，涉及3个单元操作，插入排序基于元素赋值，只需要一个单元操作\n选择： 不自适应，任何时候都是O(n*n),\n\n快速排序基于分治策略核心是哨兵划分：目标是选择数组某个元素作为基准数，将所有小于基准数的元素移到左侧，大于的移到右侧。void swap(int[] nums,int i,int j)&#123;    int temp = nums[i];    nums[i] = nums[j];    nums[j] = temp;&#125;/*哨兵划分*/int partition(int[] nums,int left,int right)&#123;    //我们以nums[left]为基准    int i = left , j = right;    while (i &lt; j)&#123;        while(i &lt; j &amp;&amp; nums[j] &gt;= nums[left])&#123;            j--;//从右向左找首个小于基准数的        &#125;        while (i&lt;j &amp;&amp; nums[i] &lt;= nums[left])&#123;            i++;//从左向右找到首个大于基准数的        &#125;        swap(nums,i,j);    &#125;    // 最终i，j一定相等，作为分界线    swap(nums,i,left);    return i; &#125;注意，当我们选取左侧的元素为基准时，只能先从右往左查找！ 正确顺序：先从右往左查找\n在这种模式下，循环的逻辑是：\n\nj 指针从右向左移动，直到找到一个小于 key 的数，然后停下来。\ni 指针从左向右移动，直到找到一个大于 key 的数，然后停下来。\n交换 nums[i] 和 nums[j]。\n重复以上过程，直到 i 和 j 相遇。\n\n为什么这能成功？因为 j 的任务是找到一个“小数”，而 i 的任务是找到一个“大数”。当循环结束，i 和 j 相遇时，相遇点 i 的值必然是小于等于基准数 key 的。这有两种情况：\n\n情况一：j 先移动，找到了一个小数停下，然后 i 再移动，直到与 j 相遇。这意味着相遇点 i（也就是 j 的位置）的元素就是 j 找到的那个小数，它必然小于 key。\n情况二：在某次交换后，j 开始向左移动，但它还没找到小数，i 就已经和它相遇了。这说明 i 和 j 相遇点及其右边的所有元素，都已经被 j 扫描过并确认是大于等于 key 的。而 i 停在当前位置，是因为它左边的元素都小于等于 key。因此，i 和 j 相遇的这个位置，是经过 i 指针扫描确认的小于等于 key 的区域的右边界。\n\n无论哪种情况，**只要是 j 指针的循环先启动，就能保证当 i 和 j 相遇时，它们所在的位置的元素是 j 筛选过的，必然小于等于 key**。这样，最后一步 swap(nums[left], nums[i]) 就能成功地将一个较小的数换到最左边，而基准数被换到了中间的正确位置。\n\n 错误顺序：先从左往右查找\n现在我们交换顺序，让 i 指针先从左往右查找。\n\ni 指针从左向右移动，直到找到一个大于 key 的数，然后停下来。\nj 指针从右向左移动，直到找到一个小于 key 的数，然后停下来。\n交换 nums[i] 和 nums[j]。\n重复以上过程，直到 i 和 j 相遇。\n\n为什么这会失败？问题就出在当 i 和 j 相遇时，相遇点的元素 nums[i] 可能是大于 key 的。\n我们用你提到的例子 [0, 0, 0, 0, 1] 来走一遍流程：\n\n基准数 key = nums[0] = 0。i 从索引 0 开始，j 从索引 4 开始。\n\n\n**先动 i**：i 从左向右查找大于 0 的数。\ni 移动到索引 4 时，nums[4] 是 1，大于 0。i 停在 4。\n\n\n**再动 j**：j 从右向左查找小于 0 的数。\n此时 i 已经是 4，j 也是 4，i &lt; j 的条件不满足，j 不会移动。\n\n\n循环结束：while(i &lt; j) 循环因为 i 等于 j 而终止。此时 i 和 j 相遇在索引 4。\n最后交换：执行 swap(nums[left], nums[i])，也就是交换 nums[0] 和 nums[4]。\n数组从 [0, 0, 0, 0, 1] 变成了 [1, 0, 0, 0, 0]。\n\n\n\n问题分析：因为是 i 指针先移动并找到了一个“大数”（1）而停下，而 j 指针因为 i 已经到达了它的位置而没有机会再去寻找“小数”，导致 i 和 j 最终相遇在了一个大于基准数的位置上。最后一步交换，就把这个“大数”换到了数组的最左边，破坏了分区的正确性。[1][2]\n\n总之，最终达到左边子数组任意元素&lt;&#x3D;基准数&lt;&#x3D;右边子数组\nvoid quickSort(int[] nums,int left,int right)&#123;    //基本情况，如果数组长度为1天然有序    if(left &gt;= right)&#123;        return;    &#125;    //基于分治策略，把一个长数组划分成两个短数组。    //有两个作用：1.把pivot放在正确的顺序索引上    //         2.左边子数组任意元素&lt;=基准数&lt;=右边子数组    int pivot = partition(nums,left,right);    //分别排序pivot左右两侧的数组    quickSort(nums,left,pivot-1);    quickSort(nums,pivot+1,right);    //最终左右两侧，pivot自己都有序&#125;\n\n平均时间复杂度O(nlongn)，非自适应：平均情况下递归层数为logn,每层中操作数为O(n)(主要是哨兵划分，各个子数组操作之和)。但最差时(哨兵选取的是最大或者最小的元素时），每轮哨兵划分都分为长度为0和n-1的子数组，递归层数会达到n，复杂度达到O(n*n).\n空间复杂度O(n),原地排序：递归深度最差达到n(哨兵选取的是最大或者最小元素时)。直接操作员数组，没有借助额外空间\n非稳定性：partition的最后一步，把基准元素调换到分界线时可能改变和基准元素相等的元素的相对位置\n\n优化基准数选取优化下面是一种方法，选取首、尾、中点的中位数。我们要把选取的基准数调换到最左侧，这样可以直接复用代码，直接仿照上面的哨兵划分即可\n/* 选取三个候选元素的中位数 */int medianThree(int[] nums, int left, int mid, int right) &#123;    int l = nums[left], m = nums[mid], r = nums[right];    if ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))        return mid; // m 在 l 和 r 之间    if ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))        return left; // l 在 m 和 r 之间    return right;&#125;/* 哨兵划分（三数取中值） */int partition(int[] nums, int left, int right) &#123;    // 选取三个候选元素的中位数    int med = medianThree(nums, left, (left + right) / 2, right);    // 将中位数交换至数组最左端，之后就可以直接复用上面的代码了    swap(nums, left, med);    // 以 nums[left] 为基准数    int i = left, j = right;    while (i &lt; j) &#123;        while (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])            j--;          // 从右向左找首个小于基准数的元素        while (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])            i++;          // 从左向右找首个大于基准数的元素        swap(nums, i, j); // 交换这两个元素    &#125;    swap(nums, i, left);  // 将基准数交换至两子数组的分界线    return i;             // 返回基准数的索引&#125;\n\n递归深度优化最差空间复杂度优化为O(logn):即便在基准数选取最大或者最小值时也保证O(logn)我们可以只对划分出来的短子数组进行递归，长子数组利用迭代在下次循环处理。\nvoid quickSort(int [] nums , int left ,int right)&#123;    while(left&lt;right)&#123;//基本情况隐含了，子数组长度小于等于直接返回        int pivot = parition(nums,left,right);        if(pivot - left &lt; right - pivot)&#123;            quickSort(nums,left,pivot-1);            left = pivot + 1;//左子数组被排序过了，这是新的未排序的左边界        &#125;        else&#123;            quickSort(nums,pivot + 1,right);            right = pivot - 1;//右子数组被排序过了，这是新的未排序的右边界        &#125;    &#125;&#125;\n由于每次较短的子数组必定小于等于n&#x2F;2,因此这种方法递归深度必然不超过O(logn)最差空间复杂度优化为O(logn)\n分区优化当数组中所有元素都相等时，快速排序的时间复杂度是O(n^n)对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。\n归并排序也基于分治策略，\n\n划分阶段：用递归将数组从中点处分开\n合并阶段：数组长度为1时停止开始合并\n归并排序的顺序和二叉树的后序遍历类似。\n\n\n后序遍历：先递归左子树，再递归右子树，最后处理根节点\n归并排序：先递归左子树组，再递归右子树组，最后处理合并void merge (int[] nums,int left,int mid,int right)&#123;    //左子数组区间时[left,mid],右子树组是[mid+1,right]    //temp存放合并后的结果    int [] temp = new int[right - left +1];    int i = left,j = mid+1,k = 0;    //当左右数组都有元素时，进行比较并把较小的元素复制到数组中    while (i &lt;= mid &amp;&amp; j &lt;= right)    &#123;        if(nums[i] &lt;= nums[j])        &#123;            temp[k++] = nums[i++];        &#125;        else &#123;            temp[k++] = nums[j++];        &#125;    &#125;    //当任意一个数组元素被遍历完后，把剩余元素复制到临时数组    while (i&lt;=mid)    &#123;        temp[k++] = nums[i++];    &#125;    while (j &lt;= right)    &#123;        temp[k++] = nums[j++];    &#125;    //将temp复制回原数组对应区间    for(k = 0;k&lt; temp.length;k++)    &#123;        nums[left + k] = temp[k];    &#125;&#125;/*归并排序*/void mergeSort(int[] nums,int left,int right)&#123;    //基本情况    if(left &gt;= right)    &#123;        return;    &#125;    int mid = left + (right - left)/2;    //相信mergeSort能处理更小规模的    //先对左侧归并排序    mergeSort(nums,left,mid);    //堆右侧归并排序    mergeSort(nums,mid+1,right);    //最后把左右子数组进行合并    merge(nums,left,mid,right);&#125;\n时间复杂度O(nlogn)、非自适应。递归高度logn,每层一共的合并操作都是n\n空间复杂度O(n)、非原地排序。递归调用栈O(logn),合并操作的辅助数组O(n).\n稳定排序（我们先处理了左侧的子数组）\n\n堆排序一个简单的方法是输入数组建立小顶堆，之后不断执行出堆操作，一次记录出堆元素但这样空间复杂度高，我们可以优化成原地排序\n\n输入数组建立大顶堆。完成后最大元素位于堆顶\n把堆顶元素（首个）和堆底元素（最后一个元素）交换。交换后堆的长度减去1，已排序元素加一\n从堆顶开始执行从顶到底堆化。\n重复2、3。循环n-1轮即可排序成功\n\nvoid siftDown(int[] nums,int n,int i)&#123;    while(true)    &#123;        int l = 2*i +1;        int r = 2*i + 2;        int ma = i;        if(l &lt; n &amp;&amp; nums[l] &gt; nums[ma])        &#123;            ma = l;        &#125;        if(r &lt; n &amp;&amp; nums[r] &gt; nums[ma])        &#123;            ma = r;        &#125;        if (ma == i)        &#123;            break;        &#125;        int temp = nums[i];        nums[i] = nums[ma];        nums[ma] = temp;        i = ma;    &#125;&#125;\n注意，自顶向下堆化要求除了要处理的当前节点及其子节点外，剩余部分的子树都满足堆的性质。\n/*堆排序*/void heapSort(int[] nums)&#123;    //建堆    for( int i = nums.length/2 - 1 ;i&gt;= 0;i--)    &#123;        siftDown(nums,nums.length,i);    &#125;    //从堆中提取最大元素，循环n-1轮    for(int i = nums.length - 1;i&gt;0;i--)    &#123;        int temp = nums[0];        nums[0] = nums[i];        nums[i] = temp;        siftDown(nums,i,0);//i是索引中最后的元素，本来就是数组长度-1，因此首次循环无需先减去1    &#125;&#125;\n\n时间复杂度O(nlogn)、非自适应排序log(n-1) + log(n-2) + …… + log2,我们在之后证明这个求和的渐进上限就是O(nlogn)\n空间复杂度O(1)、原地排序\n非稳定性排序：交换堆顶和堆底时，相等元素相对位置可能变化\n\n下面我们来证明log(n-1) + ……+log2的渐进上限是O(logn)\n\n显然和s&lt;&#x3D;nlogn\n之后我们把s分两半，log(2)到log(n&#x2F;2),和log(n&#x2F;2+1)到log(n-1)，后一半是nlogn,因此s&gt;&#x3D;nlogn\n\n实际上快速排序一般更快\n出现最坏情况的概率很低快速排序的最坏情况时间复杂度是 O(n²)，这种情况发生在每次选择的基准值（pivot）都是当前数组中的最大或最小值时，例如对一个已经排好序的数组进行排序。然而，这种情况在实际应用中非常罕见。通过随机选取基准值或使用“三数取中”等方法，可以极大地避免最坏情况的发生。在绝大多数情况下，快速排序都能在 O(n log n) 的时间复杂度下高效运行。\n缓存使用效率高现代计算机的内存结构是分级的（CPU -&gt; Cache -&gt; Memory）。CPU访问缓存的速度远快于访问主内存。快速排序在分区（partition）操作时，是对一个连续的数组块进行操作。这使得数据可以被加载到高速缓存中，从而提高访问效率。 这种访问模式被称为“局部性原理”（principle of locality）。相比之下，像堆排序这样的算法需要跳跃式地访问元素（例如，访问父节点和子节点，它们在内存中可能相距很远），这降低了缓存的命中率，从而导致实际运行时间变慢。\n复杂度的常数系数小算法的时间复杂度（如 O(n log n)）描述的是随着数据规模 (n) 增长的趋势，但忽略了常数项。在实际计算中，这个常数项代表了完成基本操作（如比较、交换）所需的具体时间。在上述三种算法中，快速排序完成一次内循环所需要的比较、赋值、交换等操作的总数量是最少的。 这意味着在相同的 n log n 级别下，快速排序的实际执行时间更短。这与“插入排序”比“冒泡排序”更快的原因类似，尽管它们的复杂度在最坏情况下都是O(n²)，但插入排序的内部操作更少。\n\n桶排序采取分治策略设置一些具有一定大小顺序的桶，每个桶对应一个数据范围，把数据平均分配到各个桶中，之后在每个桶内部排序，最后按照桶的顺序把所有数据合并\nimport java.util.ArrayList;import java.util.Collection;import java.util.List;void bucketSort(float[] nums) &#123;    //初始化k = n/2，预期向每个桶分配2个元素    int k = nums.length / 2;    List&lt;List&lt;Float&gt;&gt; buckets = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; k; i++) &#123;        buckets.add(new ArrayList&lt;&gt;());    &#125;    //把元素平均分配到各个桶    for (float num : nums) &#123;        int i = (int) (num * i);        buckets.get(i).add(num);    &#125;    // 对每个桶排序    for (List&lt;Float&gt; bucket : buckets) &#123;        Collection.sort(bucket);    &#125;    int i = 0;    for(List&lt;Float&gt;bucket : buckets)    &#123;        for(float num : bucket)        &#123;            nums[i++] = num;        &#125;    &#125;&#125;\n\n时间复杂度：O(n + k):在平均分布的情况下，排序单个桶O((n&#x2F;k) *log(n&#x2F;k)),k个桶就是O(nlog(n&#x2F;k)),当k很大，趋近于O(n)。合并结果时，每轮循环操作数O(1+n&#x2F;k),一共k轮循环花费O(n+k)。但最差情况下所有数据分配到一个桶，复杂度可能是O(nlogn)\n空间复杂度：O(n + k),非原地排序\n稳定性取决于排序每个桶内的算法是否稳定\n**桶排序重要的是要尽可能使元素平均分布**\n\n计数排序假定数组都是非负整数先找到原数组最大数字m,创建长度m+1辅助数组counter,借助counter统计nums各个数字出现次数，由于counter索引天然有序，之后遍历counter把数字填入nums\n//注意这个实现不能排序对象void countingSortNative(int[] nums)&#123;    //统计最大元素m    int m = 0;    for(int num : nums)    &#123;        m = Math.max(m , nums);    &#125;    //统计各个数字出现次数    int[] counter = new int[m+1];    for(int num : nums)    &#123;        counter[num]++;    &#125;    //遍历counter，把元素填入原数组    int i = 0;    for(int num = 0;num &lt; m+1;num++)    &#123;        for(int j = 0;j &lt; counter[num];j++,i++)        &#123;            nums[i] = num;        &#125;    &#125;&#125;\n我们可以将计数排序中的计数数组 counter 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。但是上述实现无法对对象排序。如果强行对对象排序，会只得到排序所依据的属性的顺序我们可以计算前缀和来完整实现。前缀和就是小于等于i的元素之和，我们用prefix数组记录于是prefix[i] - 1就是最右侧元素应该在的索引最后倒序遍历原数组nums,依据每个元素对应的prefix放到res对应的位置，之后让prefix减一，最后把res复制到原数字即可\nvoid countingSort(int[] nums)&#123;    int m = 0;    for(int num : nums)    &#123;        m = Math.max(m,num);    &#125;    int[] counter = new int[m + 1];    for(int num : nums)    &#123;        counter[num]++;    &#125;    //计算前缀和    for(int i = 0;i &lt; m;i++)    &#123;        counter[i+1] += counter[i];    &#125;    //倒序遍历并且填入res    int n = nums.length;    int[] res = new int[n];    for(int i = n - 1;i &gt;= 0; i--)    &#123;        int num = nums[i];        res[counter[num] - 1] = num;        counter[num]--;    &#125;    for(int i = 0; i &lt; n;i++)    &#123;        nums[i] = res[i];    &#125;&#125;\n\n时间复杂度O(n + m),非自适应：m是最大的数\n空间复杂度O(n+m),非原地排序\n稳定排序计数排序只适用于非负整数（其他的可以转换），适用于数据量大但是范围小的情况\n\n基数排序位数从低到高，分别以每位为键进行计数排序。\n\n低位排序是为高位排序服务的：当我们按十位排序时，所有十位相同的数字，它们的相对顺序实际上是由个位决定的，而个位在第一步已经排好了。\n稳定性是秩序的“守护者”：稳定性保证了低位排序的成果不会被高位排序破坏掉。它确保了当高位相同时，低位已经建立的秩序得以保留。\n层层递进的秩序：当排到第 k 位时，所有数字的后 k 位其实都已经是有序的了。当最后排完最高位时，整个数字自然就是完全有序的。可用下图公式获取d进制数字的第k位/*获取元素第k位，其中exp = 10^(k-1)*/int digit (int num , int exp)&#123;    //传入exp避免重复次方运算    return (num/exp) % 10;&#125;/*计数排序，根据nums第k位排序*/void countingSortDigit(int[] nums, int exp)&#123;    int[] counter = new int[10];    int n = nums.length;    //统计0~9出现个数    for(int i = 0; i&lt; n;i++)&#123;        int d = digit(nums[i],exp);        counter[d]++;    &#125;    //求前缀和    for(int i = 1;i&lt;10;i++)    &#123;        counter[i] += counter[i-1];    &#125;    //倒序遍历    int[] res = new int [n];    for(int i = n -1;i&gt;=0;i--)    &#123;        int d = digit(nums[i],exp);        int j = counter[d] - 1;        res[j] = nums[i];        counter[d]--;    &#125;    for(int i = 0;i &lt; n;i++)    &#123;        nums[i] = res[i];    &#125;    &#125;/*基数排序*/void radixSort(int[] nums)&#123;    int m = Integer.MIN_VALUE;    for(int num : nums)    &#123;        if(num &gt; m)        &#123;            m = num;        &#125;    &#125;    for(int exp = 1;exp &lt;= m ;exp *= 10)    &#123;        countingSortDigit(nums,exp);    &#125;&#125;\n时间复杂度：O(nk),非自适应：对某一位排序是O(n+d),排序所有k位是O((n+d)k),一般n &gt;&gt; d,可以近似为O(nk).一般情况下，n,k都是小常数，复杂度可以为O(n).\n空间复杂度：O(n + d),要借助res和counter数组\n稳定排序：计数排序稳定基数就稳定\n\n总结\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"递归复杂度分析","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95/%E9%80%92%E5%BD%92%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/","content":"如何系统性分析递归算法的复杂度（最终优化版）分析递归算法的复杂度，核心在于将算法的递推逻辑转化为清晰的数学模型，并选择最恰当的工具进行求解。本指南将为您呈现一个从时间到空间、从建模到求解的完整分析框架。\n\n\n\n开篇：分析决策流程图在开始之前，可以根据以下流程图来选择最适合您的分析路径：\n                  拿到一个递归算法                        ↓        1. 写出时间/空间递推关系式                        ↓[时间复杂度分析] ├──────────────────| [空间复杂度分析]      ↓                                    ↓2. 观察递推式形式                      分析最大递归深度 × 单次调用空间      ↓┌──────────────────────────────────────────────┐│ T(n)=aT(n/b)+f(n)？                          ││      ├─ 是 ─&gt; ✅ 优先：主方法                 ││      │         (若不适用，则转为递归树法)        ││      ↓ 否                                      ││                                              ││ T(n)=T(n-c)+f(n) 或 T(n)=aT(n-c)+f(n)？       ││      ├─ 是 ─&gt; ✅ **展开求和 (或递归树法)**      ││      │         (例如: T(n)=T(n-1)+n)           ││      ↓ 否                                      ││                                              ││ 其他复杂形式？ (如 T(n)=T(n/a)+T(n/b)+f(n))   ││      └─&gt; ✅ **通用后备：递归树法**             ││            (用于猜测，再用替换法证明)          │└──────────────────────────────────────────────┘      ↓3. 特殊视角：是否满足“单次处理成本O(1)”？      └─ 是 ─&gt; ✅ **聚合分析法**\n\n\n第一部分：时间复杂度分析时间复杂度的分析重点在于量化递归过程中的总计算量。\n第一步：建立递推关系式（分析的基石）这是所有分析的起点。您需要将代码逻辑翻译成一个数学表达式 T(n)，它描述了处理规模为 n 的问题所需的总时间。\n一个标准的递推关系式包含两部分：\n\n递归成本：为解决原问题，递归调用了多少次函数 (a)？每次调用的子问题规模是多大 (n/b)？\n**本地成本 f(n)**：在单次函数调用中，除了递归调用外，执行了多少“本地”计算（如循环、判断、合并结果等）？\n\n标准形式：T(n) = a * T(n/b) + f(n)\n示例：归并排序 (Merge Sort)\n\n递推关系式：T(n) = 2T(n/2) + O(n)\n2T(n/2)：两次递归调用，每次处理一半数据。\nO(n)：合并两个有序数组的 merge 操作成本。\n\n\n\n\n重要前提：明确分析场景在开始分析前，务必明确您分析的是最坏情况 (Worst Case) 还是 **平均情况 (Average Case)**。对于某些算法，这两种情况的递推式截然不同。\n\n快速排序 (Quicksort) 示例：\n最坏情况 (主元划分极不均衡): T(n) = T(n-1) + O(n) → 解得 O(n²)。\n平均&#x2F;最好情况 (主元划分较均匀): T(n) = 2T(n/2) + O(n) → 解得 O(n log n)。\n\n\n\n\n第二步：选择求解方法（决策流程）得到递推关系式后，下一步就是求解它。您可以根据关系式的特点，选择最高效的分析“武器”。\n\n分析武器详解武器一：主方法 (Master Theorem) — 公式捷径\n这是求解 T(n) = a * T(n/b) + f(n) (a&gt;&#x3D;1,b&gt;1)形式的“利器”。核心是比较 f(n) 与 n^(log_b a) 的增长速度：\n\n**情况一 (子问题主导)**：若 f(n) = O(n^(log_b a - ε)) 对于某个常数 ε &gt; 0，则 T(n) = Θ(n^(log_b a))。\n\n通俗讲：f(n) 的增长速度显著慢于 n^(log_b a)。\n\n\n**情况二 (成本均衡)**：若 f(n) = Θ(n^(log_b a))，则 T(n) = Θ(n^(log_b a) * log n)。\n\n通俗讲：f(n) 的增长速度等于 n^(log_b a)。\n\n\n**情况三 (本地成本主导)**：若 f(n) = Ω(n^(log_b a + ε)) 对于某个常数 ε &gt; 0，且满足正则条件 a * f(n/b) ≤ c * f(n) (对于某个常数 c &lt; 1 和所有足够大的 n)，则 T(n) = Θ(f(n))。\n\n通俗讲：f(n) 的增长速度显著快于 n^(log_b a)。\n\n\n\n实际上，可以认为 f(n) 代表本地操作数增长，g(n) &#x3D; n^(log_b a) 代表基础子问题操作数增长（递归树叶节点操作数），谁趋势显著大就保留谁，一样的话就再乘上一个logn显著大：h(n) &#x3D; f(n) &#x2F; g(n)，如果h(n)至少是一个多项式(n^k,k大于0)，意味着f(n)显著大于g(n)\n关于g(n),g(n)实际上是a^(树高次方)进行数学恒等变换得到的，代表递归树的总叶结点数量，每个节点数量，每个节点的操作树一般都是f(1)是个常数，因此这个式子可以代表子问题总操作数\n\n正则条件 a * f(n/b) ≤ c * f(n) 的通俗理解：这个条件确保 f(n) 的增长是“稳健的”，不会在递归深入时出现剧烈波动。它本质上是要求：**子问题 a * f(n/b) 的总本地成本，必须小于或等于根节点本地成本 f(n) 的一个常数比例 c**（其中 c&lt;1）。这保证了总成本主要由根节点的 f(n) 决定，而不会被子问题的成本“反超”。绝大多数常见的多项式、对数函数都满足此条件。\n\n\n局限性与扩展：主方法并非万能，其三个情况之间存在“间隙”(gap)，无法覆盖所有函数。\n\n一个常见的“间隙”情况（主方法扩展）：当 f(n) = Θ(n^(log_b a) * log^k n) 且 k ≥ 0 时，标准主方法不直接适用。此时，解为 **T(n) = Θ(n^(log_b a) * log^(k+1) n)**。\n\n  例如，对于递推式 T(n) = 2T(n/2) + O(n log n)，这里 a=2, b=2, log_b a = 1。f(n) = n log n，属于 k=1 的情况。其解为 T(n) = Θ(n * log² n)。\n\n武器二：递归树法 (Recursion Tree Method) — 直观通用\n当主方法不适用或想更深入理解时，递归树是最好的工具。\n分析步骤：\n\n画树：将递推式展开成一棵树，每个节点代表一次函数调用的本地成本。\n算每层成本：计算树的每一层所有节点的成本之和。\n算树高：确定从根节点到叶子节点的最长路径长度。\n累加求和：将所有层的成本累加起来，得到总复杂度。\n\n示例1 (均匀分割)：归并排序 T(n) = 2T(n/2) + cn\n\n每层成本：无论在哪一层，该层所有节点的成本之和总是 cn。\n树高：log₂n。\n总成本：每层成本 × 树高 &#x3D; cn * log₂n → O(n log n)。\n\n示例2 (非均匀分割)：T(n) = T(n/3) + T(2n/3) + n\n\n画树：这是一棵非完全二叉树，每一层的节点大小不同。\n每层成本：根节点成本是 n。下一层是 n/3 和 2n/3，成本和仍为 n。可以发现，每一层的成本之和都是 n。\n树高：树的高度由最长的路径决定，即 n -&gt; (2/3)n -&gt; (2/3)²n -&gt; ... -&gt; 1。高度 h 满足 (2/3)^h * n = 1，解得 h = log_(3/2) n。\n总成本：n * log_(3/2) n → O(n log n)。这个例子展示了递归树处理复杂分割的强大能力。\n\n\n⚠️ 递归树法的常见陷阱：误判叶子节点数量对于 T(n) = aT(n/b) + f(n) 形式的递归，叶子节点的总数是 a^h，其中 h 是树高。这个总数等于 **n^(log_b a)**。在计算与叶子节点相关的成本时（通常是递归的终止条件 T(1)），必须使用这个正确的数量级，而不是简单地认为是 n。\n\n武器三：替换法 (Substitution Method) — 严谨证明\n此方法本质是数学归纳法，通常配合递归树使用：先用递归树猜测一个复杂度上界，再用替换法来严格证明这个猜测是成立的。\n武器四：聚合分析法  — 总量视角注：此处的聚合分析指直接累加算法各部分的总工作量  \n此方法跳出求解单次递归的递推关系，通过直接计算整个算法生命周期内的工作总量来确定复杂度。\n✅ 适用信号：\n\n有限处理次数：通过“单向移动指针”或“visited状态标记”等机制，保证每个核心元素在其生命周期内只被处理有限次（通常是1次）。\n恒定单次成本：处理单个工作单元的本地操作成本为 **O(1)**，通常借助哈希表等高效数据结构实现。实际上是每个单元的操作树不随子问题规模而变化\n\n分析步骤：总复杂度 = (一次性初始化成本) + (工作单元总数) × (每个单元的处理次数) × (单次处理成本)\n示例：根据前序和中序遍历重建二叉树 (使用哈希表)\n\n适用性判断：\n前序遍历的索引 preIndex 只增不减，保证每个节点只被创建一次。（满足特征1）\n通过哈希表 inorderMap 查找根节点索引，成本为 O(1)。（满足特征2）\n\n\n分析：\n一次性成本：构建 inorderMap &#x3D; O(N)。\n核心工作量：N个节点 × 1次处理 × O(1)单次成本 &#x3D; O(N)。\n总复杂度 &#x3D; O(N) + O(N) = O(N)。\n\n\n\n\n第二部分：空间复杂度分析递归算法的空间复杂度主要由递归调用栈 (Call Stack) 的深度决定。它衡量的是算法在执行期间内存占用的峰值。\n核心公式调用栈空间复杂度 &#x3D; 最大递归深度 × 每次递归调用所需的空间\n\n一个更完整的视角：调用栈空间 vs. 辅助空间一个算法的总空间复杂度是调用栈空间与算法明确创建的辅助空间（如数组、哈希表等）中的最大值。\n总空间复杂度 &#x3D; Max(调用栈空间, 辅助空间)\n关于返回值的说明：通常，空间复杂度分析关注的是算法运行过程中的临时内存占用，不包括最终输出结果本身所需的空间。\n示例：一个递归函数，对一棵有 N 个节点的平衡二叉树进行遍历，并将所有节点值存入一个结果列表中。\n\n调用栈空间：树的高度为 O(log N)。\n辅助空间：结果列表需要存储 N 个节点值，空间为 O(N)。\n最终空间复杂度：Max(O(log N), O(N)) = O(N)。\n\n\n系统分析步骤第一步：确定最大递归深度这是决定调用栈空间复杂度的最关键因素。\n\n**线性递归 (如：阶乘)**：最大深度为 O(n)。\n**树形递归 (如：斐波那契数列)**：虽然总调用次数是指数级的，但执行是深度优先的。最长的调用链是从 n 到 1，因此最大深度仍为 O(n)。\n二叉树深度遍历：递归深度取决于树的高度 h。对于平衡二叉树，深度为 O(log n)；对于链状的极端情况，深度为 O(n)。\n\n第二步：分析单次调用的空间消耗在绝大多数情况下，如果不创建与输入规模 n 相关的动态数据结构，单次调用的空间消耗是常数级别的，即 O(1)。\n\n⚠️ 注意隐式空间开销在分析单次调用的空间时，要警惕那些看起来像是 O(1) 但实际上会创建新对象的语言特性。\n\n示例 (Python)：在递归函数中如果使用了字符串或列表的切片 (slicing) 作为参数传递，例如 recursive_call(arr[1:])，这通常会创建一个新的、长度为 n-1 的副本，导致单次调用的空间消耗为 O(n)，从而极大地增加了总空间复杂度。\n正确做法：应通过传递索引或指针（如 recursive_call(arr, start_index + 1))来避免这种不必要的空间开销，维持单次调用的空间为 O(1)。\n\n\n第三步：综合计算总的空间复杂度结合前两步的结果，并考虑算法使用的辅助空间，得出最终结论。\n优化考量：尾递归 (Tail Recursion)如果一个递归函数的最后一步操作是调用自身（尾调用），支持该优化的编译器可以复用当前栈帧，将调用栈空间复杂度从 O(n) 降低到 O(1)。\n\n注意：许多主流编程语言（如 Python、Java）的解释器&#x2F;编译器默认不支持尾递归优化。因此，在这些环境中不能想当然地认为空间复杂度会被优化。\n\n\n第三部分：总结与常见陷阱核心分析方法对比表\n\n\n方法\n适用场景\n优点\n缺点\n\n\n\n主方法\nT(n)=aT(n/b)+f(n) 形式的递推式\n快速、公式化、结论直接\n有“间隙”，不通用，无法处理非标准形式\n\n\n递归树法\n几乎所有递推式，尤其主方法失效时\n直观、通用、能处理复杂分割\n过程相对繁琐，涉及级数求和\n\n\n替换法\n需要严格数学证明的场合\n最严谨，是复杂度的最终证明\n需要先“猜测”一个解，过程复杂\n\n\n聚合\n每个工作单元处理次数有限且单次成本O(1)\n思路巧妙，跳出递推式，计算简单\n适用场景非常有限，条件苛刻\n\n\n常见分析陷阱\n陷阱一：混淆“调用总次数”与“最大递归深度”\n\n辨析：时间复杂度关心总工作量（调用总次数），而空间复杂度关心内存占用的峰值（最大递归深度）。\n反例速查：朴素的斐波那契数列 fib(n)，时间复杂度为 O(2^n)（指数级的调用次数），但空间复杂度仅为 O(n)（线性的递归深度）。\n\n\n陷阱二：公式不是万能的，别乱套！\n\n辨析：每种方法都有其严格的适用范围。当不确定时，回归最通用的递归树法。\n反例速查：递推式 T(n) = T(n-1) + n 不符合主方法的结构，强行套用会出错。使用递归树法则能清晰地看到其成本累加为 n + (n-1) + ... + 1，结果为 O(n²)。\n\n\n陷阱三：f(n) 是魔鬼，细节决定成败！\n\n辨析：在建立递推关系式 T(n) = aT(n/b) + f(n) 时，必须精确分析除递归调用外的所有“本地成本”f(n)。\n反例速查：归并排序中，合并操作的成本是 f(n)=O(n)，这是决定其 O(n log n) 复杂度的关键。如果误认为 f(n)=O(1)，会得出完全错误的结论。\n\n\n陷阱四：忽略 f(n) 中的“隐形成本”\n\n辨析：f(n) 的计算必须细致入微。一个看似简单的循环或函数调用，其成本可能并非 O(1)。\n反例速查：考虑一个在 n 个元素上进行递归的函数，每次递归中，它都循环遍历一个大小为 k 的辅助数组。此时 f(n) 应该是 O(k) 而非 O(1)。另一个例子是在 f(n) 中执行了字符串拼接操作，在某些语言中，n 次拼接 n 个字符的成本可能是 O(n²)，而不是 O(n)。\n\n\n\n\n一个构建递归树的例子  \n第一步：写出递推关系式根据上面的算法思想，我们可以得出归并排序的时间复杂度递推关系式：\n\n分解：找到中间点，只需要 O(1) 的时间。\n解决：递归调用两次，每次处理一半的数据。所以这部分的代价是 2 * T(n/2)。\n合并：merge 操作需要遍历两个子数组，将它们合并成一个新的数组，这个过程的时间复杂度是 O(n)。\n\n因此，总的时间复杂度递推式为：T(n) &#x3D; 2T(n&#x2F;2) + cn(为了方便计算，我们用 cn 来表示 O(n) 这一项，其中 c 是一个常数)\n第二步：构建并分析递归树现在，我们开始画出这个递推关系式对应的递归树。\n1. 树的结构\n根节点：代表原始问题 T(n)。它有两个子节点，代表两个规模为 n/2 的子问题。根节点自身的工作量（合并代价）是 cn。\n第二层：有两个节点，每个节点代表一个 T(n/2) 的问题。对于每个节点，它自身的工作量是 c(n/2)，并且它又会产生两个规模为 n/4 的子问题。\n第三层：有四个节点，每个节点代表一个 T(n/4) 的问题，每个节点的工作量是 c(n/4)。\n……\n叶子节点：当问题规模缩小到 1 时，递归到达终点。这代表 T(1)，其时间复杂度为 O(1)，我们记为常数 c。\n\n2. 可视化递归树下面是这个过程的可视化图：\n              cn (代价)                     -----&gt;  第 0 层: 总代价 = cn             /  \\            /    \\           /      \\     T(n/2)        T(n/2)       |             |    c(n/2)          c(n/2)                  -----&gt;  第 1 层: 总代价 = 2 * c(n/2) = cn     / \\           / \\    /   \\         /   \\T(n/4) T(n/4)   T(n/4) T(n/4)  |      |       |      |c(n/4) c(n/4)   c(n/4) c(n/4)             -----&gt;  第 2 层: 总代价 = 4 * c(n/4) = cn ...    ...     ...    ...  |      |       |      | T(1)   T(1)     ...    T(1)                   -----&gt;  第 k 层 (叶子层)\n\n3. 分析树的属性a) 计算每一层的代价：\n\n第 0 层 (根节点)：代价是 cn。\n第 1 层：有两个节点，每个节点的代价是 c(n/2)，所以总代价是 2 * c(n/2) = cn。\n第 2 层：有 2^2 = 4 个节点，每个节点的代价是 c(n/4)，所以总代价是 4 * c(n/4) = cn。\n…\n第 i 层：有 2^i 个节点，每个节点的代价是 c(n / 2^i)，所以总代价是 2^i * c(n / 2^i) = cn。\n\n观察发现： 在这棵树中，每一层的总代价都是 cn。\nb) 计算树的深度（高度）：\n递归树的深度取决于问题规模从 n 缩小到 1 需要多少步。假设树的深度为 k（从第 0 层开始）。在第 k 层，子问题的规模是 n / 2^k。当递归到达叶子节点时，问题规模为 1。所以，我们令 n / 2^k = 1，解得 2^k = n，即 k = log₂n。\n因此，这棵树的高度大约为 log₂n。层数是从 0 到 log₂n，总共有 log₂n + 1 层。\n第三步：累加所有层的代价现在我们把所有层的代价加起来，得到算法的总运行时间。\n总代价 &#x3D; (每一层的代价) × (树的层数)T(n) = cn + cn + cn + ... + cn (共 log₂n 层)\n注意：这里还需要加上最后一层叶子节点的代价。最后一层（第 log₂n 层）有 n 个叶子节点 (2^(log₂n) = n)，每个节点的代价是 T(1) = c。所以最后一层的总代价是 n * c = cn。\n精确的计算是：T(n) = Σ (从 i=0 到 log₂n - 1) [cn] + c * n (最后一层叶子节点的代价)T(n) = cn * log₂n + cn\n第四步：得出最终复杂度根据上面的求和结果 cn * log₂n + cn，我们使用大O表示法来评估其渐进复杂度。忽略低阶项 cn 和常数系数 c，我们得到：\nT(n) &#x3D; O(n log n)\n总结：递归树法分析步骤回顾\n写出递推式：T(n) = 2T(n/2) + cn。\n画出递归树：清晰地展示出每一层的节点数和每个节点的代价。\n计算每层总代价：发现每一层的代价都是 cn。\n计算树的高度：高度为 log₂n。\n累加总代价：将每一层的代价乘以树的高度，即 cn * log₂n。\n得出结论：最终时间复杂度为 O(n log n)。\n\n","categories":["基本算法"],"tags":["基本算法","学习笔记"]},{"title":"HashMap","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/HashMap/","content":"哈希表核心知识点与 Java 实现1. 定义与核心原理哈希表 (Hash Table)，又称散列表，是一种通过哈希函数 (Hash Function) 将键 (Key) 映射到数组索引，从而实现高效键值 (Key-Value) 存储与访问的数据结构。\n\n\n\n\n核心目标: 实现平均时间复杂度为 O(1) 的插入、删除、查找操作。\n基本组件:\n键值对 (Pair): 数据存储的基本单元。\n桶数组 (Bucket Array): 哈希表底层的数组，用于存放数据。\n哈希函数 (Hash Function): 负责将 Key 转换为桶数组的索引。\n\n\n\n2. 关键组件一：哈希函数哈希函数是哈希表的基石，其质量直接影响哈希表的性能。\n2.1. 必备特性\n确定性: 相同的 Key 输入必须产生相同的索引输出。\n高效性: 函数计算速度必须快。\n均匀性: 必须能将不同的 Key 尽可能均匀地分布到桶数组的各个位置，以最小化哈希冲突。\n\n2.2. Java 中的 hashCode() 与 equals()在 Java 中，HashMap 等数据结构依赖对象的 hashCode() 方法来计算哈希值。为保证正确性，必须遵守以下契约：\n\nequals() 相等的两个对象，其 hashCode() 必须相等。\nhashCode() 相等的两个对象，其 equals() 不一定相等（这正是哈希冲突）。\n如果重写了 equals() 方法，就必须重写 hashCode() 方法以维护此契约。\n\n3. 关键组件二：哈希冲突解决方案哈希冲突: 两个不同的 Key 经过哈希函数计算后得到了相同的数组索引。冲突是必然的，解决冲突的策略是哈希表设计的核心。\n3.1. 方案 A: 链式地址法 (Separate Chaining)\n机制: 桶数组的每个位置不直接存储元素，而是存储一个数据集合（如链表、动态数组）的引用。所有哈希到同一索引的键值对，都被添加到该位置的集合中。\n\n操作流程:\n\n插入 (put): 计算索引，定位到桶。遍历桶内集合：若 Key 已存在，则更新 Value；若不存在，则将新键值对添加到集合末尾。\n查找 (get): 计算索引，定位到桶。遍历桶内集合，查找匹配的 Key 并返回其 Value。\n删除 (remove): 计算索引，定位到桶。遍历桶内集合，找到并移除匹配的键值对。\n\n\n重要优化：红黑树化 (Treeifying)\n\n问题: 当大量 Key 哈希到同一个桶时，链表会变得很长，查询效率从 O(1) 退化到 O(N)。\n解决方案: 在 Java 8 及以后的 HashMap 中，当一个桶内的链表长度超过阈值（默认为 8）且哈希表总容量大于 64 时，该链表会转换为一棵红黑树。\n效果: 将该桶的最坏查询时间复杂度从 O(N) 优化到 **O(logN)**。\n\n\n链式地址法总结:\n\n优点: 实现逻辑清晰，删除操作简单直接，负载因子理论上可以大于1。\n缺点: 存在额外的数据结构开销（如链表节点的指针），对 CPU 缓存不友好。\n\n\n\n3.2. 方案 B: 开放寻址法 (Open Addressing)\n机制: 所有元素都直接存储在桶数组中。当发生冲突时，通过一个探测序列在数组中寻找下一个可用的空槽位。\n\n核心：懒删除 (Lazy Deletion) 与 TOMBSTONE\n\n问题: 直接删除元素（置为 null）会中断探测链，导致后续本应能找到的元素查找失败。\n解决方案: 删除时，不将槽位置为 null，而是放置一个特殊的**墓碑对象 (TOMBSTONE)**。\nTOMBSTONE 的作用:\n对于查找操作：遇到墓碑，表示探测应继续进行。\n对于插入操作：墓碑所在的位置被视为可用槽位，可以直接插入新元素。\n\n\n\n\n探测方法:\n\n线性探测 (Linear Probing): 依次探测 index+1, index+2, …。实现简单，但易产生聚集 (Clustering) 现象，即连续的槽位被占据，降低性能。\n二次探测 (Quadratic Probing): 依次探测 index+1², index+2², …。可缓解主聚集。\n双重哈希 (Double Hashing): 使用第二个哈希函数计算探测的步长。index = (hash1(key) + i * hash2(key)) % capacity。能有效避免各类聚集，是性能较好的探测方法。\n\n\n开放寻址法总结:\n\n优点: 无额外数据结构开销，空间利用率高，数据连续存储对 CPU 缓存友好。\n缺点: 实现相对复杂，删除操作需要懒删除机制，负载因子必须严格小于1，对哈希函数的均匀性要求更高。\n\n\n\n4. 关键组件三：负载因子与扩容机制\n负载因子 (Load Factor):\n\n定义: 负载因子 = 已存元素数量 / 桶数组总容量。\n作用: 衡量哈希表的填充程度，是决定是否需要扩容的关键指标。Java HashMap 默认为 0.75。\n\n\n扩容 (Rehashing):\n\n触发条件: 当负载因子超过设定的阈值时。\n目的: 降低负载因子，减少哈希冲突，维持 O(1) 的平均性能。\n过程 (时间复杂度 O(N)):\n创建一个容量通常为原来2倍的新桶数组。\n遍历旧桶数组中的每一个元素。\n重新计算每个元素在新容量下的哈希索引 (key % new_capacity)。\n将元素放入新桶数组的对应位置。\n用新桶数组替换旧桶数组。\n\n\n注意: 扩容是一个高成本操作，因为它需要重新处理所有现有元素。\n\n\n\n5. 两种方案对比总结\n\n\n特性\n链式地址法 (Separate Chaining)\n开放寻址法 (Open Addressing)\n\n\n\n空间使用\n存在额外指针&#x2F;节点开销\n空间利用率高，无额外开销\n\n\n负载因子\n可大于 1\n必须小于 1\n\n\n删除操作\n简单，直接移除节点\n复杂，需要 TOMBSTONE 标记\n\n\n缓存效率\n较低（内存不连续）\n较高（内存连续）\n\n\n主要问题\n链表过长导致性能退化\n元素聚集导致性能退化\n\n\n常见场景\n通用哈希表实现 (如 Java HashMap)\n对内存占用敏感的特定场景\n\n\n\n6. 完整代码实现实现 1：HashMapChaining.java (链式地址法)import java.util.ArrayList;import java.util.List;// 辅助类：键值对class Pair &#123;    public int key;    public String val;    public Pair(int key, String val) &#123;        this.key = key;        this.val = val;    &#125;&#125;public class HashMapChaining &#123;    /*    实现哈希表，链式地址    实现构造，hashFunc,loadFactor,get,put,remove,extend,print方法。     */    int size;    int capacity;    double lodaThres;    int extendRatio;    List&lt;List&lt;Pair&gt;&gt; buckets;    public HashMapChaining() &#123;        size = 0;        capacity = 4;        lodaThres = 2.0 / 3.0;        extendRatio = 2;        buckets = new ArrayList&lt;&gt;(capacity);        for (int i = 0; i &lt; capacity; i++) &#123;            buckets.add(new ArrayList&lt;&gt;());        &#125;    &#125;    int hashFunc(int key) &#123;        return key % capacity;    &#125;    double loadFactor() &#123;        return (double) size / capacity;    &#125;    String get(int key) &#123;        int index = hashFunc(key);        List&lt;Pair&gt; bucket = buckets.get(index);        for (Pair pair : bucket) &#123;            if (pair.key == key) &#123;                return pair.val;            &#125;        &#125;        return null;    &#125;    void put(int key, String val) &#123;        if (loadFactor() &gt; lodaThres) &#123;            extend();        &#125;        int index = hashFunc(key);        List&lt;Pair&gt; bucket = buckets.get(index);        for (Pair pair : bucket) &#123;            if (pair.key == key) &#123;                pair.val = val;                return;            &#125;        &#125;        Pair pair = new Pair(key, val);        bucket.add(pair);        size++;    &#125;    void remove(int key) &#123;        int index = hashFunc((key));        List&lt;Pair&gt; bucket = buckets.get(index);        for (Pair pair : bucket) &#123;            if (pair.key == key) &#123;                bucket.remove(pair);                size--;                break;            &#125;        &#125;    &#125;    void extend() &#123;        List&lt;List&lt;Pair&gt;&gt; bucketsTemp = buckets;        capacity *= extendRatio;        buckets = new ArrayList&lt;&gt;(capacity);        for (int i = 0; i &lt; capacity; i++) &#123;            buckets.add(new ArrayList&lt;&gt;());        &#125;        size = 0; // 重置size，因为put操作会重新增加它        for (List&lt;Pair&gt; bucket : bucketsTemp) &#123;            for (Pair pair : bucket) &#123;                put(pair.key, pair.val);            &#125;        &#125;    &#125;    void print() &#123;        for (List&lt;Pair&gt; bucket : buckets) &#123;            List&lt;String&gt; res = new ArrayList&lt;&gt;();            for (Pair pair : bucket) &#123;                res.add(pair.key + &quot;-&gt;&quot; + pair.val);            &#125;            System.out.println(res);        &#125;    &#125;&#125;\n\n实现 2：HashMapOpenAddressing.java (开放寻址法)// Pair 类复用上面的定义public class HashMapOpenAddressing &#123;    /*    包含懒删除的开放寻址（线性探测）的哈希表。    实现构造，hashFunc ,loadFactor,findBucket,get,put,remove,extend,print     */    private int size;    private int capacity = 4;    private final double loadThres = 2.0 / 3.0;    private final int extendRatio = 2;    private Pair[] buckets;    private final Pair TOMBSTONE = new Pair(-1, &quot;-1&quot;); // 墓碑标记    public HashMapOpenAddressing() &#123;        size = 0;        buckets = new Pair[capacity];    &#125;    private int hashFunc(int key) &#123;        return key % capacity;    &#125;    private double loadFactor() &#123;        return (double) size / capacity;    &#125;    private int findBucket(int key) &#123;        int index = hashFunc(key);        int firstTombstone = -1;        // 循环探测        while (buckets[index] != null) &#123;            // 如果找到匹配的key，直接返回            if (buckets[index].key == key) &#123;                // 如果之前遇到了墓碑，做交换优化，让元素更靠近初始位置                if (firstTombstone != -1) &#123;                    buckets[firstTombstone] = buckets[index];                    buckets[index] = TOMBSTONE;                    return firstTombstone;                &#125;                return index; // 直接返回当前位置            &#125;            // 记录遇到的第一个墓碑            if (firstTombstone == -1 &amp;&amp; buckets[index] == TOMBSTONE) &#123;                firstTombstone = index;            &#125;            // 线性探测，移动到下一个位置            index = (index + 1) % capacity;        &#125;        // 循环结束，表示未找到key。        // 如果曾遇到墓碑，返回第一个墓碑的位置（用于插入）；否则返回null的位置。        return firstTombstone == -1 ? index : firstTombstone;    &#125;    public String get(int key) &#123;        int index = findBucket(key);        // 如果找到的位置不为null且不是墓碑，说明找到了        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;            return buckets[index].val;        &#125;        return null;    &#125;    public void put(int key, String val) &#123;        if (loadFactor() &gt; loadThres) &#123;            extend();        &#125;        int index = findBucket(key);        // 如果该位置已有元素（不是null或墓碑），说明是更新操作        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;            buckets[index].val = val;            return;        &#125;        // 否则是插入新元素        buckets[index] = new Pair(key, val);        size++;    &#125;    public void remove(int key) &#123;        int index = findBucket(key);        // 确保该位置有元素再删除        if (buckets[index] != null &amp;&amp; buckets[index] != TOMBSTONE) &#123;            buckets[index] = TOMBSTONE;            size--;        &#125;    &#125;    private void extend() &#123;        Pair[] bucketsTemp = buckets;        capacity *= extendRatio;        buckets = new Pair[capacity];        size = 0; // 重置size，因为put会重新计算        // 遍历旧数组，将非null且非墓碑的元素重新插入        for (Pair pair : bucketsTemp) &#123;            if (pair != null &amp;&amp; pair != TOMBSTONE) &#123;                put(pair.key, pair.val);            &#125;        &#125;    &#125;    public void print() &#123;        for (Pair pair : buckets) &#123;            if (pair == null) &#123;                System.out.println(&quot;null&quot;);            &#125; else if (pair == TOMBSTONE) &#123;                System.out.println(&quot;TOMBSTONE&quot;);            &#125; else &#123;                System.out.println(pair.key + &quot;-&gt;&quot; + pair.val);            &#125;        &#125;    &#125;&#125;","categories":["数据结构"],"tags":["数据结构","学习笔记"]},{"title":"Heap","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Heap/","content":"Heap因为堆是完全二叉树，我们可以尝试用数组下面以大顶堆为例\n\n\n入堆：先把元素加到堆底，之后从低至顶堆化（冒泡即可）void push(int val)&#123;    maxHeap.add(val);    siftUp(size() - 1);&#125;void siftUp(int i)&#123;    while (true)    &#123;        int p = parent(i);        if(p&lt;0 || maxHeap.get(i) &lt;= maxHeap.get(p))        &#123;            break;        &#125;        swap(i,p);        i = p;    &#125;&#125;\n显然一次入堆操作时间复杂度是O（logn),空间复杂度除了储存原本的堆外是O(1)\n出堆一般先交换堆顶和堆底，之后删除堆底（实际上是原来的堆顶），之后从根节点开始自顶置底堆化自顶至底堆化：根节点和两个子节点比较，把最大的子节点和根节点交换，迭代至叶节点或者某个无需交换的节点\nint pop()&#123;    if(isEmpty())    &#123;        throw new IndexOutOfBoundsException();    &#125;    swap(0,size() - 1);    int val = maxHeap.remove(size() - 1);    siftDown(0);    return val;&#125;void siftDown(int i)&#123;    while(true)&#123;        int l = left(i),r = right(i),maxNode = i;        if(l &lt; size() &amp;&amp; maxHeap.get(l) &gt; maxHeap.get(maxNode))        &#123;            maxNode = l;        &#125;        if(r &lt; size() &amp;&amp; maxHeap.get(r) &gt; maxHeap.get(maxNode))        &#123;            maxNode = r;        &#125;        if(maxNode == i)        &#123;            break;        &#125;        swap(i,maxNode);        i = maxNode;    &#125;&#125;\n注意很多语言优先队列就是堆\n建堆操作\n依次入堆法，时间复杂度O(nlogn)\n遍历堆化：先把列表元素直接加入堆，再倒叙遍历堆对每个非叶子点进行 从顶至底堆化\n\nimport java.util.ArrayList;import java.util.List;MaxHeap(List&lt;Integer&gt; nums) &#123;    maxHeap = new ArrayList&lt;&gt;(nums);    for(int i = parent(size() -1);i&gt;=0;i--)    &#123;        siftDown(i);    &#125;&#125;\n复杂度是个差比数列求和：以完美二叉树为例：每层高度记为h，h-1 … 0，单层节点数量则是2^0,2^1 ……2^h;求和得最终是O(2^h),即为O(n).\nTop-k 问题给定一个长度为n 的无序数组 nums ，请返回数组中最大的k 个元素。\n遍历k遍历，每轮找到一个当前最大，时间复杂度O(nk)\n排序先排序再取前k个，O(nlogn)\n堆先初始化一个小顶对；前k个元素入堆；k+1个开始，如果当前元素大于堆顶则堆顶出堆当前元素入堆；遍历完后堆中的就是k个元素\nimport java.util.PriorityQueue;import java.util.Queue;Queue&lt;Integer&gt; topKHeap(int[] nums, int k) &#123;    Queue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;();    for(int i = 0; i&lt; k;i++)    &#123;        heap.offer(nums[i]);    &#125;    for(int i = k;i&lt;nums.length;i++)    &#123;        if (nums[i] &gt; heap.peek())        &#123;            heap.poll();            heap.offer(nums[i]);        &#125;    &#125;    return heap;&#125;\n时间复杂度O（nlogk）。时间复杂度：初始堆构建：我们遵循每次循环最悲观的操作作为单次操作量，就是log(k),因此第一部分就是O（klogk)同时大概想一下，再k&#x2F;2前后开始的复杂度就是log(k)，有超过一半的操作数是这个，因此我们找的上届是合理的后续： O((n-k)log(k))因此最终求和后就是O(nlog(k))\n","categories":["数据结构"],"tags":["数据结构","学习笔记"]},{"title":"graph","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/graph/","content":"图的实现邻接矩阵import java.util.ArrayList;import java.util.List;&lt;!-- more --&gt;class GraphAdjMat &#123;    List&lt;Integer&gt; vertices;//顶点列表，元素代表顶点值，索引是顶点索引    List&lt;List&lt;Integer&gt;&gt; adjMat; //邻接矩阵，行列索引对应顶点索引    public GraphAdjMat(int[] vertices, int[][] edges) &#123;        this.vertices = new ArrayList&lt;&gt;();        this.adjMat = new ArrayList&lt;&gt;();        //添加顶点        for(int val : vertices)        &#123;            addVertex(val);        &#125;        /*                添加边                注意                edges这个二维数组里面表示的是索引对应的顶点直接有边                如int[][] edges = &#123;&#123;0, 1&#125;, &#123;0, 2&#125;, &#123;1, 3&#125;&#125;;                第一个元素&#123;0,1&#125;表示索引0，1对应的顶点之间有边         */        for(int[] e : edges)        &#123;            addEdge(e[0],e[1]);        &#125;    &#125;    public int size()&#123;        return vertices.size();    &#125;    public void addVertex(int val)&#123;        int n = size();        vertices.add(val);        List&lt;Integer&gt; newRow = new ArrayList&lt;&gt;();        for(int j = 0;j &lt; n ;j++)        &#123;            newRow.add(0);        &#125;        adjMat.add(newRow);        for(List&lt;Integer&gt; row : adjMat)&#123;            row.add(0);        &#125;    &#125;    public void removeVertex(int index)&#123;        if (index &gt;= size())        &#123;            throw new IndexOutOfBoundsException();        &#125;        vertices.remove((index));        adjMat.remove(index);        for (List&lt;Integer&gt; row : adjMat)        &#123;            row.remove(index);        &#125;    &#125;        public void addEdge(int i , int j)    &#123;        if(i &lt;0 || j&lt; 0 || i&gt;= size() || j&gt;= size() || i==j)        &#123;            throw new IndexOutOfBoundsException();        &#125;        adjMat.get(i).set(j,1);        adjMat.get(j).set(i,1);    &#125;    public void removeEdge(int i ,int j)&#123;        if(i&lt;0||j&lt;0||i&gt;=size()||j&gt;=size())&#123;            throw new IndexOutOfBoundsException();        &#125;        adjMat.get(i).set(j,0);        adjMat.get(j).set(i,0);    &#125;    public void print()&#123;        System.out.print(&quot;顶点列表 = &quot;);        System.out.println(vertices);        System.out.println(&quot;邻接矩阵 = &quot;);        for (List&lt;Integer&gt; row : adjMat) &#123;            for (int val : row) &#123;                System.out.print(val + &quot; &quot;);            &#125;            System.out.println();         &#125;    &#125;&#125;\n邻接表实际上我们使用Vertex类表示顶点，这样删除时只需要删除一个不需要删除其他（借助哈希表）\nclass Vertex &#123;    int val;    Vertex(int val) &#123;        this.val = val;    &#125;    // 必须重写 equals 方法    @Override    public boolean equals(Object obj) &#123;        if (this == obj) return true;        if (obj == null || getClass() != obj.getClass()) return false;        Vertex vertex = (Vertex) obj;        return val == vertex.val;    &#125;    // 必须重写 hashCode 方法    @Override    public int hashCode() &#123;        return Integer.hashCode(val);    &#125;&#125;\n我们想用Vertex作为key，哈希表必须知道怎么去实现哈希算法从而快速找到把这个key放在哪里，也需要知道怎么去比较两个key是否相等。因此务必重写hashCode(哈希算法)和equals方法。\nimport java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;class GraphAdjList &#123;    Map&lt;Vertex, List&lt;Vertex&gt;&gt; adjList;    public GraphAdjList(Vertex[][] edges) &#123;        this.adjList = new HashMap&lt;&gt;();        for (Vertex[] edge : edges) &#123;            addVertex(edge[0]);            addVertex(edge[1]);            addEdge(edge[0], edge[1]);        &#125;    &#125;    public int size() &#123;        return adjList.size();    &#125;    public void addEdge(Vertex vet1, Vertex vet2) &#123;        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2)) &#123;            throw new IllegalArgumentException();        &#125;        adjList.get(vet1).add(vet2);        adjList.get(vet2).add(vet1);    &#125;    public void removeEdge(Vertex vet1, Vertex vet2) &#123;        if (!adjList.containsKey(vet1) || !adjList.containsKey(vet2) || vet1 == vet2) &#123;            throw new IllegalArgumentException();        &#125;        adjList.get(vet1).remove(vet2);        adjList.get(vet2).remove(vet1);    &#125;    public void addVertex(Vertex vet) &#123;        if (adjList.containsKey(vet)) &#123;            return;        &#125;        adjList.put(vet, new ArrayList&lt;&gt;());    &#125;    public void removeVertex(Vertex vet) &#123;        if (!adjList.containsKey(vet)) &#123;            throw new IllegalArgumentException();        &#125;        adjList.remove(vet);        for (List&lt;Vertex&gt; list : adjList.values()) &#123;            list.remove((vet));        &#125;    &#125;    public void print() &#123;        System.out.println(&quot;邻接表 = &quot;);        for (Map.Entry&lt;Vertex,List&lt;Vertex&gt;&gt; pair : adjList.entrySet())        &#123;            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();            for (Vertex vertex : pair.getValue())            &#123;                temp.add(vertex.val);            &#125;            System.out.println(pair.getKey().val + &quot;: &quot; + temp + &quot;,&quot;);        &#125;    &#125;&#125;\n\n\n\n\n邻接矩阵\n邻接表（链表）\n邻接表（哈希表）\n\n\n\n判断是否邻接\nO(1)\nO(n)\nO(1)\n\n\n添加边\nO(1)\nO(1)\nO(1)\n\n\n删除边\nO(1)\nO(n)\nO(1)\n\n\n添加顶点\nO(n)\nO(1)\nO(1)\n\n\n删除顶点\nO(n*n)\nO(n+m)\nO(n+m)\n\n\n内存空间\nO(n*n)\nO(n+m)\nO(n+m)\n\n\n请注意，邻接表（链表）对应本文实现，而邻接表（哈希表）专指将所有链表替换为哈希表后的实现。\n图的遍历广度遍历（BFS）使用队列遍历起始顶点加入队列，每次迭代弹出队首病记录访问，之后把顶点所有的邻接节点加入队尾\nimport java.util.ArrayList;import java.util.HashSet;import java.util.LinkedList;import java.util.Queue;List&lt;Vertex&gt; graphBFS(GraphAdjList graph, Vertex startVet) &#123;    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();    visited.add(startVet);    Queue&lt;Vertex&gt; que = new LinkedList&lt;&gt;();    que.offer(startVet);    while (!que.isEmpty())    &#123;        Vertex vet = que.poll();        res.add(vet);        //相当于遍历边        for(Vertex adjVet : graph.adjList.get(vet))        &#123;            if(visited.contains(adjVet))            &#123;                continue;            &#125;            que.offer(adjVet);            visited.add(adjVet);        &#125;    &#125;    return res;&#125;\n时间复杂度：O(V+E)空间复杂度：OO（V）\n深度优先（DFS）import java.util.ArrayList;import java.util.HashSet;import java.util.List;void dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) &#123;    if (visited.contains(vet)) &#123;        return;    &#125;    res.add(vet);    visited.add(vet);    //依然是，访问邻接节点相当于再访问边。    for (Vertex adjVet : graph.adjList.get(vet)) &#123;        dfs(graph, visited, res, adjVet);    &#125;&#125;List&lt;Vertex&gt; graphDFS(GraphAdjList graph, Vertex startVet) &#123;    List&lt;Vertex&gt; res = new ArrayList&lt;&gt;();    Set&lt;Vertex&gt; visited = new HashSet&lt;&gt;();    dfs(graph,visited,res,startVet);    return res;&#125;\n可以优化成调用前检查\nvoid dfs(GraphAdjList graph, Set&lt;Vertex&gt; visited, List&lt;Vertex&gt; res, Vertex vet) &#123;    res.add(vet);     // 记录访问顶点    visited.add(vet); // 标记该顶点已被访问    // 遍历该顶点的所有邻接顶点    for (Vertex adjVet : graph.adjList.get(vet)) &#123;        //基本情况隐藏在这里，如果所有邻接节点都被访问，就会返回        if (visited.contains(adjVet))            continue; // 跳过已被访问的顶点        // 递归访问邻接顶点        dfs(graph, visited, res, adjVet);    &#125;&#125;\n显式写出基本情况时，如果某个邻接节点被访问过，依然会递归调用一次dfs，性能会略微低点。时间复杂度：O(V+E)，所有顶点都会被访问一次，用O（V）时间，所有边被访问两次，O（E）空间复杂度：res，visited都是O（V），递归深度最多也是O（V），总体就是O（V）。\n","categories":["数据结构"],"tags":["数据结构","学习笔记"]},{"title":"Tree","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Tree/","content":"二叉树遍历层序遍历（广度优先，bfs）广度优先，和队列的“先进先出”类似。因此考虑使用队列\n\n\n\nimport javax.swing.tree.TreeNode;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import java.util.Queue;List&lt;Integer&gt; levelOrder(TreeNode root) &#123;    //初始化一个队列,作为遍历过程中的临时储存。    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.add(root);    //初始化一个列表储存结果    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();    while (!queue.isEmpty())    &#123;        TreeNode node = queue.poll();//出队        result.add(node.val);        if(node.left != null)&#123;            queue.offer(node.left);        &#125;        if(node.right != null)        &#123;            queue.offer(node.right);        &#125;    &#125;    return result;&#125;\n时间复杂度：O(N).要访问所有节点空间复杂度：O(N).队列和result占用空间\n深度优先（前序，中序，后序）前序：当前节点-&gt;左子树-&gt;右子树中序：左子树-&gt;当前节点-&gt;右子树后序：左子树-&gt;右子树-&gt;当前节点\nimport javax.swing.tree.TreeNode;import java.util.LinkedList;import java.util.List;List&lt;Integer&gt; list = new LinkedList&lt;&gt;();void preOrder(TreeNode cur) &#123;    if (cur == null) &#123;        return;    &#125;    list.add(cur.val);    preOrder(cur.left);    preOrder(cur.right);&#125;void inOrder(TreeNode cur)&#123;    if(cur == null)    &#123;        return;    &#125;    inOrder(cur.left);    list.add(cur.val);    inOrder(cur.right);&#125;void postOrder(TreeNode cur)&#123;    if(cur == null)    &#123;        return;    &#125;    postOrder(cur.left);    postOrder(cur.right);    list.add(cur.val);&#125;\n时间复杂度：都是O(N)，因为要遍历所有节点空间复杂度: O(N)。list储存结果是O（N）；栈帧应该是O(logN),因为每次要按深度递到叶节点后再归，理想状态平衡的话应当是O（logN），如果退化成链表就是O(N)\n数组表示import java.util.ArrayList;import java.util.List;import java.util.concurrent.ArrayBlockingQueue;class ArrayBinaryTree &#123;    private List&lt;Integer&gt; tree;    public ArrayBinaryTree(List&lt;Integer&gt; arr) &#123;        tree = new ArrayList&lt;&gt;(arr);    &#125;    public int size()&#123;        return tree.size();    &#125;    public Integer val(int i )&#123;        if(i&lt;0 || i&gt;= size())        &#123;            return null;        &#125;        return tree.get(i);    &#125;    public Integer left(int i)    &#123;        return 2 * i + 1;    &#125;     public Integer right(int i)    &#123;        return 2*i+2;    &#125;    public Integer parent(int i)&#123;        return (i - 1) / 2;    &#125;    public List&lt;Integer&gt; levelOrder()&#123;        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        for(int i =0;i &lt; size();i++)        &#123;            if(val(i) != null)            &#123;                res.add(val(i));            &#125;        &#125;        return res;    &#125;    private void dfs(Integer i, String order, List&lt;Integer&gt; res) &#123;        if (i &gt;= size() || val(i) == null) &#123; // 索引越界或节点为空            return;        &#125;        if (&quot;pre&quot;.equals(order)) &#123;            res.add(val(i));            dfs(left(i), order, res);            dfs(right(i), order, res);        &#125; else if (&quot;in&quot;.equals(order)) &#123;            dfs(left(i), order, res);            res.add(val(i));            dfs(right(i), order, res);        &#125; else if (&quot;post&quot;.equals(order)) &#123;            dfs(left(i), order, res);            dfs(right(i), order, res);            res.add(val(i));        &#125;    &#125;&#125;\n\n二叉搜索树左子树&lt;根节点&lt;右子树，任意子树也满足\n查找节点import javax.swing.tree.TreeNode;TreeNode search(int num)&#123;    TreeNode cur = root;    while (cur != null)    &#123;        if(cur.val &lt; num)        &#123;            cur = cur.right;        &#125; else if (cur.val &gt; num) &#123;            cur = cur.left;        &#125;        else&#123;            break;        &#125;    &#125;    return cur;&#125;\n类似二分查找，时间复杂度是O(logN)(在二叉树平衡时）, 空间复杂度O(1)\n插入节点一般直接插在合适的末端，作为新的叶节点，这样更方便先查找再插入\nimport javax.swing.tree.TreeNode;void insert(int num) &#123;    if (root == null) &#123;        root = new TreeNode(num);        return;    &#125;    TreeNode cur = root,pre = null;    while (cur != null)    &#123;        if(cur.val == num )        &#123;            return;        &#125;        pre = cur;        if(cur.val &lt; num)        &#123;            cur = cur.right;        &#125;        else&#123;            cur = cur.left;        &#125;    &#125;    TreeNode node = new TreeNode(num);    if(pre.val &lt; num)    &#123;        pre.right = node;    &#125;    else &#123;        pre.left = node;    &#125;&#125;\n时间复杂度平衡时也是O（logN).\n删除节点需分情况，要删的节点的度是0，1，2其中度为二时为了保证满足二叉搜索树。需要用一个节点替换被删除的节点，可以是右子树最小节点或者左子树最大节点。这里我们使用右子树最小节点（也就是中序遍历的下一个节点，左子树-&gt;当前节点-&gt;右子树）\nimport javax.swing.tree.TreeNode;TreeNode root;void remove(int num) &#123;    if (root == null) &#123;        return;    &#125;    TreeNode cur = root,pre = null;    //查找    while(cur != null)    &#123;        if(cur.val == num)        &#123;            break;        &#125;        pre = cur;        if(cur.val &lt; num)        &#123;            cur = cur.right;        &#125;        else &#123;            cur = cur.left;        &#125;    &#125;    if(cur == null)    &#123;        return;    &#125;    if(cur.left == null || cur.right ==null)    &#123;        TreeNode child = (cur.left != null ? cur.left : cur.right);        if(cur != root)        &#123;            if(pre.left == cur)            &#123;                pre.left =child;            &#125;            else&#123;                pre.right = child;            &#125;        &#125;        else&#123;            root = child;        &#125;    &#125;    //度为二    else &#123;        TreeNode temp = cur.right;        TreeNode tempParent = cur;        //查找右子树的最小节点        while (temp.left != null)        &#123;            tempParent = temp;            temp = temp.left;        &#125;        cur.val = temp.val;        //删除后继节点        if(tempParent.left == temp)        &#123;            tempParent.left = temp.right;        &#125;        else&#123;            tempParent.right = temp.right;        &#125;    &#125;&#125;\n时间复杂度: 查找O(logn),获取中序遍历后继节点O(logn)，最终是O（logn)空间复杂度：O（1）因此平衡的二叉搜索树的增删查都是O(logN)\n","categories":["数据结构"],"tags":["数据结构","学习笔记"]},{"title":"栈与队列","url":"/2025/09/15/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"栈、队列与双端队列核心笔记1. 栈 (Stack)1.1 定义与原则栈是一种 后进先出 (Last-In, First-Out, LIFO) 的线性数据结构。所有操作均在数据结构的同一端——栈顶 (Top) 进行。\n\n\n\n1.2 核心操作\n\n\n操作\n描述\n时间复杂度\n\n\n\npush(element)\n将元素压入栈顶\nO(1)\n\n\npop()\n移除并返回栈顶元素\nO(1)\n\n\npeek()\n查看栈顶元素，不移除\nO(1)\n\n\nisEmpty()\n检查栈是否为空\nO(1)\n\n\nsize()\n返回栈中元素数量\nO(1)\n\n\n1.3 实现方式1.3.1 基于数组 (ArrayStack)\n机制: 使用动态数组（如 ArrayList）实现，将数组的尾部视为栈顶。\n优点:\n内存连续，CPU缓存命中率高，访问速度快。\n实现简单。\n\n\n缺点:\npush 操作在数组容量不足时会触发扩容，导致该次操作的最坏时间复杂度为 O(N)。其均摊时间复杂度为 O(1)。\n\n\n\n1.3.2 基于链表 (LinkedListStack)\n机制: 使用单向链表实现，将链表的头节点视为栈顶。\n优点:\n所有操作的时间复杂度均为**稳定的 O(1)**。\n空间按需分配，无容量限制。\n\n\n缺点:\n每个节点需要额外空间存储指针，内存开销较大。\n内存不连续，缓存性能可能较差。\n\n\n\n1.4 核心应用场景\n函数调用栈: 管理函数调用的上下文信息。\n表达式求值: 中缀表达式转后缀（逆波兰）表达式并计算。\n括号匹配: 校验字符串中的括号是否合法。\n深度优先搜索 (DFS): 图与树的遍历（递归或非递归实现）。\n撤销&#x2F;重做功能: 编辑器中的 Undo&#x2F;Redo 操作。\n单调栈: 解决“下一个更大&#x2F;更小元素”等问题。\n\n\n2. 队列 (Queue)2.1 定义与原则队列是一种 先进先出 (First-In, First-Out, FIFO) 的线性数据结构。元素从队尾 (Rear) 加入，从队首 (Front) 离开。\n2.2 核心操作\n\n\n操作\n描述\n时间复杂度\n\n\n\npush(element)\n元素在队尾入队\nO(1)\n\n\npop()\n队首元素出队并返回\nO(1)\n\n\npeek()\n查看队首元素，不移除\nO(1)\n\n\nisEmpty()\n检查队列是否为空\nO(1)\n\n\nsize()\n返回队列中元素数量\nO(1)\n\n\n2.3 实现方式2.3.1 基于环形数组 (ArrayQueue)\n机制: 使用固定长度的数组，通过 front 指针和 size 计数器（或 front 和 rear 两个指针）实现。指针移动通过取模运算 (index + 1) % capacity 实现循环，避免了数据迁移。\n优点:\n所有操作均为稳定的 O(1) 时间复杂度。\n内存连续，缓存友好。\n\n\n缺点:\n容量固定，无法动态扩展。\n\n\n\n2.3.2 基于链表 (LinkedListQueue)\n机制: 使用单向链表，维护 front 和 rear 两个指针分别指向头节点和尾节点。\n优点:\n动态容量，无空间限制。\n所有操作均为稳定的 O(1) 时间复杂度。\n\n\n缺点:\n额外的指针内存开销。\n内存不连续。\n\n\n\n2.4 核心应用场景\n广度优先搜索 (BFS): 图与树的层序遍历。\n资源调度: 操作系统的任务调度、线程池的任务队列。\n消息队列 (MQ): 在分布式系统中用于解耦、异步通信和流量削峰。\n缓存淘汰策略: 实现 FIFO 缓存。\n\n\n3. 双端队列 (Deque)3.1 定义与原则双端队列 (Double-Ended Queue) 是栈和队列的泛化，允许在队首和队尾两端进行插入和删除操作。\n3.2 核心操作包含队首和队尾两套对称的操作：pushFirst, pushLast, popFirst, popLast, peekFirst, peekLast。所有核心操作的时间复杂度均为 O(1)。\n3.3 实现方式3.3.1 基于环形数组 (ArrayDeque)\n机制: 与环形队列类似，但 front 指针可以双向移动。为防止负数索引，front 向前移动的逻辑为 (front - 1 + capacity) % capacity。\n优点:\n功能强大，高性能，是 Java 中实现栈和队列的首选推荐。\n\n\n缺点:\n容量固定（尽管 Java 的 ArrayDeque 实现了自动扩容）。\n\n\n\n3.3.2 基于双向链表 (LinkedListDeque)\n机制: 必须使用双向链表，每个节点包含 prev 和 next 两个指针，以支持在两端进行 O(1) 的删除操作。\n优点:\n动态容量，实现灵活。\n\n\n缺点:\n指针的内存开销是所有实现中最大的。\n\n\n\n3.4 核心应用场景\n实现栈和队列: 可同时作为栈（使用 pushFirst&#x2F;popFirst）和队列（使用 pushLast&#x2F;popFirst）使用。\n滑动窗口问题: 高效求解滑动窗口中的最值问题（维护一个单调的双端队列）。\n历史记录管理: 如浏览器的前进&#x2F;后退功能。\n\n\n4. 总结与选择\n\n\n特性\n数组实现\n链表实现\n\n\n\n时间复杂度\n入&#x2F;出队&#x2F;栈: 平均 O(1)。数组扩容时最坏为 O(N)。\n入&#x2F;出队&#x2F;栈: 稳定 O(1)。\n\n\n空间复杂度\n元素本身开销小，但可能预分配了未使用空间。\n每个元素需额外空间存储指针。\n\n\n内存模型\n连续内存，缓存友好。\n离散内存，可能导致缓存未命中。\n\n\n容量\n固定或需要昂贵的扩容操作。\n动态调整，灵活。\n\n\n实践建议\n在 Java 中，当需要栈或队列结构时，**ArrayDeque 是首选**。它比 Stack 类（因继承 Vector 而有线程同步开销，性能较差）和 LinkedList（作为队列或栈使用时，底层节点对象开销较大）通常有更好的性能。\n当数据规模不确定，且不希望有任何性能抖动（如实时系统）时，链表实现是更安全的选择。\n\n\n5. 附录: 完整代码实现5.1 栈实现\nArrayStack.java (点击展开)\n\nimport java.util.ArrayList;public class ArrayStack &#123;    // 使用 ArrayList 实现，尾部作为栈顶    private ArrayList&lt;Integer&gt; stack;    public ArrayStack() &#123;        stack = new ArrayList&lt;&gt;();    &#125;    public int size() &#123;        return stack.size();    &#125;    public boolean isEmpty() &#123;        return stack.isEmpty();    &#125;    public void push(int num) &#123;        stack.add(num);    &#125;    public int pop() &#123;        if (isEmpty()) &#123;            // 在实际应用中，更推荐抛出 NoSuchElementException            return -1;        &#125;        return stack.remove(size() - 1);    &#125;    public int peek() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return stack.get(size() - 1);    &#125;    public Object[] toArray() &#123;        return stack.toArray();    &#125;&#125;\n\n\n\nLinkedListStack.java (点击展开)\n\n// 辅助节点类class ListNode &#123;    int val;    ListNode next;    ListNode(int val) &#123; this.val = val; &#125;&#125;public class LinkedListStack &#123;    // 头节点视为栈顶    private ListNode stackPeek;    private int stkSize;    public LinkedListStack() &#123;        stackPeek = null;        stkSize = 0;    &#125;    public int getStkSize() &#123;        return stkSize;    &#125;    public boolean isEmpty() &#123;        return stkSize == 0;    &#125;    public void push(int val) &#123;        ListNode node = new ListNode(val);        node.next = stackPeek;        stackPeek = node;        stkSize++;    &#125;    public int pop() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        int val = stackPeek.val;        stackPeek = stackPeek.next;        stkSize--;        return val;    &#125;    public int peek() &#123;        if (isEmpty()) &#123;            return -1;        &#125;        return stackPeek.val;    &#125;    public int[] toArray() &#123;        int[] res = new int[stkSize];        ListNode curr = stackPeek;        for (int i = 0; i &lt; stkSize; i++) &#123;            res[i] = curr.val;            curr = curr.next;        &#125;        return res;    &#125;&#125;\n\n\n5.2 队列实现\nArrayQueue.java (点击展开)\n\npublic class ArrayQueue &#123;    /*    环形数组实现队列。    front指向首元素，维护size，rear = （size + front）%nums.length    实现capacity，size,isEmpty,push,pop,peek,toArray方法     */    private int[] nums;    private int front ;    private int queSize;    public ArrayQueue(int capacity)    &#123;        nums = new int[capacity];        front = queSize = 0;    &#125;    public int capacity()    &#123;        /*        返回整个数组长度         */        return nums.length;    &#125;    public int size()    &#123;        return queSize;    &#125;    public boolean isEmpty()    &#123;        return queSize == 0;    &#125;    public void push(int num)    &#123;        if(isEmpty())        &#123;            nums[front] = num;            queSize++;            return;        &#125;        if(capacity() == queSize)        &#123;            System.out.println(&quot;wrong&quot;);            return;        &#125;        int rear = (front + queSize)%capacity();        nums[rear] = num;        queSize++;        return;    &#125;    public int pop()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        int temp = nums[front];        front = (front+1) % capacity();        queSize--;        return temp;    &#125;    public int peek()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        return nums[front];    &#125;    public int[] toArray()    &#123;        int[] res = new int[queSize];        int curr = front;        for (int i = 0; i &lt; queSize; i++) &#123;            res[i] = nums[curr];            curr = (curr + 1)%capacity();        &#125;        return res;    &#125;&#125;\n\n\n5.3双向队列实现public class ArrayDeque &#123;    /*    环形数组实现    capacity,size,isEmpty,index,pushFirst,pushLast,popFirst    popLast,peekFirst,peekLast,toArray方法     */    private int[] nums;    private int front;    private int queSize;    public ArrayDeque(int capacity)    &#123;        this.nums = new int[capacity];        front = 0;        queSize = 0;    &#125;    public int capacity()    &#123;        return nums.length;    &#125;    public boolean isEmpty()    &#123;        return queSize == 0;    &#125;    public int index(int i)    &#123;        /*        为什么不直接 i % capacity()？        因为在Java中，负数取余的结果还是负数或0（例如 -1 % 10 的结果是 -1）        这仍然是无效索引。         */        return (i + capacity())%capacity();    &#125;    public void pushFirst(int num)    &#123;        if(queSize == capacity())        &#123;            return;        &#125;        front = index(front-1);        nums[front] = num;        queSize++;    &#125;    public void pushLast(int num)    &#123;        if(queSize == capacity())        &#123;            return;        &#125;        int rear =index (front + queSize) ;        nums[rear] = num;        queSize++;    &#125;    public int popFirst()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        int temp = nums[front];        front = index(front+1);        queSize--;        return temp;    &#125;    public int popLast()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        int temp = peekLast();        queSize--;        return temp;    &#125;    public int peekFirst()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        return nums[front];    &#125;    public int peekLast()    &#123;        if(isEmpty())        &#123;            return -1;        &#125;        int last = index(front + queSize -1);        return nums[last];    &#125;    public int[] toArray()    &#123;        int[] res = new int[queSize];        int curr = front;        for (int i = 0; i &lt; queSize; i++) &#123;            res[i] = nums[curr];            curr = index(curr + 1);        &#125;        return res;    &#125;&#125;","categories":["数据结构"],"tags":["数据结构","学习笔记"]}]